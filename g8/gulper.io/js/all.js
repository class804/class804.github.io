function FromString(e) {
for (var t = e.length, n = new Uint32Array(t), r = 0, i = 0; i < t; i++, r++) {
var a = e.charCodeAt(i);
if (55296 > a || 57344 <= a) n[r] = a; else {
i++;
var o = e.charCodeAt(i);
if (56320 <= a || 56320 > o) return [];
n[r] = (a - 55296 << 10) + o + 9216;
}
}
return n.slice(0, r);
}

function FromUTF8(e) {
for (var t = e.length, n = new Uint32Array(t), r = 0, i = 0; i < t; i++, r++) {
var a = e[i];
if (0 != (128 & a)) {
if (0 == (64 & a)) return [];
var o = e[++i];
if (0 == (32 & a)) {
if (n[r] = (31 & a) << 6 | 63 & o, 128 == (192 & o)) continue;
return [];
}
var s = e[++i];
if (0 == (16 & a)) {
if (n[r] = (15 & a) << 12 | (63 & o) << 6 | 63 & s, 128 == (192 & o) && 128 == (192 & s)) continue;
return [];
}
var c = e[++i];
if (0 == (8 & a) && (n[r] = (7 & a) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & c, 
128 == (192 & o) && 128 == (192 & s) && 128 == (192 & c))) continue;
return [];
}
n[r] = a;
}
return n.slice(0, r);
}

function FromUTF16(e) {
for (var t = e.length, n = new Uint32Array(t), r = 0, i = 0; i < t; i++, r++) {
var a = e[i];
if (55296 > a || 57344 <= a) n[r] = a; else {
var o = e[++i];
if (56320 <= a || 56320 > o) return [];
n[r] = (a - 55296 << 10) + o + 9216;
}
}
return n.slice(0, r);
}

function ToString(e) {
for (var t = (e = ToUTF16(e)).length, n = "", r = 0; r < t; r++) n += String.fromCharCode(e[r]);
return n;
}

function ToUTF8(e) {
for (var t = e.length, n = new Uint8Array(t << 2), r = 0, i = 0; i < t; i++, r++) {
var a = e[i];
if (128 > a) n[r] = a; else if (2048 > a) n[r] = a >>> 6 | 192, n[++r] = 63 & a | 128; else if (65536 > a) n[r] = a >>> 12 | 224, 
n[++r] = a >>> 6 & 63 | 128, n[++r] = 63 & a | 128; else {
if (!(1114112 > a)) return [];
n[r] = a >>> 18 | 240, n[++r] = a >>> 12 & 63 | 128, n[++r] = a >>> 6 & 63 | 128, 
n[++r] = 63 & a | 128;
}
}
return n.slice(0, r);
}

function ToUTF16(e) {
for (var t = e.length, n = new Uint16Array(t << 1), r = 0, i = 0; i < t; i++, r++) {
var a = e[i];
if (55296 > a || 57344 <= a && 65536 > a) n[r] = a; else {
if (55296 <= a && 57344 > a) return [];
a -= 65536, n[r] = 55296 + (a >>> 10), n[++r] = 56320 + (1023 & a);
}
}
return n.slice(0, r);
}

!function(e, t) {
"use strict";
"object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
if (!e.document) throw new Error("jQuery requires a window with a document");
return t(e);
} : t(e);
}("undefined" != typeof window ? window : this, function(e, t) {
"use strict";
var n = [], r = Object.getPrototypeOf, i = n.slice, a = n.flat ? function(e) {
return n.flat.call(e);
} : function(e) {
return n.concat.apply([], e);
}, o = n.push, s = n.indexOf, c = {}, l = c.toString, u = c.hasOwnProperty, h = u.toString, d = h.call(Object), p = {}, f = function(e) {
return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item;
}, m = function(e) {
return null != e && e === e.window;
}, g = e.document, v = {
type: !0,
src: !0,
nonce: !0,
noModule: !0
};
function y(e, t, n) {
var r, i, a = (n = n || g).createElement("script");
if (a.text = e, t) for (r in v) (i = t[r] || t.getAttribute && t.getAttribute(r)) && a.setAttribute(r, i);
n.head.appendChild(a).parentNode.removeChild(a);
}
function $(e) {
return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? c[l.call(e)] || "object" : typeof e;
}
var b = "3.6.0", x = function(e, t) {
return new x.fn.init(e, t);
};
function w(e) {
var t = !!e && "length" in e && e.length, n = $(e);
return !f(e) && !m(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
}
x.fn = x.prototype = {
jquery: b,
constructor: x,
length: 0,
toArray: function() {
return i.call(this);
},
get: function(e) {
return null == e ? i.call(this) : e < 0 ? this[e + this.length] : this[e];
},
pushStack: function(e) {
var t = x.merge(this.constructor(), e);
return t.prevObject = this, t;
},
each: function(e) {
return x.each(this, e);
},
map: function(e) {
return this.pushStack(x.map(this, function(t, n) {
return e.call(t, n, t);
}));
},
slice: function() {
return this.pushStack(i.apply(this, arguments));
},
first: function() {
return this.eq(0);
},
last: function() {
return this.eq(-1);
},
even: function() {
return this.pushStack(x.grep(this, function(e, t) {
return (t + 1) % 2;
}));
},
odd: function() {
return this.pushStack(x.grep(this, function(e, t) {
return t % 2;
}));
},
eq: function(e) {
var t = this.length, n = +e + (e < 0 ? t : 0);
return this.pushStack(0 <= n && n < t ? [ this[n] ] : []);
},
end: function() {
return this.prevObject || this.constructor();
},
push: o,
sort: n.sort,
splice: n.splice
}, x.extend = x.fn.extend = function() {
var e, t, n, r, i, a, o = arguments[0] || {}, s = 1, c = arguments.length, l = !1;
for ("boolean" == typeof o && (l = o, o = arguments[s] || {}, s++), "object" == typeof o || f(o) || (o = {}), 
s === c && (o = this, s--); s < c; s++) if (null != (e = arguments[s])) for (t in e) r = e[t], 
"__proto__" !== t && o !== r && (l && r && (x.isPlainObject(r) || (i = Array.isArray(r))) ? (n = o[t], 
a = i && !Array.isArray(n) ? [] : i || x.isPlainObject(n) ? n : {}, i = !1, o[t] = x.extend(l, a, r)) : void 0 !== r && (o[t] = r));
return o;
}, x.extend({
expando: "jQuery" + (b + Math.random()).replace(/\D/g, ""),
isReady: !0,
error: function(e) {
throw new Error(e);
},
noop: function() {},
isPlainObject: function(e) {
var t, n;
return !(!e || "[object Object]" !== l.call(e) || (t = r(e)) && ("function" != typeof (n = u.call(t, "constructor") && t.constructor) || h.call(n) !== d));
},
isEmptyObject: function(e) {
var t;
for (t in e) return !1;
return !0;
},
globalEval: function(e, t, n) {
y(e, {
nonce: t && t.nonce
}, n);
},
each: function(e, t) {
var n, r = 0;
if (w(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++) ; else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;
return e;
},
makeArray: function(e, t) {
var n = t || [];
return null != e && (w(Object(e)) ? x.merge(n, "string" == typeof e ? [ e ] : e) : o.call(n, e)), 
n;
},
inArray: function(e, t, n) {
return null == t ? -1 : s.call(t, e, n);
},
merge: function(e, t) {
for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
return e.length = i, e;
},
grep: function(e, t, n) {
for (var r = [], i = 0, a = e.length, o = !n; i < a; i++) !t(e[i], i) !== o && r.push(e[i]);
return r;
},
map: function(e, t, n) {
var r, i, o = 0, s = [];
if (w(e)) for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && s.push(i); else for (o in e) null != (i = t(e[o], o, n)) && s.push(i);
return a(s);
},
guid: 1,
support: p
}), "function" == typeof Symbol && (x.fn[Symbol.iterator] = n[Symbol.iterator]), 
x.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
c["[object " + t + "]"] = t.toLowerCase();
});
var _ = function(e) {
var t, n, r, i, a, o, s, c, l, u, h, d, p, f, m, g, v, y, $, b = "sizzle" + 1 * new Date(), x = e.document, w = 0, _ = 0, M = ce(), S = ce(), A = ce(), T = ce(), L = function(e, t) {
return e === t && (h = !0), 0;
}, C = {}.hasOwnProperty, E = [], P = E.pop, k = E.push, O = E.push, D = E.slice, N = function(e, t) {
for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
return -1;
}, I = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", R = "[\\x20\\t\\r\\n\\f]", j = "(?:\\\\[\\da-fA-F]{1,6}" + R + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", U = "\\[" + R + "*(" + j + ")(?:" + R + "*([*^$|!~]?=)" + R + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + j + "))|)" + R + "*\\]", B = ":(" + j + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + U + ")*)|.*)\\)|)", z = new RegExp(R + "+", "g"), F = new RegExp("^" + R + "+|((?:^|[^\\\\])(?:\\\\.)*)" + R + "+$", "g"), G = new RegExp("^" + R + "*," + R + "*"), V = new RegExp("^" + R + "*([>+~]|" + R + ")" + R + "*"), W = new RegExp(R + "|>"), q = new RegExp(B), H = new RegExp("^" + j + "$"), X = {
ID: new RegExp("^#(" + j + ")"),
CLASS: new RegExp("^\\.(" + j + ")"),
TAG: new RegExp("^(" + j + "|[*])"),
ATTR: new RegExp("^" + U),
PSEUDO: new RegExp("^" + B),
CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + R + "*(even|odd|(([+-]|)(\\d*)n|)" + R + "*(?:([+-]|)" + R + "*(\\d+)|))" + R + "*\\)|)", "i"),
bool: new RegExp("^(?:" + I + ")$", "i"),
needsContext: new RegExp("^" + R + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + R + "*((?:-\\d)?\\d*)" + R + "*\\)|)(?=[^-]|$)", "i")
}, Y = /HTML$/i, J = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + R + "?|\\\\([^\\r\\n\\f])", "g"), ne = function(e, t) {
var n = "0x" + e.slice(1) - 65536;
return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320));
}, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function(e, t) {
return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
}, ae = function() {
d();
}, oe = be(function(e) {
return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
}, {
dir: "parentNode",
next: "legend"
});
try {
O.apply(E = D.call(x.childNodes), x.childNodes), E[x.childNodes.length].nodeType;
} catch (t) {
O = {
apply: E.length ? function(e, t) {
k.apply(e, D.call(t));
} : function(e, t) {
for (var n = e.length, r = 0; e[n++] = t[r++]; ) ;
e.length = n - 1;
}
};
}
function se(e, t, r, i) {
var a, s, l, u, h, f, v, y = t && t.ownerDocument, x = t ? t.nodeType : 9;
if (r = r || [], "string" != typeof e || !e || 1 !== x && 9 !== x && 11 !== x) return r;
if (!i && (d(t), t = t || p, m)) {
if (11 !== x && (h = Q.exec(e))) if (a = h[1]) {
if (9 === x) {
if (!(l = t.getElementById(a))) return r;
if (l.id === a) return r.push(l), r;
} else if (y && (l = y.getElementById(a)) && $(t, l) && l.id === a) return r.push(l), 
r;
} else {
if (h[2]) return O.apply(r, t.getElementsByTagName(e)), r;
if ((a = h[3]) && n.getElementsByClassName && t.getElementsByClassName) return O.apply(r, t.getElementsByClassName(a)), 
r;
}
if (n.qsa && !T[e + " "] && (!g || !g.test(e)) && (1 !== x || "object" !== t.nodeName.toLowerCase())) {
if (v = e, y = t, 1 === x && (W.test(e) || V.test(e))) {
for ((y = ee.test(e) && ve(t.parentNode) || t) === t && n.scope || ((u = t.getAttribute("id")) ? u = u.replace(re, ie) : t.setAttribute("id", u = b)), 
s = (f = o(e)).length; s--; ) f[s] = (u ? "#" + u : ":scope") + " " + $e(f[s]);
v = f.join(",");
}
try {
return O.apply(r, y.querySelectorAll(v)), r;
} catch (t) {
T(e, !0);
} finally {
u === b && t.removeAttribute("id");
}
}
}
return c(e.replace(F, "$1"), t, r, i);
}
function ce() {
var e = [];
return function t(n, i) {
return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i;
};
}
function le(e) {
return e[b] = !0, e;
}
function ue(e) {
var t = p.createElement("fieldset");
try {
return !!e(t);
} catch (e) {
return !1;
} finally {
t.parentNode && t.parentNode.removeChild(t), t = null;
}
}
function he(e, t) {
for (var n = e.split("|"), i = n.length; i--; ) r.attrHandle[n[i]] = t;
}
function de(e, t) {
var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
if (r) return r;
if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
return e ? 1 : -1;
}
function pe(e) {
return function(t) {
return "input" === t.nodeName.toLowerCase() && t.type === e;
};
}
function fe(e) {
return function(t) {
var n = t.nodeName.toLowerCase();
return ("input" === n || "button" === n) && t.type === e;
};
}
function me(e) {
return function(t) {
return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && oe(t) === e : t.disabled === e : "label" in t && t.disabled === e;
};
}
function ge(e) {
return le(function(t) {
return t = +t, le(function(n, r) {
for (var i, a = e([], n.length, t), o = a.length; o--; ) n[i = a[o]] && (n[i] = !(r[i] = n[i]));
});
});
}
function ve(e) {
return e && void 0 !== e.getElementsByTagName && e;
}
for (t in n = se.support = {}, a = se.isXML = function(e) {
var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement;
return !Y.test(t || n && n.nodeName || "HTML");
}, d = se.setDocument = function(e) {
var t, i, o = e ? e.ownerDocument || e : x;
return o != p && 9 === o.nodeType && o.documentElement && (f = (p = o).documentElement, 
m = !a(p), x != p && (i = p.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", ae, !1) : i.attachEvent && i.attachEvent("onunload", ae)), 
n.scope = ue(function(e) {
return f.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length;
}), n.attributes = ue(function(e) {
return e.className = "i", !e.getAttribute("className");
}), n.getElementsByTagName = ue(function(e) {
return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length;
}), n.getElementsByClassName = K.test(p.getElementsByClassName), n.getById = ue(function(e) {
return f.appendChild(e).id = b, !p.getElementsByName || !p.getElementsByName(b).length;
}), n.getById ? (r.filter.ID = function(e) {
var t = e.replace(te, ne);
return function(e) {
return e.getAttribute("id") === t;
};
}, r.find.ID = function(e, t) {
if (void 0 !== t.getElementById && m) {
var n = t.getElementById(e);
return n ? [ n ] : [];
}
}) : (r.filter.ID = function(e) {
var t = e.replace(te, ne);
return function(e) {
var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
return n && n.value === t;
};
}, r.find.ID = function(e, t) {
if (void 0 !== t.getElementById && m) {
var n, r, i, a = t.getElementById(e);
if (a) {
if ((n = a.getAttributeNode("id")) && n.value === e) return [ a ];
for (i = t.getElementsByName(e), r = 0; a = i[r++]; ) if ((n = a.getAttributeNode("id")) && n.value === e) return [ a ];
}
return [];
}
}), r.find.TAG = n.getElementsByTagName ? function(e, t) {
return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0;
} : function(e, t) {
var n, r = [], i = 0, a = t.getElementsByTagName(e);
if ("*" === e) {
for (;n = a[i++]; ) 1 === n.nodeType && r.push(n);
return r;
}
return a;
}, r.find.CLASS = n.getElementsByClassName && function(e, t) {
if (void 0 !== t.getElementsByClassName && m) return t.getElementsByClassName(e);
}, v = [], g = [], (n.qsa = K.test(p.querySelectorAll)) && (ue(function(e) {
var t;
f.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + R + "*(?:''|\"\")"), 
e.querySelectorAll("[selected]").length || g.push("\\[" + R + "*(?:value|" + I + ")"), 
e.querySelectorAll("[id~=" + b + "-]").length || g.push("~="), (t = p.createElement("input")).setAttribute("name", ""), 
e.appendChild(t), e.querySelectorAll("[name='']").length || g.push("\\[" + R + "*name" + R + "*=" + R + "*(?:''|\"\")"), 
e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + b + "+*").length || g.push(".#.+[+~]"), 
e.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]");
}), ue(function(e) {
e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
var t = p.createElement("input");
t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + R + "*[*^$|!~]?="), 
2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), 
f.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), 
e.querySelectorAll("*,:x"), g.push(",.*:");
})), (n.matchesSelector = K.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ue(function(e) {
n.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), v.push("!=", B);
}), g = g.length && new RegExp(g.join("|")), v = v.length && new RegExp(v.join("|")), 
t = K.test(f.compareDocumentPosition), $ = t || K.test(f.contains) ? function(e, t) {
var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;
return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
} : function(e, t) {
if (t) for (;t = t.parentNode; ) if (t === e) return !0;
return !1;
}, L = t ? function(e, t) {
if (e === t) return h = !0, 0;
var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
return r || (1 & (r = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e == p || e.ownerDocument == x && $(x, e) ? -1 : t == p || t.ownerDocument == x && $(x, t) ? 1 : u ? N(u, e) - N(u, t) : 0 : 4 & r ? -1 : 1);
} : function(e, t) {
if (e === t) return h = !0, 0;
var n, r = 0, i = e.parentNode, a = t.parentNode, o = [ e ], s = [ t ];
if (!i || !a) return e == p ? -1 : t == p ? 1 : i ? -1 : a ? 1 : u ? N(u, e) - N(u, t) : 0;
if (i === a) return de(e, t);
for (n = e; n = n.parentNode; ) o.unshift(n);
for (n = t; n = n.parentNode; ) s.unshift(n);
for (;o[r] === s[r]; ) r++;
return r ? de(o[r], s[r]) : o[r] == x ? -1 : s[r] == x ? 1 : 0;
}), p;
}, se.matches = function(e, t) {
return se(e, null, null, t);
}, se.matchesSelector = function(e, t) {
if (d(e), n.matchesSelector && m && !T[t + " "] && (!v || !v.test(t)) && (!g || !g.test(t))) try {
var r = y.call(e, t);
if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r;
} catch (e) {
T(t, !0);
}
return 0 < se(t, p, null, [ e ]).length;
}, se.contains = function(e, t) {
return (e.ownerDocument || e) != p && d(e), $(e, t);
}, se.attr = function(e, t) {
(e.ownerDocument || e) != p && d(e);
var i = r.attrHandle[t.toLowerCase()], a = i && C.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !m) : void 0;
return void 0 !== a ? a : n.attributes || !m ? e.getAttribute(t) : (a = e.getAttributeNode(t)) && a.specified ? a.value : null;
}, se.escape = function(e) {
return (e + "").replace(re, ie);
}, se.error = function(e) {
throw new Error("Syntax error, unrecognized expression: " + e);
}, se.uniqueSort = function(e) {
var t, r = [], i = 0, a = 0;
if (h = !n.detectDuplicates, u = !n.sortStable && e.slice(0), e.sort(L), h) {
for (;t = e[a++]; ) t === e[a] && (i = r.push(a));
for (;i--; ) e.splice(r[i], 1);
}
return u = null, e;
}, i = se.getText = function(e) {
var t, n = "", r = 0, a = e.nodeType;
if (a) {
if (1 === a || 9 === a || 11 === a) {
if ("string" == typeof e.textContent) return e.textContent;
for (e = e.firstChild; e; e = e.nextSibling) n += i(e);
} else if (3 === a || 4 === a) return e.nodeValue;
} else for (;t = e[r++]; ) n += i(t);
return n;
}, (r = se.selectors = {
cacheLength: 50,
createPseudo: le,
match: X,
attrHandle: {},
find: {},
relative: {
">": {
dir: "parentNode",
first: !0
},
" ": {
dir: "parentNode"
},
"+": {
dir: "previousSibling",
first: !0
},
"~": {
dir: "previousSibling"
}
},
preFilter: {
ATTR: function(e) {
return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), 
"~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
},
CHILD: function(e) {
return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), 
e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), 
e;
},
PSEUDO: function(e) {
var t, n = !e[6] && e[2];
return X.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && q.test(n) && (t = o(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), 
e[2] = n.slice(0, t)), e.slice(0, 3));
}
},
filter: {
TAG: function(e) {
var t = e.replace(te, ne).toLowerCase();
return "*" === e ? function() {
return !0;
} : function(e) {
return e.nodeName && e.nodeName.toLowerCase() === t;
};
},
CLASS: function(e) {
var t = M[e + " "];
return t || (t = new RegExp("(^|" + R + ")" + e + "(" + R + "|$)")) && M(e, function(e) {
return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "");
});
},
ATTR: function(e, t, n) {
return function(r) {
var i = se.attr(r, e);
return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && -1 < i.indexOf(n) : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? -1 < (" " + i.replace(z, " ") + " ").indexOf(n) : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-"));
};
},
CHILD: function(e, t, n, r, i) {
var a = "nth" !== e.slice(0, 3), o = "last" !== e.slice(-4), s = "of-type" === t;
return 1 === r && 0 === i ? function(e) {
return !!e.parentNode;
} : function(t, n, c) {
var l, u, h, d, p, f, m = a !== o ? "nextSibling" : "previousSibling", g = t.parentNode, v = s && t.nodeName.toLowerCase(), y = !c && !s, $ = !1;
if (g) {
if (a) {
for (;m; ) {
for (d = t; d = d[m]; ) if (s ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
f = m = "only" === e && !f && "nextSibling";
}
return !0;
}
if (f = [ o ? g.firstChild : g.lastChild ], o && y) {
for ($ = (p = (l = (u = (h = (d = g)[b] || (d[b] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] || [])[0] === w && l[1]) && l[2], 
d = p && g.childNodes[p]; d = ++p && d && d[m] || ($ = p = 0) || f.pop(); ) if (1 === d.nodeType && ++$ && d === t) {
u[e] = [ w, p, $ ];
break;
}
} else if (y && ($ = p = (l = (u = (h = (d = t)[b] || (d[b] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] || [])[0] === w && l[1]), 
!1 === $) for (;(d = ++p && d && d[m] || ($ = p = 0) || f.pop()) && ((s ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++$ || (y && ((u = (h = d[b] || (d[b] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] = [ w, $ ]), 
d !== t)); ) ;
return ($ -= i) === r || $ % r == 0 && 0 <= $ / r;
}
};
},
PSEUDO: function(e, t) {
var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
return i[b] ? i(t) : 1 < i.length ? (n = [ e, e, "", t ], r.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function(e, n) {
for (var r, a = i(e, t), o = a.length; o--; ) e[r = N(e, a[o])] = !(n[r] = a[o]);
}) : function(e) {
return i(e, 0, n);
}) : i;
}
},
pseudos: {
not: le(function(e) {
var t = [], n = [], r = s(e.replace(F, "$1"));
return r[b] ? le(function(e, t, n, i) {
for (var a, o = r(e, null, i, []), s = e.length; s--; ) (a = o[s]) && (e[s] = !(t[s] = a));
}) : function(e, i, a) {
return t[0] = e, r(t, null, a, n), t[0] = null, !n.pop();
};
}),
has: le(function(e) {
return function(t) {
return 0 < se(e, t).length;
};
}),
contains: le(function(e) {
return e = e.replace(te, ne), function(t) {
return -1 < (t.textContent || i(t)).indexOf(e);
};
}),
lang: le(function(e) {
return H.test(e || "") || se.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(), 
function(t) {
var n;
do {
if (n = m ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-");
} while ((t = t.parentNode) && 1 === t.nodeType);
return !1;
};
}),
target: function(t) {
var n = e.location && e.location.hash;
return n && n.slice(1) === t.id;
},
root: function(e) {
return e === f;
},
focus: function(e) {
return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
},
enabled: me(!1),
disabled: me(!0),
checked: function(e) {
var t = e.nodeName.toLowerCase();
return "input" === t && !!e.checked || "option" === t && !!e.selected;
},
selected: function(e) {
return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
},
empty: function(e) {
for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
return !0;
},
parent: function(e) {
return !r.pseudos.empty(e);
},
header: function(e) {
return Z.test(e.nodeName);
},
input: function(e) {
return J.test(e.nodeName);
},
button: function(e) {
var t = e.nodeName.toLowerCase();
return "input" === t && "button" === e.type || "button" === t;
},
text: function(e) {
var t;
return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
},
first: ge(function() {
return [ 0 ];
}),
last: ge(function(e, t) {
return [ t - 1 ];
}),
eq: ge(function(e, t, n) {
return [ n < 0 ? n + t : n ];
}),
even: ge(function(e, t) {
for (var n = 0; n < t; n += 2) e.push(n);
return e;
}),
odd: ge(function(e, t) {
for (var n = 1; n < t; n += 2) e.push(n);
return e;
}),
lt: ge(function(e, t, n) {
for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r; ) e.push(r);
return e;
}),
gt: ge(function(e, t, n) {
for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
return e;
})
}
}).pseudos.nth = r.pseudos.eq, {
radio: !0,
checkbox: !0,
file: !0,
password: !0,
image: !0
}) r.pseudos[t] = pe(t);
for (t in {
submit: !0,
reset: !0
}) r.pseudos[t] = fe(t);
function ye() {}
function $e(e) {
for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
return r;
}
function be(e, t, n) {
var r = t.dir, i = t.next, a = i || r, o = n && "parentNode" === a, s = _++;
return t.first ? function(t, n, i) {
for (;t = t[r]; ) if (1 === t.nodeType || o) return e(t, n, i);
return !1;
} : function(t, n, c) {
var l, u, h, d = [ w, s ];
if (c) {
for (;t = t[r]; ) if ((1 === t.nodeType || o) && e(t, n, c)) return !0;
} else for (;t = t[r]; ) if (1 === t.nodeType || o) if (u = (h = t[b] || (t[b] = {}))[t.uniqueID] || (h[t.uniqueID] = {}), 
i && i === t.nodeName.toLowerCase()) t = t[r] || t; else {
if ((l = u[a]) && l[0] === w && l[1] === s) return d[2] = l[2];
if ((u[a] = d)[2] = e(t, n, c)) return !0;
}
return !1;
};
}
function xe(e) {
return 1 < e.length ? function(t, n, r) {
for (var i = e.length; i--; ) if (!e[i](t, n, r)) return !1;
return !0;
} : e[0];
}
function we(e, t, n, r, i) {
for (var a, o = [], s = 0, c = e.length, l = null != t; s < c; s++) (a = e[s]) && (n && !n(a, r, i) || (o.push(a), 
l && t.push(s)));
return o;
}
function _e(e, t, n, r, i, a) {
return r && !r[b] && (r = _e(r)), i && !i[b] && (i = _e(i, a)), le(function(a, o, s, c) {
var l, u, h, d = [], p = [], f = o.length, m = a || function(e, t, n) {
for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);
return n;
}(t || "*", s.nodeType ? [ s ] : s, []), g = !e || !a && t ? m : we(m, d, e, s, c), v = n ? i || (a ? e : f || r) ? [] : o : g;
if (n && n(g, v, s, c), r) for (l = we(v, p), r(l, [], s, c), u = l.length; u--; ) (h = l[u]) && (v[p[u]] = !(g[p[u]] = h));
if (a) {
if (i || e) {
if (i) {
for (l = [], u = v.length; u--; ) (h = v[u]) && l.push(g[u] = h);
i(null, v = [], l, c);
}
for (u = v.length; u--; ) (h = v[u]) && -1 < (l = i ? N(a, h) : d[u]) && (a[l] = !(o[l] = h));
}
} else v = we(v === o ? v.splice(f, v.length) : v), i ? i(null, o, v, c) : O.apply(o, v);
});
}
function Me(e) {
for (var t, n, i, a = e.length, o = r.relative[e[0].type], s = o || r.relative[" "], c = o ? 1 : 0, u = be(function(e) {
return e === t;
}, s, !0), h = be(function(e) {
return -1 < N(t, e);
}, s, !0), d = [ function(e, n, r) {
var i = !o && (r || n !== l) || ((t = n).nodeType ? u(e, n, r) : h(e, n, r));
return t = null, i;
} ]; c < a; c++) if (n = r.relative[e[c].type]) d = [ be(xe(d), n) ]; else {
if ((n = r.filter[e[c].type].apply(null, e[c].matches))[b]) {
for (i = ++c; i < a && !r.relative[e[i].type]; i++) ;
return _e(1 < c && xe(d), 1 < c && $e(e.slice(0, c - 1).concat({
value: " " === e[c - 2].type ? "*" : ""
})).replace(F, "$1"), n, c < i && Me(e.slice(c, i)), i < a && Me(e = e.slice(i)), i < a && $e(e));
}
d.push(n);
}
return xe(d);
}
return ye.prototype = r.filters = r.pseudos, r.setFilters = new ye(), o = se.tokenize = function(e, t) {
var n, i, a, o, s, c, l, u = S[e + " "];
if (u) return t ? 0 : u.slice(0);
for (s = e, c = [], l = r.preFilter; s; ) {
for (o in n && !(i = G.exec(s)) || (i && (s = s.slice(i[0].length) || s), c.push(a = [])), 
n = !1, (i = V.exec(s)) && (n = i.shift(), a.push({
value: n,
type: i[0].replace(F, " ")
}), s = s.slice(n.length)), r.filter) !(i = X[o].exec(s)) || l[o] && !(i = l[o](i)) || (n = i.shift(), 
a.push({
value: n,
type: o,
matches: i
}), s = s.slice(n.length));
if (!n) break;
}
return t ? s.length : s ? se.error(e) : S(e, c).slice(0);
}, s = se.compile = function(e, t) {
var n, i, a, s, c, u, h = [], f = [], g = A[e + " "];
if (!g) {
for (t || (t = o(e)), n = t.length; n--; ) (g = Me(t[n]))[b] ? h.push(g) : f.push(g);
(g = A(e, (i = f, s = 0 < (a = h).length, c = 0 < i.length, u = function(e, t, n, o, u) {
var h, f, g, v = 0, y = "0", $ = e && [], b = [], x = l, _ = e || c && r.find.TAG("*", u), M = w += null == x ? 1 : Math.random() || .1, S = _.length;
for (u && (l = t == p || t || u); y !== S && null != (h = _[y]); y++) {
if (c && h) {
for (f = 0, t || h.ownerDocument == p || (d(h), n = !m); g = i[f++]; ) if (g(h, t || p, n)) {
o.push(h);
break;
}
u && (w = M);
}
s && ((h = !g && h) && v--, e && $.push(h));
}
if (v += y, s && y !== v) {
for (f = 0; g = a[f++]; ) g($, b, t, n);
if (e) {
if (0 < v) for (;y--; ) $[y] || b[y] || (b[y] = P.call(o));
b = we(b);
}
O.apply(o, b), u && !e && 0 < b.length && 1 < v + a.length && se.uniqueSort(o);
}
return u && (w = M, l = x), $;
}, s ? le(u) : u))).selector = e;
}
return g;
}, c = se.select = function(e, t, n, i) {
var a, c, l, u, h, d = "function" == typeof e && e, p = !i && o(e = d.selector || e);
if (n = n || [], 1 === p.length) {
if (2 < (c = p[0] = p[0].slice(0)).length && "ID" === (l = c[0]).type && 9 === t.nodeType && m && r.relative[c[1].type]) {
if (!(t = (r.find.ID(l.matches[0].replace(te, ne), t) || [])[0])) return n;
d && (t = t.parentNode), e = e.slice(c.shift().value.length);
}
for (a = X.needsContext.test(e) ? 0 : c.length; a-- && (l = c[a], !r.relative[u = l.type]); ) if ((h = r.find[u]) && (i = h(l.matches[0].replace(te, ne), ee.test(c[0].type) && ve(t.parentNode) || t))) {
if (c.splice(a, 1), !(e = i.length && $e(c))) return O.apply(n, i), n;
break;
}
}
return (d || s(e, p))(i, t, !m, n, !t || ee.test(e) && ve(t.parentNode) || t), n;
}, n.sortStable = b.split("").sort(L).join("") === b, n.detectDuplicates = !!h, 
d(), n.sortDetached = ue(function(e) {
return 1 & e.compareDocumentPosition(p.createElement("fieldset"));
}), ue(function(e) {
return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
}) || he("type|href|height|width", function(e, t, n) {
if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
}), n.attributes && ue(function(e) {
return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
}) || he("value", function(e, t, n) {
if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
}), ue(function(e) {
return null == e.getAttribute("disabled");
}) || he(I, function(e, t, n) {
var r;
if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
}), se;
}(e);
x.find = _, x.expr = _.selectors, x.expr[":"] = x.expr.pseudos, x.uniqueSort = x.unique = _.uniqueSort, 
x.text = _.getText, x.isXMLDoc = _.isXML, x.contains = _.contains, x.escapeSelector = _.escape;
var M = function(e, t, n) {
for (var r = [], i = void 0 !== n; (e = e[t]) && 9 !== e.nodeType; ) if (1 === e.nodeType) {
if (i && x(e).is(n)) break;
r.push(e);
}
return r;
}, S = function(e, t) {
for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
return n;
}, A = x.expr.match.needsContext;
function T(e, t) {
return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
}
var L = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
function C(e, t, n) {
return f(t) ? x.grep(e, function(e, r) {
return !!t.call(e, r, e) !== n;
}) : t.nodeType ? x.grep(e, function(e) {
return e === t !== n;
}) : "string" != typeof t ? x.grep(e, function(e) {
return -1 < s.call(t, e) !== n;
}) : x.filter(t, e, n);
}
x.filter = function(e, t, n) {
var r = t[0];
return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [ r ] : [] : x.find.matches(e, x.grep(t, function(e) {
return 1 === e.nodeType;
}));
}, x.fn.extend({
find: function(e) {
var t, n, r = this.length, i = this;
if ("string" != typeof e) return this.pushStack(x(e).filter(function() {
for (t = 0; t < r; t++) if (x.contains(i[t], this)) return !0;
}));
for (n = this.pushStack([]), t = 0; t < r; t++) x.find(e, i[t], n);
return 1 < r ? x.uniqueSort(n) : n;
},
filter: function(e) {
return this.pushStack(C(this, e || [], !1));
},
not: function(e) {
return this.pushStack(C(this, e || [], !0));
},
is: function(e) {
return !!C(this, "string" == typeof e && A.test(e) ? x(e) : e || [], !1).length;
}
});
var E, P = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
(x.fn.init = function(e, t, n) {
var r, i;
if (!e) return this;
if (n = n || E, "string" == typeof e) {
if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [ null, e, null ] : P.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
if (r[1]) {
if (t = t instanceof x ? t[0] : t, x.merge(this, x.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : g, !0)), 
L.test(r[1]) && x.isPlainObject(t)) for (r in t) f(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
return this;
}
return (i = g.getElementById(r[2])) && (this[0] = i, this.length = 1), this;
}
return e.nodeType ? (this[0] = e, this.length = 1, this) : f(e) ? void 0 !== n.ready ? n.ready(e) : e(x) : x.makeArray(e, this);
}).prototype = x.fn, E = x(g);
var k = /^(?:parents|prev(?:Until|All))/, O = {
children: !0,
contents: !0,
next: !0,
prev: !0
};
function D(e, t) {
for (;(e = e[t]) && 1 !== e.nodeType; ) ;
return e;
}
x.fn.extend({
has: function(e) {
var t = x(e, this), n = t.length;
return this.filter(function() {
for (var e = 0; e < n; e++) if (x.contains(this, t[e])) return !0;
});
},
closest: function(e, t) {
var n, r = 0, i = this.length, a = [], o = "string" != typeof e && x(e);
if (!A.test(e)) for (;r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (o ? -1 < o.index(n) : 1 === n.nodeType && x.find.matchesSelector(n, e))) {
a.push(n);
break;
}
return this.pushStack(1 < a.length ? x.uniqueSort(a) : a);
},
index: function(e) {
return e ? "string" == typeof e ? s.call(x(e), this[0]) : s.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
},
add: function(e, t) {
return this.pushStack(x.uniqueSort(x.merge(this.get(), x(e, t))));
},
addBack: function(e) {
return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
}
}), x.each({
parent: function(e) {
var t = e.parentNode;
return t && 11 !== t.nodeType ? t : null;
},
parents: function(e) {
return M(e, "parentNode");
},
parentsUntil: function(e, t, n) {
return M(e, "parentNode", n);
},
next: function(e) {
return D(e, "nextSibling");
},
prev: function(e) {
return D(e, "previousSibling");
},
nextAll: function(e) {
return M(e, "nextSibling");
},
prevAll: function(e) {
return M(e, "previousSibling");
},
nextUntil: function(e, t, n) {
return M(e, "nextSibling", n);
},
prevUntil: function(e, t, n) {
return M(e, "previousSibling", n);
},
siblings: function(e) {
return S((e.parentNode || {}).firstChild, e);
},
children: function(e) {
return S(e.firstChild);
},
contents: function(e) {
return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (T(e, "template") && (e = e.content || e), 
x.merge([], e.childNodes));
}
}, function(e, t) {
x.fn[e] = function(n, r) {
var i = x.map(this, t, n);
return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = x.filter(r, i)), 
1 < this.length && (O[e] || x.uniqueSort(i), k.test(e) && i.reverse()), this.pushStack(i);
};
});
var N = /[^\x20\t\r\n\f]+/g;
function I(e) {
return e;
}
function R(e) {
throw e;
}
function j(e, t, n, r) {
var i;
try {
e && f(i = e.promise) ? i.call(e).done(t).fail(n) : e && f(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [ e ].slice(r));
} catch (e) {
n.apply(void 0, [ e ]);
}
}
x.Callbacks = function(e) {
var t, n;
e = "string" == typeof e ? (t = e, n = {}, x.each(t.match(N) || [], function(e, t) {
n[t] = !0;
}), n) : x.extend({}, e);
var r, i, a, o, s = [], c = [], l = -1, u = function() {
for (o = o || e.once, a = r = !0; c.length; l = -1) for (i = c.shift(); ++l < s.length; ) !1 === s[l].apply(i[0], i[1]) && e.stopOnFalse && (l = s.length, 
i = !1);
e.memory || (i = !1), r = !1, o && (s = i ? [] : "");
}, h = {
add: function() {
return s && (i && !r && (l = s.length - 1, c.push(i)), function t(n) {
x.each(n, function(n, r) {
f(r) ? e.unique && h.has(r) || s.push(r) : r && r.length && "string" !== $(r) && t(r);
});
}(arguments), i && !r && u()), this;
},
remove: function() {
return x.each(arguments, function(e, t) {
for (var n; -1 < (n = x.inArray(t, s, n)); ) s.splice(n, 1), n <= l && l--;
}), this;
},
has: function(e) {
return e ? -1 < x.inArray(e, s) : 0 < s.length;
},
empty: function() {
return s && (s = []), this;
},
disable: function() {
return o = c = [], s = i = "", this;
},
disabled: function() {
return !s;
},
lock: function() {
return o = c = [], i || r || (s = i = ""), this;
},
locked: function() {
return !!o;
},
fireWith: function(e, t) {
return o || (t = [ e, (t = t || []).slice ? t.slice() : t ], c.push(t), r || u()), 
this;
},
fire: function() {
return h.fireWith(this, arguments), this;
},
fired: function() {
return !!a;
}
};
return h;
}, x.extend({
Deferred: function(t) {
var n = [ [ "notify", "progress", x.Callbacks("memory"), x.Callbacks("memory"), 2 ], [ "resolve", "done", x.Callbacks("once memory"), x.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", x.Callbacks("once memory"), x.Callbacks("once memory"), 1, "rejected" ] ], r = "pending", i = {
state: function() {
return r;
},
always: function() {
return a.done(arguments).fail(arguments), this;
},
catch: function(e) {
return i.then(null, e);
},
pipe: function() {
var e = arguments;
return x.Deferred(function(t) {
x.each(n, function(n, r) {
var i = f(e[r[4]]) && e[r[4]];
a[r[1]](function() {
var e = i && i.apply(this, arguments);
e && f(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [ e ] : arguments);
});
}), e = null;
}).promise();
},
then: function(t, r, i) {
var a = 0;
function o(t, n, r, i) {
return function() {
var s = this, c = arguments, l = function() {
var e, l;
if (!(t < a)) {
if ((e = r.apply(s, c)) === n.promise()) throw new TypeError("Thenable self-resolution");
l = e && ("object" == typeof e || "function" == typeof e) && e.then, f(l) ? i ? l.call(e, o(a, n, I, i), o(a, n, R, i)) : (a++, 
l.call(e, o(a, n, I, i), o(a, n, R, i), o(a, n, I, n.notifyWith))) : (r !== I && (s = void 0, 
c = [ e ]), (i || n.resolveWith)(s, c));
}
}, u = i ? l : function() {
try {
l();
} catch (e) {
x.Deferred.exceptionHook && x.Deferred.exceptionHook(e, u.stackTrace), a <= t + 1 && (r !== R && (s = void 0, 
c = [ e ]), n.rejectWith(s, c));
}
};
t ? u() : (x.Deferred.getStackHook && (u.stackTrace = x.Deferred.getStackHook()), 
e.setTimeout(u));
};
}
return x.Deferred(function(e) {
n[0][3].add(o(0, e, f(i) ? i : I, e.notifyWith)), n[1][3].add(o(0, e, f(t) ? t : I)), 
n[2][3].add(o(0, e, f(r) ? r : R));
}).promise();
},
promise: function(e) {
return null != e ? x.extend(e, i) : i;
}
}, a = {};
return x.each(n, function(e, t) {
var o = t[2], s = t[5];
i[t[1]] = o.add, s && o.add(function() {
r = s;
}, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), o.add(t[3].fire), 
a[t[0]] = function() {
return a[t[0] + "With"](this === a ? void 0 : this, arguments), this;
}, a[t[0] + "With"] = o.fireWith;
}), i.promise(a), t && t.call(a, a), a;
},
when: function(e) {
var t = arguments.length, n = t, r = Array(n), a = i.call(arguments), o = x.Deferred(), s = function(e) {
return function(n) {
r[e] = this, a[e] = 1 < arguments.length ? i.call(arguments) : n, --t || o.resolveWith(r, a);
};
};
if (t <= 1 && (j(e, o.done(s(n)).resolve, o.reject, !t), "pending" === o.state() || f(a[n] && a[n].then))) return o.then();
for (;n--; ) j(a[n], s(n), o.reject);
return o.promise();
}
});
var U = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
x.Deferred.exceptionHook = function(t, n) {
e.console && e.console.warn && t && U.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n);
}, x.readyException = function(t) {
e.setTimeout(function() {
throw t;
});
};
var B = x.Deferred();
function z() {
g.removeEventListener("DOMContentLoaded", z), e.removeEventListener("load", z), 
x.ready();
}
x.fn.ready = function(e) {
return B.then(e).catch(function(e) {
x.readyException(e);
}), this;
}, x.extend({
isReady: !1,
readyWait: 1,
ready: function(e) {
(!0 === e ? --x.readyWait : x.isReady) || (x.isReady = !0) !== e && 0 < --x.readyWait || B.resolveWith(g, [ x ]);
}
}), x.ready.then = B.then, "complete" === g.readyState || "loading" !== g.readyState && !g.documentElement.doScroll ? e.setTimeout(x.ready) : (g.addEventListener("DOMContentLoaded", z), 
e.addEventListener("load", z));
var F = function(e, t, n, r, i, a, o) {
var s = 0, c = e.length, l = null == n;
if ("object" === $(n)) for (s in i = !0, n) F(e, t, s, n[s], !0, a, o); else if (void 0 !== r && (i = !0, 
f(r) || (o = !0), l && (o ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
return l.call(x(e), n);
})), t)) for (;s < c; s++) t(e[s], n, o ? r : r.call(e[s], s, t(e[s], n)));
return i ? e : l ? t.call(e) : c ? t(e[0], n) : a;
}, G = /^-ms-/, V = /-([a-z])/g;
function W(e, t) {
return t.toUpperCase();
}
function q(e) {
return e.replace(G, "ms-").replace(V, W);
}
var H = function(e) {
return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
};
function X() {
this.expando = x.expando + X.uid++;
}
X.uid = 1, X.prototype = {
cache: function(e) {
var t = e[this.expando];
return t || (t = {}, H(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
value: t,
configurable: !0
}))), t;
},
set: function(e, t, n) {
var r, i = this.cache(e);
if ("string" == typeof t) i[q(t)] = n; else for (r in t) i[q(r)] = t[r];
return i;
},
get: function(e, t) {
return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][q(t)];
},
access: function(e, t, n) {
return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), 
void 0 !== n ? n : t);
},
remove: function(e, t) {
var n, r = e[this.expando];
if (void 0 !== r) {
if (void 0 !== t) {
n = (t = Array.isArray(t) ? t.map(q) : (t = q(t)) in r ? [ t ] : t.match(N) || []).length;
for (;n--; ) delete r[t[n]];
}
(void 0 === t || x.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
}
},
hasData: function(e) {
var t = e[this.expando];
return void 0 !== t && !x.isEmptyObject(t);
}
};
var Y = new X(), J = new X(), Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g;
function Q(e, t, n) {
var r, i;
if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), 
"string" == typeof (n = e.getAttribute(r))) {
try {
n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : Z.test(i) ? JSON.parse(i) : i);
} catch (e) {}
J.set(e, t, n);
} else n = void 0;
return n;
}
x.extend({
hasData: function(e) {
return J.hasData(e) || Y.hasData(e);
},
data: function(e, t, n) {
return J.access(e, t, n);
},
removeData: function(e, t) {
J.remove(e, t);
},
_data: function(e, t, n) {
return Y.access(e, t, n);
},
_removeData: function(e, t) {
Y.remove(e, t);
}
}), x.fn.extend({
data: function(e, t) {
var n, r, i, a = this[0], o = a && a.attributes;
if (void 0 === e) {
if (this.length && (i = J.get(a), 1 === a.nodeType && !Y.get(a, "hasDataAttrs"))) {
for (n = o.length; n--; ) o[n] && 0 === (r = o[n].name).indexOf("data-") && (r = q(r.slice(5)), 
Q(a, r, i[r]));
Y.set(a, "hasDataAttrs", !0);
}
return i;
}
return "object" == typeof e ? this.each(function() {
J.set(this, e);
}) : F(this, function(t) {
var n;
if (a && void 0 === t) return void 0 !== (n = J.get(a, e)) ? n : void 0 !== (n = Q(a, e)) ? n : void 0;
this.each(function() {
J.set(this, e, t);
});
}, null, t, 1 < arguments.length, null, !0);
},
removeData: function(e) {
return this.each(function() {
J.remove(this, e);
});
}
}), x.extend({
queue: function(e, t, n) {
var r;
if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, x.makeArray(n)) : r.push(n)), 
r || [];
},
dequeue: function(e, t) {
t = t || "fx";
var n = x.queue(e, t), r = n.length, i = n.shift(), a = x._queueHooks(e, t);
"inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), 
delete a.stop, i.call(e, function() {
x.dequeue(e, t);
}, a)), !r && a && a.empty.fire();
},
_queueHooks: function(e, t) {
var n = t + "queueHooks";
return Y.get(e, n) || Y.access(e, n, {
empty: x.Callbacks("once memory").add(function() {
Y.remove(e, [ t + "queue", n ]);
})
});
}
}), x.fn.extend({
queue: function(e, t) {
var n = 2;
return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? x.queue(this[0], e) : void 0 === t ? this : this.each(function() {
var n = x.queue(this, e, t);
x._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && x.dequeue(this, e);
});
},
dequeue: function(e) {
return this.each(function() {
x.dequeue(this, e);
});
},
clearQueue: function(e) {
return this.queue(e || "fx", []);
},
promise: function(e, t) {
var n, r = 1, i = x.Deferred(), a = this, o = this.length, s = function() {
--r || i.resolveWith(a, [ a ]);
};
for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; o--; ) (n = Y.get(a[o], e + "queueHooks")) && n.empty && (r++, 
n.empty.add(s));
return s(), i.promise(t);
}
});
var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = [ "Top", "Right", "Bottom", "Left" ], re = g.documentElement, ie = function(e) {
return x.contains(e.ownerDocument, e);
}, ae = {
composed: !0
};
re.getRootNode && (ie = function(e) {
return x.contains(e.ownerDocument, e) || e.getRootNode(ae) === e.ownerDocument;
});
var oe = function(e, t) {
return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === x.css(e, "display");
};
function se(e, t, n, r) {
var i, a, o = 20, s = r ? function() {
return r.cur();
} : function() {
return x.css(e, t, "");
}, c = s(), l = n && n[3] || (x.cssNumber[t] ? "" : "px"), u = e.nodeType && (x.cssNumber[t] || "px" !== l && +c) && te.exec(x.css(e, t));
if (u && u[3] !== l) {
for (c /= 2, l = l || u[3], u = +c || 1; o--; ) x.style(e, t, u + l), (1 - a) * (1 - (a = s() / c || .5)) <= 0 && (o = 0), 
u /= a;
u *= 2, x.style(e, t, u + l), n = n || [];
}
return n && (u = +u || +c || 0, i = n[1] ? u + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, 
r.start = u, r.end = i)), i;
}
var ce = {};
function le(e, t) {
for (var n, r, i, a, o, s, c, l = [], u = 0, h = e.length; u < h; u++) (r = e[u]).style && (n = r.style.display, 
t ? ("none" === n && (l[u] = Y.get(r, "display") || null, l[u] || (r.style.display = "")), 
"" === r.style.display && oe(r) && (l[u] = (c = o = a = void 0, o = (i = r).ownerDocument, 
s = i.nodeName, (c = ce[s]) || (a = o.body.appendChild(o.createElement(s)), c = x.css(a, "display"), 
a.parentNode.removeChild(a), "none" === c && (c = "block"), ce[s] = c)))) : "none" !== n && (l[u] = "none", 
Y.set(r, "display", n)));
for (u = 0; u < h; u++) null != l[u] && (e[u].style.display = l[u]);
return e;
}
x.fn.extend({
show: function() {
return le(this, !0);
},
hide: function() {
return le(this);
},
toggle: function(e) {
return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
oe(this) ? x(this).show() : x(this).hide();
});
}
});
var ue, he, de = /^(?:checkbox|radio)$/i, pe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, fe = /^$|^module$|\/(?:java|ecma)script/i;
ue = g.createDocumentFragment().appendChild(g.createElement("div")), (he = g.createElement("input")).setAttribute("type", "radio"), 
he.setAttribute("checked", "checked"), he.setAttribute("name", "t"), ue.appendChild(he), 
p.checkClone = ue.cloneNode(!0).cloneNode(!0).lastChild.checked, ue.innerHTML = "<textarea>x</textarea>", 
p.noCloneChecked = !!ue.cloneNode(!0).lastChild.defaultValue, ue.innerHTML = "<option></option>", 
p.option = !!ue.lastChild;
var me = {
thead: [ 1, "<table>", "</table>" ],
col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
tr: [ 2, "<table><tbody>", "</tbody></table>" ],
td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
_default: [ 0, "", "" ]
};
function ge(e, t) {
var n;
return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], 
void 0 === t || t && T(e, t) ? x.merge([ e ], n) : n;
}
function ve(e, t) {
for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"));
}
me.tbody = me.tfoot = me.colgroup = me.caption = me.thead, me.th = me.td, p.option || (me.optgroup = me.option = [ 1, "<select multiple='multiple'>", "</select>" ]);
var ye = /<|&#?\w+;/;
function $e(e, t, n, r, i) {
for (var a, o, s, c, l, u, h = t.createDocumentFragment(), d = [], p = 0, f = e.length; p < f; p++) if ((a = e[p]) || 0 === a) if ("object" === $(a)) x.merge(d, a.nodeType ? [ a ] : a); else if (ye.test(a)) {
for (o = o || h.appendChild(t.createElement("div")), s = (pe.exec(a) || [ "", "" ])[1].toLowerCase(), 
c = me[s] || me._default, o.innerHTML = c[1] + x.htmlPrefilter(a) + c[2], u = c[0]; u--; ) o = o.lastChild;
x.merge(d, o.childNodes), (o = h.firstChild).textContent = "";
} else d.push(t.createTextNode(a));
for (h.textContent = "", p = 0; a = d[p++]; ) if (r && -1 < x.inArray(a, r)) i && i.push(a); else if (l = ie(a), 
o = ge(h.appendChild(a), "script"), l && ve(o), n) for (u = 0; a = o[u++]; ) fe.test(a.type || "") && n.push(a);
return h;
}
var be = /^([^.]*)(?:\.(.+)|)/;
function xe() {
return !0;
}
function we() {
return !1;
}
function _e(e, t) {
return e === function() {
try {
return g.activeElement;
} catch (e) {}
}() == ("focus" === t);
}
function Me(e, t, n, r, i, a) {
var o, s;
if ("object" == typeof t) {
for (s in "string" != typeof n && (r = r || n, n = void 0), t) Me(e, s, n, r, t[s], a);
return e;
}
if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, 
r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = we; else if (!i) return e;
return 1 === a && (o = i, (i = function(e) {
return x().off(e), o.apply(this, arguments);
}).guid = o.guid || (o.guid = x.guid++)), e.each(function() {
x.event.add(this, t, i, r, n);
});
}
function Se(e, t, n) {
n ? (Y.set(e, t, !1), x.event.add(e, t, {
namespace: !1,
handler: function(e) {
var r, a, o = Y.get(this, t);
if (1 & e.isTrigger && this[t]) {
if (o.length) (x.event.special[t] || {}).delegateType && e.stopPropagation(); else if (o = i.call(arguments), 
Y.set(this, t, o), r = n(this, t), this[t](), o !== (a = Y.get(this, t)) || r ? Y.set(this, t, !1) : a = {}, 
o !== a) return e.stopImmediatePropagation(), e.preventDefault(), a && a.value;
} else o.length && (Y.set(this, t, {
value: x.event.trigger(x.extend(o[0], x.Event.prototype), o.slice(1), this)
}), e.stopImmediatePropagation());
}
})) : void 0 === Y.get(e, t) && x.event.add(e, t, xe);
}
x.event = {
global: {},
add: function(e, t, n, r, i) {
var a, o, s, c, l, u, h, d, p, f, m, g = Y.get(e);
if (H(e)) for (n.handler && (n = (a = n).handler, i = a.selector), i && x.find.matchesSelector(re, i), 
n.guid || (n.guid = x.guid++), (c = g.events) || (c = g.events = Object.create(null)), 
(o = g.handle) || (o = g.handle = function(t) {
return void 0 !== x && x.event.triggered !== t.type ? x.event.dispatch.apply(e, arguments) : void 0;
}), l = (t = (t || "").match(N) || [ "" ]).length; l--; ) p = m = (s = be.exec(t[l]) || [])[1], 
f = (s[2] || "").split(".").sort(), p && (h = x.event.special[p] || {}, p = (i ? h.delegateType : h.bindType) || p, 
h = x.event.special[p] || {}, u = x.extend({
type: p,
origType: m,
data: r,
handler: n,
guid: n.guid,
selector: i,
needsContext: i && x.expr.match.needsContext.test(i),
namespace: f.join(".")
}, a), (d = c[p]) || ((d = c[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(e, r, f, o) || e.addEventListener && e.addEventListener(p, o)), 
h.add && (h.add.call(e, u), u.handler.guid || (u.handler.guid = n.guid)), i ? d.splice(d.delegateCount++, 0, u) : d.push(u), 
x.event.global[p] = !0);
},
remove: function(e, t, n, r, i) {
var a, o, s, c, l, u, h, d, p, f, m, g = Y.hasData(e) && Y.get(e);
if (g && (c = g.events)) {
for (l = (t = (t || "").match(N) || [ "" ]).length; l--; ) if (p = m = (s = be.exec(t[l]) || [])[1], 
f = (s[2] || "").split(".").sort(), p) {
for (h = x.event.special[p] || {}, d = c[p = (r ? h.delegateType : h.bindType) || p] || [], 
s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = a = d.length; a--; ) u = d[a], 
!i && m !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || r && r !== u.selector && ("**" !== r || !u.selector) || (d.splice(a, 1), 
u.selector && d.delegateCount--, h.remove && h.remove.call(e, u));
o && !d.length && (h.teardown && !1 !== h.teardown.call(e, f, g.handle) || x.removeEvent(e, p, g.handle), 
delete c[p]);
} else for (p in c) x.event.remove(e, p + t[l], n, r, !0);
x.isEmptyObject(c) && Y.remove(e, "handle events");
}
},
dispatch: function(e) {
var t, n, r, i, a, o, s = new Array(arguments.length), c = x.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[c.type] || [], u = x.event.special[c.type] || {};
for (s[0] = c, t = 1; t < arguments.length; t++) s[t] = arguments[t];
if (c.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, c)) {
for (o = x.event.handlers.call(this, c, l), t = 0; (i = o[t++]) && !c.isPropagationStopped(); ) for (c.currentTarget = i.elem, 
n = 0; (a = i.handlers[n++]) && !c.isImmediatePropagationStopped(); ) c.rnamespace && !1 !== a.namespace && !c.rnamespace.test(a.namespace) || (c.handleObj = a, 
c.data = a.data, void 0 !== (r = ((x.event.special[a.origType] || {}).handle || a.handler).apply(i.elem, s)) && !1 === (c.result = r) && (c.preventDefault(), 
c.stopPropagation()));
return u.postDispatch && u.postDispatch.call(this, c), c.result;
}
},
handlers: function(e, t) {
var n, r, i, a, o, s = [], c = t.delegateCount, l = e.target;
if (c && l.nodeType && !("click" === e.type && 1 <= e.button)) for (;l !== this; l = l.parentNode || this) if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
for (a = [], o = {}, n = 0; n < c; n++) void 0 === o[i = (r = t[n]).selector + " "] && (o[i] = r.needsContext ? -1 < x(i, this).index(l) : x.find(i, this, null, [ l ]).length), 
o[i] && a.push(r);
a.length && s.push({
elem: l,
handlers: a
});
}
return l = this, c < t.length && s.push({
elem: l,
handlers: t.slice(c)
}), s;
},
addProp: function(e, t) {
Object.defineProperty(x.Event.prototype, e, {
enumerable: !0,
configurable: !0,
get: f(t) ? function() {
if (this.originalEvent) return t(this.originalEvent);
} : function() {
if (this.originalEvent) return this.originalEvent[e];
},
set: function(t) {
Object.defineProperty(this, e, {
enumerable: !0,
configurable: !0,
writable: !0,
value: t
});
}
});
},
fix: function(e) {
return e[x.expando] ? e : new x.Event(e);
},
special: {
load: {
noBubble: !0
},
click: {
setup: function(e) {
var t = this || e;
return de.test(t.type) && t.click && T(t, "input") && Se(t, "click", xe), !1;
},
trigger: function(e) {
var t = this || e;
return de.test(t.type) && t.click && T(t, "input") && Se(t, "click"), !0;
},
_default: function(e) {
var t = e.target;
return de.test(t.type) && t.click && T(t, "input") && Y.get(t, "click") || T(t, "a");
}
},
beforeunload: {
postDispatch: function(e) {
void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
}
}
}
}, x.removeEvent = function(e, t, n) {
e.removeEventListener && e.removeEventListener(t, n);
}, x.Event = function(e, t) {
if (!(this instanceof x.Event)) return new x.Event(e, t);
e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? xe : we, 
this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, 
this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, 
t && x.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[x.expando] = !0;
}, x.Event.prototype = {
constructor: x.Event,
isDefaultPrevented: we,
isPropagationStopped: we,
isImmediatePropagationStopped: we,
isSimulated: !1,
preventDefault: function() {
var e = this.originalEvent;
this.isDefaultPrevented = xe, e && !this.isSimulated && e.preventDefault();
},
stopPropagation: function() {
var e = this.originalEvent;
this.isPropagationStopped = xe, e && !this.isSimulated && e.stopPropagation();
},
stopImmediatePropagation: function() {
var e = this.originalEvent;
this.isImmediatePropagationStopped = xe, e && !this.isSimulated && e.stopImmediatePropagation(), 
this.stopPropagation();
}
}, x.each({
altKey: !0,
bubbles: !0,
cancelable: !0,
changedTouches: !0,
ctrlKey: !0,
detail: !0,
eventPhase: !0,
metaKey: !0,
pageX: !0,
pageY: !0,
shiftKey: !0,
view: !0,
char: !0,
code: !0,
charCode: !0,
key: !0,
keyCode: !0,
button: !0,
buttons: !0,
clientX: !0,
clientY: !0,
offsetX: !0,
offsetY: !0,
pointerId: !0,
pointerType: !0,
screenX: !0,
screenY: !0,
targetTouches: !0,
toElement: !0,
touches: !0,
which: !0
}, x.event.addProp), x.each({
focus: "focusin",
blur: "focusout"
}, function(e, t) {
x.event.special[e] = {
setup: function() {
return Se(this, e, _e), !1;
},
trigger: function() {
return Se(this, e), !0;
},
_default: function() {
return !0;
},
delegateType: t
};
}), x.each({
mouseenter: "mouseover",
mouseleave: "mouseout",
pointerenter: "pointerover",
pointerleave: "pointerout"
}, function(e, t) {
x.event.special[e] = {
delegateType: t,
bindType: t,
handle: function(e) {
var n, r = e.relatedTarget, i = e.handleObj;
return r && (r === this || x.contains(this, r)) || (e.type = i.origType, n = i.handler.apply(this, arguments), 
e.type = t), n;
}
};
}), x.fn.extend({
on: function(e, t, n, r) {
return Me(this, e, t, n, r);
},
one: function(e, t, n, r) {
return Me(this, e, t, n, r, 1);
},
off: function(e, t, n) {
var r, i;
if (e && e.preventDefault && e.handleObj) return r = e.handleObj, x(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), 
this;
if ("object" == typeof e) {
for (i in e) this.off(i, t, e[i]);
return this;
}
return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = we), 
this.each(function() {
x.event.remove(this, e, n, t);
});
}
});
var Ae = /<script|<style|<link/i, Te = /checked\s*(?:[^=]|=\s*.checked.)/i, Le = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
function Ce(e, t) {
return T(e, "table") && T(11 !== t.nodeType ? t : t.firstChild, "tr") && x(e).children("tbody")[0] || e;
}
function Ee(e) {
return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
}
function Pe(e) {
return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), 
e;
}
function ke(e, t) {
var n, r, i, a, o, s;
if (1 === t.nodeType) {
if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), 
s) for (n = 0, r = s[i].length; n < r; n++) x.event.add(t, i, s[i][n]);
J.hasData(e) && (a = J.access(e), o = x.extend({}, a), J.set(t, o));
}
}
function Oe(e, t, n, r) {
t = a(t);
var i, o, s, c, l, u, h = 0, d = e.length, m = d - 1, g = t[0], v = f(g);
if (v || 1 < d && "string" == typeof g && !p.checkClone && Te.test(g)) return e.each(function(i) {
var a = e.eq(i);
v && (t[0] = g.call(this, i, a.html())), Oe(a, t, n, r);
});
if (d && (o = (i = $e(t, e[0].ownerDocument, !1, e, r)).firstChild, 1 === i.childNodes.length && (i = o), 
o || r)) {
for (c = (s = x.map(ge(i, "script"), Ee)).length; h < d; h++) l = i, h !== m && (l = x.clone(l, !0, !0), 
c && x.merge(s, ge(l, "script"))), n.call(e[h], l, h);
if (c) for (u = s[s.length - 1].ownerDocument, x.map(s, Pe), h = 0; h < c; h++) l = s[h], 
fe.test(l.type || "") && !Y.access(l, "globalEval") && x.contains(u, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? x._evalUrl && !l.noModule && x._evalUrl(l.src, {
nonce: l.nonce || l.getAttribute("nonce")
}, u) : y(l.textContent.replace(Le, ""), l, u));
}
return e;
}
function De(e, t, n) {
for (var r, i = t ? x.filter(t, e) : e, a = 0; null != (r = i[a]); a++) n || 1 !== r.nodeType || x.cleanData(ge(r)), 
r.parentNode && (n && ie(r) && ve(ge(r, "script")), r.parentNode.removeChild(r));
return e;
}
x.extend({
htmlPrefilter: function(e) {
return e;
},
clone: function(e, t, n) {
var r, i, a, o, s, c, l, u = e.cloneNode(!0), h = ie(e);
if (!(p.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e))) for (o = ge(u), 
r = 0, i = (a = ge(e)).length; r < i; r++) s = a[r], "input" === (l = (c = o[r]).nodeName.toLowerCase()) && de.test(s.type) ? c.checked = s.checked : "input" !== l && "textarea" !== l || (c.defaultValue = s.defaultValue);
if (t) if (n) for (a = a || ge(e), o = o || ge(u), r = 0, i = a.length; r < i; r++) ke(a[r], o[r]); else ke(e, u);
return 0 < (o = ge(u, "script")).length && ve(o, !h && ge(e, "script")), u;
},
cleanData: function(e) {
for (var t, n, r, i = x.event.special, a = 0; void 0 !== (n = e[a]); a++) if (H(n)) {
if (t = n[Y.expando]) {
if (t.events) for (r in t.events) i[r] ? x.event.remove(n, r) : x.removeEvent(n, r, t.handle);
n[Y.expando] = void 0;
}
n[J.expando] && (n[J.expando] = void 0);
}
}
}), x.fn.extend({
detach: function(e) {
return De(this, e, !0);
},
remove: function(e) {
return De(this, e);
},
text: function(e) {
return F(this, function(e) {
return void 0 === e ? x.text(this) : this.empty().each(function() {
1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
});
}, null, e, arguments.length);
},
append: function() {
return Oe(this, arguments, function(e) {
1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Ce(this, e).appendChild(e);
});
},
prepend: function() {
return Oe(this, arguments, function(e) {
if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
var t = Ce(this, e);
t.insertBefore(e, t.firstChild);
}
});
},
before: function() {
return Oe(this, arguments, function(e) {
this.parentNode && this.parentNode.insertBefore(e, this);
});
},
after: function() {
return Oe(this, arguments, function(e) {
this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
});
},
empty: function() {
for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (x.cleanData(ge(e, !1)), 
e.textContent = "");
return this;
},
clone: function(e, t) {
return e = null != e && e, t = null == t ? e : t, this.map(function() {
return x.clone(this, e, t);
});
},
html: function(e) {
return F(this, function(e) {
var t = this[0] || {}, n = 0, r = this.length;
if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
if ("string" == typeof e && !Ae.test(e) && !me[(pe.exec(e) || [ "", "" ])[1].toLowerCase()]) {
e = x.htmlPrefilter(e);
try {
for (;n < r; n++) 1 === (t = this[n] || {}).nodeType && (x.cleanData(ge(t, !1)), 
t.innerHTML = e);
t = 0;
} catch (e) {}
}
t && this.empty().append(e);
}, null, e, arguments.length);
},
replaceWith: function() {
var e = [];
return Oe(this, arguments, function(t) {
var n = this.parentNode;
x.inArray(this, e) < 0 && (x.cleanData(ge(this)), n && n.replaceChild(t, this));
}, e);
}
}), x.each({
appendTo: "append",
prependTo: "prepend",
insertBefore: "before",
insertAfter: "after",
replaceAll: "replaceWith"
}, function(e, t) {
x.fn[e] = function(e) {
for (var n, r = [], i = x(e), a = i.length - 1, s = 0; s <= a; s++) n = s === a ? this : this.clone(!0), 
x(i[s])[t](n), o.apply(r, n.get());
return this.pushStack(r);
};
});
var Ne = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Ie = function(t) {
var n = t.ownerDocument.defaultView;
return n && n.opener || (n = e), n.getComputedStyle(t);
}, Re = function(e, t, n) {
var r, i, a = {};
for (i in t) a[i] = e.style[i], e.style[i] = t[i];
for (i in r = n.call(e), t) e.style[i] = a[i];
return r;
}, je = new RegExp(ne.join("|"), "i");
function Ue(e, t, n) {
var r, i, a, o, s = e.style;
return (n = n || Ie(e)) && ("" !== (o = n.getPropertyValue(t) || n[t]) || ie(e) || (o = x.style(e, t)), 
!p.pixelBoxStyles() && Ne.test(o) && je.test(t) && (r = s.width, i = s.minWidth, 
a = s.maxWidth, s.minWidth = s.maxWidth = s.width = o, o = n.width, s.width = r, 
s.minWidth = i, s.maxWidth = a)), void 0 !== o ? o + "" : o;
}
function Be(e, t) {
return {
get: function() {
if (!e()) return (this.get = t).apply(this, arguments);
delete this.get;
}
};
}
!function() {
function t() {
if (u) {
l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", 
u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", 
re.appendChild(l).appendChild(u);
var t = e.getComputedStyle(u);
r = "1%" !== t.top, c = 12 === n(t.marginLeft), u.style.right = "60%", o = 36 === n(t.right), 
i = 36 === n(t.width), u.style.position = "absolute", a = 12 === n(u.offsetWidth / 3), 
re.removeChild(l), u = null;
}
}
function n(e) {
return Math.round(parseFloat(e));
}
var r, i, a, o, s, c, l = g.createElement("div"), u = g.createElement("div");
u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", 
p.clearCloneStyle = "content-box" === u.style.backgroundClip, x.extend(p, {
boxSizingReliable: function() {
return t(), i;
},
pixelBoxStyles: function() {
return t(), o;
},
pixelPosition: function() {
return t(), r;
},
reliableMarginLeft: function() {
return t(), c;
},
scrollboxSize: function() {
return t(), a;
},
reliableTrDimensions: function() {
var t, n, r, i;
return null == s && (t = g.createElement("table"), n = g.createElement("tr"), r = g.createElement("div"), 
t.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", n.style.cssText = "border:1px solid", 
n.style.height = "1px", r.style.height = "9px", r.style.display = "block", re.appendChild(t).appendChild(n).appendChild(r), 
i = e.getComputedStyle(n), s = parseInt(i.height, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10) === n.offsetHeight, 
re.removeChild(t)), s;
}
}));
}();
var ze = [ "Webkit", "Moz", "ms" ], Fe = g.createElement("div").style, Ge = {};
function Ve(e) {
return x.cssProps[e] || Ge[e] || (e in Fe ? e : Ge[e] = function(e) {
for (var t = e[0].toUpperCase() + e.slice(1), n = ze.length; n--; ) if ((e = ze[n] + t) in Fe) return e;
}(e) || e);
}
var We = /^(none|table(?!-c[ea]).+)/, qe = /^--/, He = {
position: "absolute",
visibility: "hidden",
display: "block"
}, Xe = {
letterSpacing: "0",
fontWeight: "400"
};
function Ye(e, t, n) {
var r = te.exec(t);
return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
}
function Je(e, t, n, r, i, a) {
var o = "width" === t ? 1 : 0, s = 0, c = 0;
if (n === (r ? "border" : "content")) return 0;
for (;o < 4; o += 2) "margin" === n && (c += x.css(e, n + ne[o], !0, i)), r ? ("content" === n && (c -= x.css(e, "padding" + ne[o], !0, i)), 
"margin" !== n && (c -= x.css(e, "border" + ne[o] + "Width", !0, i))) : (c += x.css(e, "padding" + ne[o], !0, i), 
"padding" !== n ? c += x.css(e, "border" + ne[o] + "Width", !0, i) : s += x.css(e, "border" + ne[o] + "Width", !0, i));
return !r && 0 <= a && (c += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - a - c - s - .5)) || 0), 
c;
}
function Ze(e, t, n) {
var r = Ie(e), i = (!p.boxSizingReliable() || n) && "border-box" === x.css(e, "boxSizing", !1, r), a = i, o = Ue(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1);
if (Ne.test(o)) {
if (!n) return o;
o = "auto";
}
return (!p.boxSizingReliable() && i || !p.reliableTrDimensions() && T(e, "tr") || "auto" === o || !parseFloat(o) && "inline" === x.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === x.css(e, "boxSizing", !1, r), 
(a = s in e) && (o = e[s])), (o = parseFloat(o) || 0) + Je(e, t, n || (i ? "border" : "content"), a, r, o) + "px";
}
function Ke(e, t, n, r, i) {
return new Ke.prototype.init(e, t, n, r, i);
}
x.extend({
cssHooks: {
opacity: {
get: function(e, t) {
if (t) {
var n = Ue(e, "opacity");
return "" === n ? "1" : n;
}
}
}
},
cssNumber: {
animationIterationCount: !0,
columnCount: !0,
fillOpacity: !0,
flexGrow: !0,
flexShrink: !0,
fontWeight: !0,
gridArea: !0,
gridColumn: !0,
gridColumnEnd: !0,
gridColumnStart: !0,
gridRow: !0,
gridRowEnd: !0,
gridRowStart: !0,
lineHeight: !0,
opacity: !0,
order: !0,
orphans: !0,
widows: !0,
zIndex: !0,
zoom: !0
},
cssProps: {},
style: function(e, t, n, r) {
if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
var i, a, o, s = q(t), c = qe.test(t), l = e.style;
if (c || (t = Ve(s)), o = x.cssHooks[t] || x.cssHooks[s], void 0 === n) return o && "get" in o && void 0 !== (i = o.get(e, !1, r)) ? i : l[t];
"string" == (a = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), a = "number"), 
null != n && n == n && ("number" !== a || c || (n += i && i[3] || (x.cssNumber[s] ? "" : "px")), 
p.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), 
o && "set" in o && void 0 === (n = o.set(e, n, r)) || (c ? l.setProperty(t, n) : l[t] = n));
}
},
css: function(e, t, n, r) {
var i, a, o, s = q(t);
return qe.test(t) || (t = Ve(s)), (o = x.cssHooks[t] || x.cssHooks[s]) && "get" in o && (i = o.get(e, !0, n)), 
void 0 === i && (i = Ue(e, t, r)), "normal" === i && t in Xe && (i = Xe[t]), "" === n || n ? (a = parseFloat(i), 
!0 === n || isFinite(a) ? a || 0 : i) : i;
}
}), x.each([ "height", "width" ], function(e, t) {
x.cssHooks[t] = {
get: function(e, n, r) {
if (n) return !We.test(x.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Ze(e, t, r) : Re(e, He, function() {
return Ze(e, t, r);
});
},
set: function(e, n, r) {
var i, a = Ie(e), o = !p.scrollboxSize() && "absolute" === a.position, s = (o || r) && "border-box" === x.css(e, "boxSizing", !1, a), c = r ? Je(e, t, r, s, a) : 0;
return s && o && (c -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(a[t]) - Je(e, t, "border", !1, a) - .5)), 
c && (i = te.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = x.css(e, t)), 
Ye(0, n, c);
}
};
}), x.cssHooks.marginLeft = Be(p.reliableMarginLeft, function(e, t) {
if (t) return (parseFloat(Ue(e, "marginLeft")) || e.getBoundingClientRect().left - Re(e, {
marginLeft: 0
}, function() {
return e.getBoundingClientRect().left;
})) + "px";
}), x.each({
margin: "",
padding: "",
border: "Width"
}, function(e, t) {
x.cssHooks[e + t] = {
expand: function(n) {
for (var r = 0, i = {}, a = "string" == typeof n ? n.split(" ") : [ n ]; r < 4; r++) i[e + ne[r] + t] = a[r] || a[r - 2] || a[0];
return i;
}
}, "margin" !== e && (x.cssHooks[e + t].set = Ye);
}), x.fn.extend({
css: function(e, t) {
return F(this, function(e, t, n) {
var r, i, a = {}, o = 0;
if (Array.isArray(t)) {
for (r = Ie(e), i = t.length; o < i; o++) a[t[o]] = x.css(e, t[o], !1, r);
return a;
}
return void 0 !== n ? x.style(e, t, n) : x.css(e, t);
}, e, t, 1 < arguments.length);
}
}), ((x.Tween = Ke).prototype = {
constructor: Ke,
init: function(e, t, n, r, i, a) {
this.elem = e, this.prop = n, this.easing = i || x.easing._default, this.options = t, 
this.start = this.now = this.cur(), this.end = r, this.unit = a || (x.cssNumber[n] ? "" : "px");
},
cur: function() {
var e = Ke.propHooks[this.prop];
return e && e.get ? e.get(this) : Ke.propHooks._default.get(this);
},
run: function(e) {
var t, n = Ke.propHooks[this.prop];
return this.options.duration ? this.pos = t = x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, 
this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this;
}
}).init.prototype = Ke.prototype, (Ke.propHooks = {
_default: {
get: function(e) {
var t;
return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = x.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
},
set: function(e) {
x.fx.step[e.prop] ? x.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !x.cssHooks[e.prop] && null == e.elem.style[Ve(e.prop)] ? e.elem[e.prop] = e.now : x.style(e.elem, e.prop, e.now + e.unit);
}
}
}).scrollTop = Ke.propHooks.scrollLeft = {
set: function(e) {
e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
}
}, x.easing = {
linear: function(e) {
return e;
},
swing: function(e) {
return .5 - Math.cos(e * Math.PI) / 2;
},
_default: "swing"
}, x.fx = Ke.prototype.init, x.fx.step = {};
var Qe, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/;
function at() {
et && (!1 === g.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, x.fx.interval), 
x.fx.tick());
}
function ot() {
return e.setTimeout(function() {
Qe = void 0;
}), Qe = Date.now();
}
function st(e, t) {
var n, r = 0, i = {
height: e
};
for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;
return t && (i.opacity = i.width = e), i;
}
function ct(e, t, n) {
for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), a = 0, o = i.length; a < o; a++) if (r = i[a].call(n, t, e)) return r;
}
function lt(e, t, n) {
var r, i, a = 0, o = lt.prefilters.length, s = x.Deferred().always(function() {
delete c.elem;
}), c = function() {
if (i) return !1;
for (var t = Qe || ot(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), a = 0, o = l.tweens.length; a < o; a++) l.tweens[a].run(r);
return s.notifyWith(e, [ l, r, n ]), r < 1 && o ? n : (o || s.notifyWith(e, [ l, 1, 0 ]), 
s.resolveWith(e, [ l ]), !1);
}, l = s.promise({
elem: e,
props: x.extend({}, t),
opts: x.extend(!0, {
specialEasing: {},
easing: x.easing._default
}, n),
originalProperties: t,
originalOptions: n,
startTime: Qe || ot(),
duration: n.duration,
tweens: [],
createTween: function(t, n) {
var r = x.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
return l.tweens.push(r), r;
},
stop: function(t) {
var n = 0, r = t ? l.tweens.length : 0;
if (i) return this;
for (i = !0; n < r; n++) l.tweens[n].run(1);
return t ? (s.notifyWith(e, [ l, 1, 0 ]), s.resolveWith(e, [ l, t ])) : s.rejectWith(e, [ l, t ]), 
this;
}
}), u = l.props;
for (function(e, t) {
var n, r, i, a, o;
for (n in e) if (i = t[r = q(n)], a = e[n], Array.isArray(a) && (i = a[1], a = e[n] = a[0]), 
n !== r && (e[r] = a, delete e[n]), (o = x.cssHooks[r]) && "expand" in o) for (n in a = o.expand(a), 
delete e[r], a) n in e || (e[n] = a[n], t[n] = i); else t[r] = i;
}(u, l.opts.specialEasing); a < o; a++) if (r = lt.prefilters[a].call(l, e, u, l.opts)) return f(r.stop) && (x._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), 
r;
return x.map(u, ct, l), f(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), 
x.fx.timer(x.extend(c, {
elem: e,
anim: l,
queue: l.opts.queue
})), l;
}
x.Animation = x.extend(lt, {
tweeners: {
"*": [ function(e, t) {
var n = this.createTween(e, t);
return se(n.elem, e, te.exec(t), n), n;
} ]
},
tweener: function(e, t) {
f(e) ? (t = e, e = [ "*" ]) : e = e.match(N);
for (var n, r = 0, i = e.length; r < i; r++) n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], 
lt.tweeners[n].unshift(t);
},
prefilters: [ function(e, t, n) {
var r, i, a, o, s, c, l, u, h = "width" in t || "height" in t, d = this, p = {}, f = e.style, m = e.nodeType && oe(e), g = Y.get(e, "fxshow");
for (r in n.queue || (null == (o = x._queueHooks(e, "fx")).unqueued && (o.unqueued = 0, 
s = o.empty.fire, o.empty.fire = function() {
o.unqueued || s();
}), o.unqueued++, d.always(function() {
d.always(function() {
o.unqueued--, x.queue(e, "fx").length || o.empty.fire();
});
})), t) if (i = t[r], rt.test(i)) {
if (delete t[r], a = a || "toggle" === i, i === (m ? "hide" : "show")) {
if ("show" !== i || !g || void 0 === g[r]) continue;
m = !0;
}
p[r] = g && g[r] || x.style(e, r);
}
if ((c = !x.isEmptyObject(t)) || !x.isEmptyObject(p)) for (r in h && 1 === e.nodeType && (n.overflow = [ f.overflow, f.overflowX, f.overflowY ], 
null == (l = g && g.display) && (l = Y.get(e, "display")), "none" === (u = x.css(e, "display")) && (l ? u = l : (le([ e ], !0), 
l = e.style.display || l, u = x.css(e, "display"), le([ e ]))), ("inline" === u || "inline-block" === u && null != l) && "none" === x.css(e, "float") && (c || (d.done(function() {
f.display = l;
}), null == l && (u = f.display, l = "none" === u ? "" : u)), f.display = "inline-block")), 
n.overflow && (f.overflow = "hidden", d.always(function() {
f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2];
})), c = !1, p) c || (g ? "hidden" in g && (m = g.hidden) : g = Y.access(e, "fxshow", {
display: l
}), a && (g.hidden = !m), m && le([ e ], !0), d.done(function() {
for (r in m || le([ e ]), Y.remove(e, "fxshow"), p) x.style(e, r, p[r]);
})), c = ct(m ? g[r] : 0, r, d), r in g || (g[r] = c.start, m && (c.end = c.start, 
c.start = 0));
} ],
prefilter: function(e, t) {
t ? lt.prefilters.unshift(e) : lt.prefilters.push(e);
}
}), x.speed = function(e, t, n) {
var r = e && "object" == typeof e ? x.extend({}, e) : {
complete: n || !n && t || f(e) && e,
duration: e,
easing: n && t || t && !f(t) && t
};
return x.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in x.fx.speeds ? r.duration = x.fx.speeds[r.duration] : r.duration = x.fx.speeds._default), 
null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
f(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue);
}, r;
}, x.fn.extend({
fadeTo: function(e, t, n, r) {
return this.filter(oe).css("opacity", 0).show().end().animate({
opacity: t
}, e, n, r);
},
animate: function(e, t, n, r) {
var i = x.isEmptyObject(e), a = x.speed(t, n, r), o = function() {
var t = lt(this, x.extend({}, e), a);
(i || Y.get(this, "finish")) && t.stop(!0);
};
return o.finish = o, i || !1 === a.queue ? this.each(o) : this.queue(a.queue, o);
},
stop: function(e, t, n) {
var r = function(e) {
var t = e.stop;
delete e.stop, t(n);
};
return "string" != typeof e && (n = t, t = e, e = void 0), t && this.queue(e || "fx", []), 
this.each(function() {
var t = !0, i = null != e && e + "queueHooks", a = x.timers, o = Y.get(this);
if (i) o[i] && o[i].stop && r(o[i]); else for (i in o) o[i] && o[i].stop && it.test(i) && r(o[i]);
for (i = a.length; i--; ) a[i].elem !== this || null != e && a[i].queue !== e || (a[i].anim.stop(n), 
t = !1, a.splice(i, 1));
!t && n || x.dequeue(this, e);
});
},
finish: function(e) {
return !1 !== e && (e = e || "fx"), this.each(function() {
var t, n = Y.get(this), r = n[e + "queue"], i = n[e + "queueHooks"], a = x.timers, o = r ? r.length : 0;
for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), 
t = a.length; t--; ) a[t].elem === this && a[t].queue === e && (a[t].anim.stop(!0), 
a.splice(t, 1));
for (t = 0; t < o; t++) r[t] && r[t].finish && r[t].finish.call(this);
delete n.finish;
});
}
}), x.each([ "toggle", "show", "hide" ], function(e, t) {
var n = x.fn[t];
x.fn[t] = function(e, r, i) {
return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(st(t, !0), e, r, i);
};
}), x.each({
slideDown: st("show"),
slideUp: st("hide"),
slideToggle: st("toggle"),
fadeIn: {
opacity: "show"
},
fadeOut: {
opacity: "hide"
},
fadeToggle: {
opacity: "toggle"
}
}, function(e, t) {
x.fn[e] = function(e, n, r) {
return this.animate(t, e, n, r);
};
}), x.timers = [], x.fx.tick = function() {
var e, t = 0, n = x.timers;
for (Qe = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
n.length || x.fx.stop(), Qe = void 0;
}, x.fx.timer = function(e) {
x.timers.push(e), x.fx.start();
}, x.fx.interval = 13, x.fx.start = function() {
et || (et = !0, at());
}, x.fx.stop = function() {
et = null;
}, x.fx.speeds = {
slow: 600,
fast: 200,
_default: 400
}, x.fn.delay = function(t, n) {
return t = x.fx && x.fx.speeds[t] || t, n = n || "fx", this.queue(n, function(n, r) {
var i = e.setTimeout(n, t);
r.stop = function() {
e.clearTimeout(i);
};
});
}, tt = g.createElement("input"), nt = g.createElement("select").appendChild(g.createElement("option")), 
tt.type = "checkbox", p.checkOn = "" !== tt.value, p.optSelected = nt.selected, 
(tt = g.createElement("input")).value = "t", tt.type = "radio", p.radioValue = "t" === tt.value;
var ut, ht = x.expr.attrHandle;
x.fn.extend({
attr: function(e, t) {
return F(this, x.attr, e, t, 1 < arguments.length);
},
removeAttr: function(e) {
return this.each(function() {
x.removeAttr(this, e);
});
}
}), x.extend({
attr: function(e, t, n) {
var r, i, a = e.nodeType;
if (3 !== a && 8 !== a && 2 !== a) return void 0 === e.getAttribute ? x.prop(e, t, n) : (1 === a && x.isXMLDoc(e) || (i = x.attrHooks[t.toLowerCase()] || (x.expr.match.bool.test(t) ? ut : void 0)), 
void 0 !== n ? null === n ? void x.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), 
n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = x.find.attr(e, t)) ? void 0 : r);
},
attrHooks: {
type: {
set: function(e, t) {
if (!p.radioValue && "radio" === t && T(e, "input")) {
var n = e.value;
return e.setAttribute("type", t), n && (e.value = n), t;
}
}
}
},
removeAttr: function(e, t) {
var n, r = 0, i = t && t.match(N);
if (i && 1 === e.nodeType) for (;n = i[r++]; ) e.removeAttribute(n);
}
}), ut = {
set: function(e, t, n) {
return !1 === t ? x.removeAttr(e, n) : e.setAttribute(n, n), n;
}
}, x.each(x.expr.match.bool.source.match(/\w+/g), function(e, t) {
var n = ht[t] || x.find.attr;
ht[t] = function(e, t, r) {
var i, a, o = t.toLowerCase();
return r || (a = ht[o], ht[o] = i, i = null != n(e, t, r) ? o : null, ht[o] = a), 
i;
};
});
var dt = /^(?:input|select|textarea|button)$/i, pt = /^(?:a|area)$/i;
function ft(e) {
return (e.match(N) || []).join(" ");
}
function mt(e) {
return e.getAttribute && e.getAttribute("class") || "";
}
function gt(e) {
return Array.isArray(e) ? e : "string" == typeof e && e.match(N) || [];
}
x.fn.extend({
prop: function(e, t) {
return F(this, x.prop, e, t, 1 < arguments.length);
},
removeProp: function(e) {
return this.each(function() {
delete this[x.propFix[e] || e];
});
}
}), x.extend({
prop: function(e, t, n) {
var r, i, a = e.nodeType;
if (3 !== a && 8 !== a && 2 !== a) return 1 === a && x.isXMLDoc(e) || (t = x.propFix[t] || t, 
i = x.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
},
propHooks: {
tabIndex: {
get: function(e) {
var t = x.find.attr(e, "tabindex");
return t ? parseInt(t, 10) : dt.test(e.nodeName) || pt.test(e.nodeName) && e.href ? 0 : -1;
}
}
},
propFix: {
for: "htmlFor",
class: "className"
}
}), p.optSelected || (x.propHooks.selected = {
get: function(e) {
var t = e.parentNode;
return t && t.parentNode && t.parentNode.selectedIndex, null;
},
set: function(e) {
var t = e.parentNode;
t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
}
}), x.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
x.propFix[this.toLowerCase()] = this;
}), x.fn.extend({
addClass: function(e) {
var t, n, r, i, a, o, s, c = 0;
if (f(e)) return this.each(function(t) {
x(this).addClass(e.call(this, t, mt(this)));
});
if ((t = gt(e)).length) for (;n = this[c++]; ) if (i = mt(n), r = 1 === n.nodeType && " " + ft(i) + " ") {
for (o = 0; a = t[o++]; ) r.indexOf(" " + a + " ") < 0 && (r += a + " ");
i !== (s = ft(r)) && n.setAttribute("class", s);
}
return this;
},
removeClass: function(e) {
var t, n, r, i, a, o, s, c = 0;
if (f(e)) return this.each(function(t) {
x(this).removeClass(e.call(this, t, mt(this)));
});
if (!arguments.length) return this.attr("class", "");
if ((t = gt(e)).length) for (;n = this[c++]; ) if (i = mt(n), r = 1 === n.nodeType && " " + ft(i) + " ") {
for (o = 0; a = t[o++]; ) for (;-1 < r.indexOf(" " + a + " "); ) r = r.replace(" " + a + " ", " ");
i !== (s = ft(r)) && n.setAttribute("class", s);
}
return this;
},
toggleClass: function(e, t) {
var n = typeof e, r = "string" === n || Array.isArray(e);
return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : f(e) ? this.each(function(n) {
x(this).toggleClass(e.call(this, n, mt(this), t), t);
}) : this.each(function() {
var t, i, a, o;
if (r) for (i = 0, a = x(this), o = gt(e); t = o[i++]; ) a.hasClass(t) ? a.removeClass(t) : a.addClass(t); else void 0 !== e && "boolean" !== n || ((t = mt(this)) && Y.set(this, "__className__", t), 
this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : Y.get(this, "__className__") || ""));
});
},
hasClass: function(e) {
var t, n, r = 0;
for (t = " " + e + " "; n = this[r++]; ) if (1 === n.nodeType && -1 < (" " + ft(mt(n)) + " ").indexOf(t)) return !0;
return !1;
}
});
var vt = /\r/g;
x.fn.extend({
val: function(e) {
var t, n, r, i = this[0];
return arguments.length ? (r = f(e), this.each(function(n) {
var i;
1 === this.nodeType && (null == (i = r ? e.call(this, n, x(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = x.map(i, function(e) {
return null == e ? "" : e + "";
})), (t = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i));
})) : i ? (t = x.valHooks[i.type] || x.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(vt, "") : null == n ? "" : n : void 0;
}
}), x.extend({
valHooks: {
option: {
get: function(e) {
var t = x.find.attr(e, "value");
return null != t ? t : ft(x.text(e));
}
},
select: {
get: function(e) {
var t, n, r, i = e.options, a = e.selectedIndex, o = "select-one" === e.type, s = o ? null : [], c = o ? a + 1 : i.length;
for (r = a < 0 ? c : o ? a : 0; r < c; r++) if (((n = i[r]).selected || r === a) && !n.disabled && (!n.parentNode.disabled || !T(n.parentNode, "optgroup"))) {
if (t = x(n).val(), o) return t;
s.push(t);
}
return s;
},
set: function(e, t) {
for (var n, r, i = e.options, a = x.makeArray(t), o = i.length; o--; ) ((r = i[o]).selected = -1 < x.inArray(x.valHooks.option.get(r), a)) && (n = !0);
return n || (e.selectedIndex = -1), a;
}
}
}
}), x.each([ "radio", "checkbox" ], function() {
x.valHooks[this] = {
set: function(e, t) {
if (Array.isArray(t)) return e.checked = -1 < x.inArray(x(e).val(), t);
}
}, p.checkOn || (x.valHooks[this].get = function(e) {
return null === e.getAttribute("value") ? "on" : e.value;
});
}), p.focusin = "onfocusin" in e;
var yt = /^(?:focusinfocus|focusoutblur)$/, $t = function(e) {
e.stopPropagation();
};
x.extend(x.event, {
trigger: function(t, n, r, i) {
var a, o, s, c, l, h, d, p, v = [ r || g ], y = u.call(t, "type") ? t.type : t, $ = u.call(t, "namespace") ? t.namespace.split(".") : [];
if (o = p = s = r = r || g, 3 !== r.nodeType && 8 !== r.nodeType && !yt.test(y + x.event.triggered) && (-1 < y.indexOf(".") && (y = ($ = y.split(".")).shift(), 
$.sort()), l = y.indexOf(":") < 0 && "on" + y, (t = t[x.expando] ? t : new x.Event(y, "object" == typeof t && t)).isTrigger = i ? 2 : 3, 
t.namespace = $.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + $.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
t.result = void 0, t.target || (t.target = r), n = null == n ? [ t ] : x.makeArray(n, [ t ]), 
d = x.event.special[y] || {}, i || !d.trigger || !1 !== d.trigger.apply(r, n))) {
if (!i && !d.noBubble && !m(r)) {
for (c = d.delegateType || y, yt.test(c + y) || (o = o.parentNode); o; o = o.parentNode) v.push(o), 
s = o;
s === (r.ownerDocument || g) && v.push(s.defaultView || s.parentWindow || e);
}
for (a = 0; (o = v[a++]) && !t.isPropagationStopped(); ) p = o, t.type = 1 < a ? c : d.bindType || y, 
(h = (Y.get(o, "events") || Object.create(null))[t.type] && Y.get(o, "handle")) && h.apply(o, n), 
(h = l && o[l]) && h.apply && H(o) && (t.result = h.apply(o, n), !1 === t.result && t.preventDefault());
return t.type = y, i || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !H(r) || l && f(r[y]) && !m(r) && ((s = r[l]) && (r[l] = null), 
x.event.triggered = y, t.isPropagationStopped() && p.addEventListener(y, $t), r[y](), 
t.isPropagationStopped() && p.removeEventListener(y, $t), x.event.triggered = void 0, 
s && (r[l] = s)), t.result;
}
},
simulate: function(e, t, n) {
var r = x.extend(new x.Event(), n, {
type: e,
isSimulated: !0
});
x.event.trigger(r, null, t);
}
}), x.fn.extend({
trigger: function(e, t) {
return this.each(function() {
x.event.trigger(e, t, this);
});
},
triggerHandler: function(e, t) {
var n = this[0];
if (n) return x.event.trigger(e, t, n, !0);
}
}), p.focusin || x.each({
focus: "focusin",
blur: "focusout"
}, function(e, t) {
var n = function(e) {
x.event.simulate(t, e.target, x.event.fix(e));
};
x.event.special[t] = {
setup: function() {
var r = this.ownerDocument || this.document || this, i = Y.access(r, t);
i || r.addEventListener(e, n, !0), Y.access(r, t, (i || 0) + 1);
},
teardown: function() {
var r = this.ownerDocument || this.document || this, i = Y.access(r, t) - 1;
i ? Y.access(r, t, i) : (r.removeEventListener(e, n, !0), Y.remove(r, t));
}
};
});
var bt = e.location, xt = {
guid: Date.now()
}, wt = /\?/;
x.parseXML = function(t) {
var n, r;
if (!t || "string" != typeof t) return null;
try {
n = new e.DOMParser().parseFromString(t, "text/xml");
} catch (t) {}
return r = n && n.getElementsByTagName("parsererror")[0], n && !r || x.error("Invalid XML: " + (r ? x.map(r.childNodes, function(e) {
return e.textContent;
}).join("\n") : t)), n;
};
var _t = /\[\]$/, Mt = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, At = /^(?:input|select|textarea|keygen)/i;
function Tt(e, t, n, r) {
var i;
if (Array.isArray(t)) x.each(t, function(t, i) {
n || _t.test(e) ? r(e, i) : Tt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r);
}); else if (n || "object" !== $(t)) r(e, t); else for (i in t) Tt(e + "[" + i + "]", t[i], n, r);
}
x.param = function(e, t) {
var n, r = [], i = function(e, t) {
var n = f(t) ? t() : t;
r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
};
if (null == e) return "";
if (Array.isArray(e) || e.jquery && !x.isPlainObject(e)) x.each(e, function() {
i(this.name, this.value);
}); else for (n in e) Tt(n, e[n], t, i);
return r.join("&");
}, x.fn.extend({
serialize: function() {
return x.param(this.serializeArray());
},
serializeArray: function() {
return this.map(function() {
var e = x.prop(this, "elements");
return e ? x.makeArray(e) : this;
}).filter(function() {
var e = this.type;
return this.name && !x(this).is(":disabled") && At.test(this.nodeName) && !St.test(e) && (this.checked || !de.test(e));
}).map(function(e, t) {
var n = x(this).val();
return null == n ? null : Array.isArray(n) ? x.map(n, function(e) {
return {
name: t.name,
value: e.replace(Mt, "\r\n")
};
}) : {
name: t.name,
value: n.replace(Mt, "\r\n")
};
}).get();
}
});
var Lt = /%20/g, Ct = /#.*$/, Et = /([?&])_=[^&]*/, Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm, kt = /^(?:GET|HEAD)$/, Ot = /^\/\//, Dt = {}, Nt = {}, It = "*/".concat("*"), Rt = g.createElement("a");
function jt(e) {
return function(t, n) {
"string" != typeof t && (n = t, t = "*");
var r, i = 0, a = t.toLowerCase().match(N) || [];
if (f(n)) for (;r = a[i++]; ) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
};
}
function Ut(e, t, n, r) {
var i = {}, a = e === Nt;
function o(s) {
var c;
return i[s] = !0, x.each(e[s] || [], function(e, s) {
var l = s(t, n, r);
return "string" != typeof l || a || i[l] ? a ? !(c = l) : void 0 : (t.dataTypes.unshift(l), 
o(l), !1);
}), c;
}
return o(t.dataTypes[0]) || !i["*"] && o("*");
}
function Bt(e, t) {
var n, r, i = x.ajaxSettings.flatOptions || {};
for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
return r && x.extend(!0, e, r), e;
}
Rt.href = bt.href, x.extend({
active: 0,
lastModified: {},
etag: {},
ajaxSettings: {
url: bt.href,
type: "GET",
isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
global: !0,
processData: !0,
async: !0,
contentType: "application/x-www-form-urlencoded; charset=UTF-8",
accepts: {
"*": It,
text: "text/plain",
html: "text/html",
xml: "application/xml, text/xml",
json: "application/json, text/javascript"
},
contents: {
xml: /\bxml\b/,
html: /\bhtml/,
json: /\bjson\b/
},
responseFields: {
xml: "responseXML",
text: "responseText",
json: "responseJSON"
},
converters: {
"* text": String,
"text html": !0,
"text json": JSON.parse,
"text xml": x.parseXML
},
flatOptions: {
url: !0,
context: !0
}
},
ajaxSetup: function(e, t) {
return t ? Bt(Bt(e, x.ajaxSettings), t) : Bt(x.ajaxSettings, e);
},
ajaxPrefilter: jt(Dt),
ajaxTransport: jt(Nt),
ajax: function(t, n) {
"object" == typeof t && (n = t, t = void 0), n = n || {};
var r, i, a, o, s, c, l, u, h, d, p = x.ajaxSetup({}, n), f = p.context || p, m = p.context && (f.nodeType || f.jquery) ? x(f) : x.event, v = x.Deferred(), y = x.Callbacks("once memory"), $ = p.statusCode || {}, b = {}, w = {}, _ = "canceled", M = {
readyState: 0,
getResponseHeader: function(e) {
var t;
if (l) {
if (!o) for (o = {}; t = Pt.exec(a); ) o[t[1].toLowerCase() + " "] = (o[t[1].toLowerCase() + " "] || []).concat(t[2]);
t = o[e.toLowerCase() + " "];
}
return null == t ? null : t.join(", ");
},
getAllResponseHeaders: function() {
return l ? a : null;
},
setRequestHeader: function(e, t) {
return null == l && (e = w[e.toLowerCase()] = w[e.toLowerCase()] || e, b[e] = t), 
this;
},
overrideMimeType: function(e) {
return null == l && (p.mimeType = e), this;
},
statusCode: function(e) {
var t;
if (e) if (l) M.always(e[M.status]); else for (t in e) $[t] = [ $[t], e[t] ];
return this;
},
abort: function(e) {
var t = e || _;
return r && r.abort(t), S(0, t), this;
}
};
if (v.promise(M), p.url = ((t || p.url || bt.href) + "").replace(Ot, bt.protocol + "//"), 
p.type = n.method || n.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(N) || [ "" ], 
null == p.crossDomain) {
c = g.createElement("a");
try {
c.href = p.url, c.href = c.href, p.crossDomain = Rt.protocol + "//" + Rt.host != c.protocol + "//" + c.host;
} catch (t) {
p.crossDomain = !0;
}
}
if (p.data && p.processData && "string" != typeof p.data && (p.data = x.param(p.data, p.traditional)), 
Ut(Dt, p, n, M), l) return M;
for (h in (u = x.event && p.global) && 0 == x.active++ && x.event.trigger("ajaxStart"), 
p.type = p.type.toUpperCase(), p.hasContent = !kt.test(p.type), i = p.url.replace(Ct, ""), 
p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Lt, "+")) : (d = p.url.slice(i.length), 
p.data && (p.processData || "string" == typeof p.data) && (i += (wt.test(i) ? "&" : "?") + p.data, 
delete p.data), !1 === p.cache && (i = i.replace(Et, "$1"), d = (wt.test(i) ? "&" : "?") + "_=" + xt.guid++ + d), 
p.url = i + d), p.ifModified && (x.lastModified[i] && M.setRequestHeader("If-Modified-Since", x.lastModified[i]), 
x.etag[i] && M.setRequestHeader("If-None-Match", x.etag[i])), (p.data && p.hasContent && !1 !== p.contentType || n.contentType) && M.setRequestHeader("Content-Type", p.contentType), 
M.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + It + "; q=0.01" : "") : p.accepts["*"]), 
p.headers) M.setRequestHeader(h, p.headers[h]);
if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || l)) return M.abort();
if (_ = "abort", y.add(p.complete), M.done(p.success), M.fail(p.error), r = Ut(Nt, p, n, M)) {
if (M.readyState = 1, u && m.trigger("ajaxSend", [ M, p ]), l) return M;
p.async && 0 < p.timeout && (s = e.setTimeout(function() {
M.abort("timeout");
}, p.timeout));
try {
l = !1, r.send(b, S);
} catch (t) {
if (l) throw t;
S(-1, t);
}
} else S(-1, "No Transport");
function S(t, n, o, c) {
var h, d, g, b, w, _ = n;
l || (l = !0, s && e.clearTimeout(s), r = void 0, a = c || "", M.readyState = 0 < t ? 4 : 0, 
h = 200 <= t && t < 300 || 304 === t, o && (b = function(e, t, n) {
for (var r, i, a, o, s = e.contents, c = e.dataTypes; "*" === c[0]; ) c.shift(), 
void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
if (r) for (i in s) if (s[i] && s[i].test(r)) {
c.unshift(i);
break;
}
if (c[0] in n) a = c[0]; else {
for (i in n) {
if (!c[0] || e.converters[i + " " + c[0]]) {
a = i;
break;
}
o || (o = i);
}
a = a || o;
}
if (a) return a !== c[0] && c.unshift(a), n[a];
}(p, M, o)), !h && -1 < x.inArray("script", p.dataTypes) && x.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function() {}), 
b = function(e, t, n, r) {
var i, a, o, s, c, l = {}, u = e.dataTypes.slice();
if (u[1]) for (o in e.converters) l[o.toLowerCase()] = e.converters[o];
for (a = u.shift(); a; ) if (e.responseFields[a] && (n[e.responseFields[a]] = t), 
!c && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), c = a, a = u.shift()) if ("*" === a) a = c; else if ("*" !== c && c !== a) {
if (!(o = l[c + " " + a] || l["* " + a])) for (i in l) if ((s = i.split(" "))[1] === a && (o = l[c + " " + s[0]] || l["* " + s[0]])) {
!0 === o ? o = l[i] : !0 !== l[i] && (a = s[0], u.unshift(s[1]));
break;
}
if (!0 !== o) if (o && e.throws) t = o(t); else try {
t = o(t);
} catch (e) {
return {
state: "parsererror",
error: o ? e : "No conversion from " + c + " to " + a
};
}
}
return {
state: "success",
data: t
};
}(p, b, M, h), h ? (p.ifModified && ((w = M.getResponseHeader("Last-Modified")) && (x.lastModified[i] = w), 
(w = M.getResponseHeader("etag")) && (x.etag[i] = w)), 204 === t || "HEAD" === p.type ? _ = "nocontent" : 304 === t ? _ = "notmodified" : (_ = b.state, 
d = b.data, h = !(g = b.error))) : (g = _, !t && _ || (_ = "error", t < 0 && (t = 0))), 
M.status = t, M.statusText = (n || _) + "", h ? v.resolveWith(f, [ d, _, M ]) : v.rejectWith(f, [ M, _, g ]), 
M.statusCode($), $ = void 0, u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [ M, p, h ? d : g ]), 
y.fireWith(f, [ M, _ ]), u && (m.trigger("ajaxComplete", [ M, p ]), --x.active || x.event.trigger("ajaxStop")));
}
return M;
},
getJSON: function(e, t, n) {
return x.get(e, t, n, "json");
},
getScript: function(e, t) {
return x.get(e, void 0, t, "script");
}
}), x.each([ "get", "post" ], function(e, t) {
x[t] = function(e, n, r, i) {
return f(n) && (i = i || r, r = n, n = void 0), x.ajax(x.extend({
url: e,
type: t,
dataType: i,
data: n,
success: r
}, x.isPlainObject(e) && e));
};
}), x.ajaxPrefilter(function(e) {
var t;
for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "");
}), x._evalUrl = function(e, t, n) {
return x.ajax({
url: e,
type: "GET",
dataType: "script",
cache: !0,
async: !1,
global: !1,
converters: {
"text script": function() {}
},
dataFilter: function(e) {
x.globalEval(e, t, n);
}
});
}, x.fn.extend({
wrapAll: function(e) {
var t;
return this[0] && (f(e) && (e = e.call(this[0])), t = x(e, this[0].ownerDocument).eq(0).clone(!0), 
this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
for (var e = this; e.firstElementChild; ) e = e.firstElementChild;
return e;
}).append(this)), this;
},
wrapInner: function(e) {
return f(e) ? this.each(function(t) {
x(this).wrapInner(e.call(this, t));
}) : this.each(function() {
var t = x(this), n = t.contents();
n.length ? n.wrapAll(e) : t.append(e);
});
},
wrap: function(e) {
var t = f(e);
return this.each(function(n) {
x(this).wrapAll(t ? e.call(this, n) : e);
});
},
unwrap: function(e) {
return this.parent(e).not("body").each(function() {
x(this).replaceWith(this.childNodes);
}), this;
}
}), x.expr.pseudos.hidden = function(e) {
return !x.expr.pseudos.visible(e);
}, x.expr.pseudos.visible = function(e) {
return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
}, x.ajaxSettings.xhr = function() {
try {
return new e.XMLHttpRequest();
} catch (e) {}
};
var zt = {
0: 200,
1223: 204
}, Ft = x.ajaxSettings.xhr();
p.cors = !!Ft && "withCredentials" in Ft, p.ajax = Ft = !!Ft, x.ajaxTransport(function(t) {
var n, r;
if (p.cors || Ft && !t.crossDomain) return {
send: function(i, a) {
var o, s = t.xhr();
if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (o in t.xhrFields) s[o] = t.xhrFields[o];
for (o in t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"), 
i) s.setRequestHeader(o, i[o]);
n = function(e) {
return function() {
n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, 
"abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? a(0, "error") : a(s.status, s.statusText) : a(zt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
binary: s.response
} : {
text: s.responseText
}, s.getAllResponseHeaders()));
};
}, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function() {
4 === s.readyState && e.setTimeout(function() {
n && r();
});
}, n = n("abort");
try {
s.send(t.hasContent && t.data || null);
} catch (i) {
if (n) throw i;
}
},
abort: function() {
n && n();
}
};
}), x.ajaxPrefilter(function(e) {
e.crossDomain && (e.contents.script = !1);
}), x.ajaxSetup({
accepts: {
script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
},
contents: {
script: /\b(?:java|ecma)script\b/
},
converters: {
"text script": function(e) {
return x.globalEval(e), e;
}
}
}), x.ajaxPrefilter("script", function(e) {
void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
}), x.ajaxTransport("script", function(e) {
var t, n;
if (e.crossDomain || e.scriptAttrs) return {
send: function(r, i) {
t = x("<script>").attr(e.scriptAttrs || {}).prop({
charset: e.scriptCharset,
src: e.url
}).on("load error", n = function(e) {
t.remove(), n = null, e && i("error" === e.type ? 404 : 200, e.type);
}), g.head.appendChild(t[0]);
},
abort: function() {
n && n();
}
};
});
var Gt, Vt = [], Wt = /(=)\?(?=&|$)|\?\?/;
x.ajaxSetup({
jsonp: "callback",
jsonpCallback: function() {
var e = Vt.pop() || x.expando + "_" + xt.guid++;
return this[e] = !0, e;
}
}), x.ajaxPrefilter("json jsonp", function(t, n, r) {
var i, a, o, s = !1 !== t.jsonp && (Wt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Wt.test(t.data) && "data");
if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = f(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, 
s ? t[s] = t[s].replace(Wt, "$1" + i) : !1 !== t.jsonp && (t.url += (wt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), 
t.converters["script json"] = function() {
return o || x.error(i + " was not called"), o[0];
}, t.dataTypes[0] = "json", a = e[i], e[i] = function() {
o = arguments;
}, r.always(function() {
void 0 === a ? x(e).removeProp(i) : e[i] = a, t[i] && (t.jsonpCallback = n.jsonpCallback, 
Vt.push(i)), o && f(a) && a(o[0]), o = a = void 0;
}), "script";
}), p.createHTMLDocument = ((Gt = g.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 
2 === Gt.childNodes.length), x.parseHTML = function(e, t, n) {
return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (p.createHTMLDocument ? ((r = (t = g.implementation.createHTMLDocument("")).createElement("base")).href = g.location.href, 
t.head.appendChild(r)) : t = g), a = !n && [], (i = L.exec(e)) ? [ t.createElement(i[1]) ] : (i = $e([ e ], t, a), 
a && a.length && x(a).remove(), x.merge([], i.childNodes)));
var r, i, a;
}, x.fn.load = function(e, t, n) {
var r, i, a, o = this, s = e.indexOf(" ");
return -1 < s && (r = ft(e.slice(s)), e = e.slice(0, s)), f(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 
0 < o.length && x.ajax({
url: e,
type: i || "GET",
dataType: "html",
data: t
}).done(function(e) {
a = arguments, o.html(r ? x("<div>").append(x.parseHTML(e)).find(r) : e);
}).always(n && function(e, t) {
o.each(function() {
n.apply(this, a || [ e.responseText, t, e ]);
});
}), this;
}, x.expr.pseudos.animated = function(e) {
return x.grep(x.timers, function(t) {
return e === t.elem;
}).length;
}, x.offset = {
setOffset: function(e, t, n) {
var r, i, a, o, s, c, l = x.css(e, "position"), u = x(e), h = {};
"static" === l && (e.style.position = "relative"), s = u.offset(), a = x.css(e, "top"), 
c = x.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (a + c).indexOf("auto") ? (o = (r = u.position()).top, 
i = r.left) : (o = parseFloat(a) || 0, i = parseFloat(c) || 0), f(t) && (t = t.call(e, n, x.extend({}, s))), 
null != t.top && (h.top = t.top - s.top + o), null != t.left && (h.left = t.left - s.left + i), 
"using" in t ? t.using.call(e, h) : u.css(h);
}
}, x.fn.extend({
offset: function(e) {
if (arguments.length) return void 0 === e ? this : this.each(function(t) {
x.offset.setOffset(this, e, t);
});
var t, n, r = this[0];
return r ? r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, 
{
top: t.top + n.pageYOffset,
left: t.left + n.pageXOffset
}) : {
top: 0,
left: 0
} : void 0;
},
position: function() {
if (this[0]) {
var e, t, n, r = this[0], i = {
top: 0,
left: 0
};
if ("fixed" === x.css(r, "position")) t = r.getBoundingClientRect(); else {
for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === x.css(e, "position"); ) e = e.parentNode;
e && e !== r && 1 === e.nodeType && ((i = x(e).offset()).top += x.css(e, "borderTopWidth", !0), 
i.left += x.css(e, "borderLeftWidth", !0));
}
return {
top: t.top - i.top - x.css(r, "marginTop", !0),
left: t.left - i.left - x.css(r, "marginLeft", !0)
};
}
},
offsetParent: function() {
return this.map(function() {
for (var e = this.offsetParent; e && "static" === x.css(e, "position"); ) e = e.offsetParent;
return e || re;
});
}
}), x.each({
scrollLeft: "pageXOffset",
scrollTop: "pageYOffset"
}, function(e, t) {
var n = "pageYOffset" === t;
x.fn[e] = function(r) {
return F(this, function(e, r, i) {
var a;
if (m(e) ? a = e : 9 === e.nodeType && (a = e.defaultView), void 0 === i) return a ? a[t] : e[r];
a ? a.scrollTo(n ? a.pageXOffset : i, n ? i : a.pageYOffset) : e[r] = i;
}, e, r, arguments.length);
};
}), x.each([ "top", "left" ], function(e, t) {
x.cssHooks[t] = Be(p.pixelPosition, function(e, n) {
if (n) return n = Ue(e, t), Ne.test(n) ? x(e).position()[t] + "px" : n;
});
}), x.each({
Height: "height",
Width: "width"
}, function(e, t) {
x.each({
padding: "inner" + e,
content: t,
"": "outer" + e
}, function(n, r) {
x.fn[r] = function(i, a) {
var o = arguments.length && (n || "boolean" != typeof i), s = n || (!0 === i || !0 === a ? "margin" : "border");
return F(this, function(t, n, i) {
var a;
return m(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (a = t.documentElement, 
Math.max(t.body["scroll" + e], a["scroll" + e], t.body["offset" + e], a["offset" + e], a["client" + e])) : void 0 === i ? x.css(t, n, s) : x.style(t, n, i, s);
}, t, o ? i : void 0, o);
};
});
}), x.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(e, t) {
x.fn[t] = function(e) {
return this.on(t, e);
};
}), x.fn.extend({
bind: function(e, t, n) {
return this.on(e, null, t, n);
},
unbind: function(e, t) {
return this.off(e, null, t);
},
delegate: function(e, t, n, r) {
return this.on(t, e, n, r);
},
undelegate: function(e, t, n) {
return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
},
hover: function(e, t) {
return this.mouseenter(e).mouseleave(t || e);
}
}), x.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, t) {
x.fn[t] = function(e, n) {
return 0 < arguments.length ? this.on(t, null, e, n) : this.trigger(t);
};
});
var qt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
x.proxy = function(e, t) {
var n, r, a;
if ("string" == typeof t && (n = e[t], t = e, e = n), f(e)) return r = i.call(arguments, 2), 
(a = function() {
return e.apply(t || this, r.concat(i.call(arguments)));
}).guid = e.guid = e.guid || x.guid++, a;
}, x.holdReady = function(e) {
e ? x.readyWait++ : x.ready(!0);
}, x.isArray = Array.isArray, x.parseJSON = JSON.parse, x.nodeName = T, x.isFunction = f, 
x.isWindow = m, x.camelCase = q, x.type = $, x.now = Date.now, x.isNumeric = function(e) {
var t = x.type(e);
return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
}, x.trim = function(e) {
return null == e ? "" : (e + "").replace(qt, "");
}, "function" == typeof define && define.amd && define("jquery", [], function() {
return x;
});
var Ht = e.jQuery, Xt = e.$;
return x.noConflict = function(t) {
return e.$ === x && (e.$ = Xt), t && e.jQuery === x && (e.jQuery = Ht), x;
}, void 0 === t && (e.jQuery = e.$ = x), x;
}), function(e, t) {
var n, r;
"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self, 
n = e.Cookies, (r = e.Cookies = t()).noConflict = function() {
return e.Cookies = n, r;
});
}(this, function() {
"use strict";
function e(e) {
for (var t = 1; t < arguments.length; t++) {
var n = arguments[t];
for (var r in n) e[r] = n[r];
}
return e;
}
var t = {
read: function(e) {
return e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
},
write: function(e) {
return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
}
};
return function n(r, i) {
function a(t, n, a) {
if ("undefined" != typeof document) {
"number" == typeof (a = e({}, i, a)).expires && (a.expires = new Date(Date.now() + 864e5 * a.expires)), 
a.expires && (a.expires = a.expires.toUTCString()), t = encodeURIComponent(t).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape), 
n = r.write(n, t);
var o = "";
for (var s in a) a[s] && (o += "; " + s, !0 !== a[s] && (o += "=" + a[s].split(";")[0]));
return document.cookie = t + "=" + n + o;
}
}
return Object.create({
set: a,
get: function(e) {
if ("undefined" != typeof document && (!arguments.length || e)) {
for (var n = document.cookie ? document.cookie.split("; ") : [], i = {}, a = 0; a < n.length; a++) {
var o = n[a].split("="), s = o.slice(1).join("=");
'"' === s[0] && (s = s.slice(1, -1));
try {
var c = t.read(o[0]);
if (i[c] = r.read(s, c), e === c) break;
} catch (e) {}
}
return e ? i[e] : i;
}
},
remove: function(t, n) {
a(t, "", e({}, n, {
expires: -1
}));
},
withAttributes: function(t) {
return n(this.converter, e({}, this.attributes, t));
},
withConverter: function(t) {
return n(e({}, this.converter, t), this.attributes);
}
}, {
attributes: {
value: Object.freeze(i)
},
converter: {
value: Object.freeze(r)
}
});
}(t, {
path: "/"
});
}), function(e, t) {
"object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define([ "exports" ], t) : t((e = e || self).$3 = {});
}(this, function(e) {
function t() {}
function n(e, t) {
this.x = e || 0, this.y = t || 0;
}
function r() {
this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], 0 < arguments.length && console.error("$3.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
function i(e, t, a, o, s, c, l, u, h, d) {
Object.defineProperty(this, "id", {
value: ma++
}), this.uuid = da.generateUUID(), this.name = "", this.image = void 0 !== e ? e : i.DEFAULT_IMAGE, 
this.mipmaps = [], this.mapping = void 0 !== t ? t : i.DEFAULT_MAPPING, this.wrapS = void 0 !== a ? a : 1001, 
this.wrapT = void 0 !== o ? o : 1001, this.magFilter = void 0 !== s ? s : 1006, 
this.minFilter = void 0 !== c ? c : 1008, this.anisotropy = void 0 !== h ? h : 1, 
this.format = void 0 !== l ? l : 1023, this.internalFormat = null, this.type = void 0 !== u ? u : 1009, 
this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), 
this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new r(), this.generateMipmaps = !0, 
this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, 
this.version = 0, this.onUpdate = null;
}
function a(e, t, n, r) {
this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1;
}
function o(e, t, n) {
this.width = e, this.height = t, this.scissor = new a(0, 0, e, t), this.scissorTest = !1, 
this.viewport = new a(0, 0, e, t), n = n || {}, this.texture = new i(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), 
this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, 
this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, 
this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, 
this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null;
}
function s(e, t, n) {
o.call(this, e, t, n), this.samples = 4;
}
function c(e, t, n, r) {
this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1;
}
function l(e, t, n) {
this.x = e || 0, this.y = t || 0, this.z = n || 0;
}
function u() {
this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], 0 < arguments.length && console.error("$3.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
function h(e, t, n, r) {
this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || h.DefaultOrder;
}
function d() {
this.mask = 1;
}
function p() {
Object.defineProperty(this, "id", {
value: Ta++
}), this.uuid = da.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, 
this.children = [], this.up = p.DefaultUp.clone();
var e = new l(), t = new h(), n = new c(), i = new l(1, 1, 1);
t._onChange(function() {
n.setFromEuler(t, !1);
}), n._onChange(function() {
t.setFromQuaternion(n, void 0, !1);
}), Object.defineProperties(this, {
position: {
configurable: !0,
enumerable: !0,
value: e
},
rotation: {
configurable: !0,
enumerable: !0,
value: t
},
quaternion: {
configurable: !0,
enumerable: !0,
value: n
},
scale: {
configurable: !0,
enumerable: !0,
value: i
},
modelViewMatrix: {
value: new u()
},
normalMatrix: {
value: new r()
}
}), this.matrix = new u(), this.matrixWorld = new u(), this.matrixAutoUpdate = p.DefaultMatrixAutoUpdate, 
this.matrixWorldNeedsUpdate = !1, this.layers = new d(), this.visible = !0, this.receiveShadow = this.castShadow = !1, 
this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}
function f() {
p.call(this), this.type = "Scene", this.overrideMtrl = this.fog = this.environment = this.background = null, 
this.autoUpdate = !0, "undefined" != typeof __$3_DEVTOOLS__ && __$3_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
detail: this
}));
}
function m(e, t) {
this.min = void 0 !== e ? e : new l(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new l(-1 / 0, -1 / 0, -1 / 0);
}
function g(e, t, n, r, i) {
for (var a = 0, o = e.length - 3; a <= o; a += 3) {
Ka.fromArray(e, a);
var s = i.x * Math.abs(Ka.x) + i.y * Math.abs(Ka.y) + i.z * Math.abs(Ka.z), c = t.dot(Ka), l = n.dot(Ka), u = r.dot(Ka);
if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > s) return !1;
}
return !0;
}
function v(e, t) {
this.center = void 0 !== e ? e : new l(), this.radius = void 0 !== t ? t : -1;
}
function y(e, t) {
this.origin = void 0 !== e ? e : new l(), this.direction = void 0 !== t ? t : new l(0, 0, -1);
}
function $(e, t) {
this.normal = void 0 !== e ? e : new l(1, 0, 0), this.constant = void 0 !== t ? t : 0;
}
function b(e, t, n) {
this.a = void 0 !== e ? e : new l(), this.b = void 0 !== t ? t : new l(), this.c = void 0 !== n ? n : new l();
}
function x(e, t, n) {
return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
}
function w(e, t, n) {
return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : .5 > n ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
}
function _(e) {
return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
}
function M(e) {
return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
}
function S(e, t, n, r, i, a) {
this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new l(), 
this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new x(), 
this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== a ? a : 0;
}
function A() {
Object.defineProperty(this, "id", {
value: Mo++
}), this.uuid = da.generateUUID(), this.name = "", this.type = "Mtrl", this.fog = !0, 
this.blending = 1, this.side = 0, this.vertexColors = this.flatShading = !1, this.opacity = 1, 
this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, 
this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, 
this.depthWrite = this.depthTest = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, 
this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilZPass = this.stencilZFail = this.stencilFail = 7680, 
this.stencilWrite = !1, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, 
this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, 
this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, 
this.premultipliedAlpha = !1, this.toneMapped = this.visible = !0, this.userData = {}, 
this.version = 0;
}
function T(e) {
A.call(this), this.type = "MeshBasicMtrl", this.color = new x(16777215), this.lightMap = this.map = null, 
this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, 
this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
this.morphTargets = this.skinning = !1, this.setValues(e);
}
function L(e, t, n) {
if (Array.isArray(e)) throw new TypeError("$3.BufferAttribute: array should be a Typed Array.");
this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, 
this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
offset: 0,
count: -1
}, this.version = 0;
}
function C(e, t, n) {
L.call(this, new Int8Array(e), t, n);
}
function E(e, t, n) {
L.call(this, new Uint8Array(e), t, n);
}
function P(e, t, n) {
L.call(this, new Uint8ClampedArray(e), t, n);
}
function k(e, t, n) {
L.call(this, new Int16Array(e), t, n);
}
function O(e, t, n) {
L.call(this, new Uint16Array(e), t, n);
}
function D(e, t, n) {
L.call(this, new Int32Array(e), t, n);
}
function N(e, t, n) {
L.call(this, new Uint32Array(e), t, n);
}
function I(e, t, n) {
L.call(this, new Float32Array(e), t, n);
}
function R(e, t, n) {
L.call(this, new Float64Array(e), t, n);
}
function j() {
this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], 
this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], 
this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
}
function U(e) {
if (0 === e.length) return -1 / 0;
for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
return t;
}
function B() {
Object.defineProperty(this, "id", {
value: Ao += 2
}), this.uuid = da.generateUUID(), this.name = "", this.type = "BufferGmtr", this.index = null, 
this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, 
this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
start: 0,
count: 1 / 0
}, this.userData = {};
}
function z(e, t) {
p.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new B(), this.material = void 0 !== t ? t : new T(), 
this.updateMorphTargets();
}
function F(e, t, n, r, i, a, o, s) {
return null === (1 === t.side ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, 2 !== t.side, s)) ? null : (Yo.copy(s), 
Yo.applyMatrix4(e.matrixWorld), (t = n.ray.origin.distanceTo(Yo)) < n.near || t > n.far ? null : {
distance: t,
point: Yo.clone(),
object: e
});
}
function G(e, t, r, i, a, o, s, c, l, u, h, d) {
if (Io.fromBufferAttribute(a, u), Ro.fromBufferAttribute(a, h), jo.fromBufferAttribute(a, d), 
a = e.morphTargetInfluences, t.morphTargets && o && a) {
Fo.set(0, 0, 0), Go.set(0, 0, 0), Vo.set(0, 0, 0);
for (var p = 0, f = o.length; p < f; p++) {
var m = a[p], g = o[p];
0 !== m && (Uo.fromBufferAttribute(g, u), Bo.fromBufferAttribute(g, h), zo.fromBufferAttribute(g, d), 
s ? (Fo.addScaledVector(Uo, m), Go.addScaledVector(Bo, m), Vo.addScaledVector(zo, m)) : (Fo.addScaledVector(Uo.sub(Io), m), 
Go.addScaledVector(Bo.sub(Ro), m), Vo.addScaledVector(zo.sub(jo), m)));
}
Io.add(Fo), Ro.add(Go), jo.add(Vo);
}
return e.isSkinnedMesh && (e.boneTransform(u, Io), e.boneTransform(h, Ro), e.boneTransform(d, jo)), 
(e = F(e, t, r, i, Io, Ro, jo, Xo)) && (c && (Wo.fromBufferAttribute(c, u), qo.fromBufferAttribute(c, h), 
Ho.fromBufferAttribute(c, d), e.uv = b.getUV(Xo, Io, Ro, jo, Wo, qo, Ho, new n())), 
l && (Wo.fromBufferAttribute(l, u), qo.fromBufferAttribute(l, h), Ho.fromBufferAttribute(l, d), 
e.uv2 = b.getUV(Xo, Io, Ro, jo, Wo, qo, Ho, new n())), c = new S(u, h, d), b.getNormal(Io, Ro, jo, c.normal), 
e.face = c), e;
}
function V() {
Object.defineProperty(this, "id", {
value: Jo += 2
}), this.uuid = da.generateUUID(), this.name = "", this.type = "Gmtr", this.vertices = [], 
this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], this.morphTargets = [], 
this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], 
this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
}
function W(e) {
var t, n = {};
for (t in e) for (var r in n[t] = {}, e[t]) {
var i = e[t][r];
i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? n[t][r] = i.clone() : Array.isArray(i) ? n[t][r] = i.slice() : n[t][r] = i;
}
return n;
}
function q(e) {
for (var t = {}, n = 0; n < e.length; n++) {
var r, i = W(e[n]);
for (r in i) t[r] = i[r];
}
return t;
}
function H(e) {
A.call(this), this.type = "ShaderMtrl", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, 
this.extensions = {
derivatives: !1,
fragDepth: !1,
drawBuffers: !1,
shaderTextureLOD: !1
}, this.defaultAttributeValues = {
color: [ 1, 1, 1 ],
uv: [ 0, 0 ],
uv2: [ 0, 0 ]
}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("$3.ShaderMtrl: attributes should now be defined in $3.BufferGmtr instead."), 
this.setValues(e));
}
function X() {
p.call(this), this.type = "Camera", this.matrixWorldInverse = new u(), this.projectionMatrix = new u(), 
this.projectionMatrixInverse = new u();
}
function Y(e, t, n, r) {
X.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, 
this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, 
this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, 
this.filmOffset = 0, this.updateProjectionMatrix();
}
function J(e, t, n) {
if (p.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) console.error("$3.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); else {
this.renderTarget = n;
var r = new Y(90, 1, e, t);
r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new l(1, 0, 0)), this.add(r);
var i = new Y(90, 1, e, t);
i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new l(-1, 0, 0)), this.add(i);
var a = new Y(90, 1, e, t);
a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new l(0, 1, 0)), this.add(a);
var o = new Y(90, 1, e, t);
o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new l(0, -1, 0)), this.add(o);
var s = new Y(90, 1, e, t);
s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new l(0, 0, 1)), this.add(s);
var c = new Y(90, 1, e, t);
c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new l(0, 0, -1)), this.add(c), 
this.update = function(e, t) {
null === this.parent && this.updateMatrixWorld();
var l = e.xr.enabled, u = e.getRenderTarget();
e.xr.enabled = !1;
var h = n.texture.generateMipmaps;
n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), 
e.render(t, i), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), 
e.render(t, o), e.setRenderTarget(n, 4), e.render(t, s), n.texture.generateMipmaps = h, 
e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(u), e.xr.enabled = l;
}, this.clear = function(e, t, r, i) {
for (var a = e.getRenderTarget(), o = 0; 6 > o; o++) e.setRenderTarget(n, o), e.clear(t, r, i);
e.setRenderTarget(a);
};
}
}
function Z(e, t, n) {
Number.isInteger(t) && (console.warn("$3.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), 
t = n), o.call(this, e, e, t);
}
function K(e, t, n, r, a, o, s, c, l, u, h, d) {
i.call(this, null, o, s, c, l, u, r, a, h, d), this.image = {
data: e || null,
width: t || 1,
height: n || 1
}, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== u ? u : 1003, 
this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}
function Q(e, t, n, r, i, a) {
this.planes = [ void 0 !== e ? e : new $(), void 0 !== t ? t : new $(), void 0 !== n ? n : new $(), void 0 !== r ? r : new $(), void 0 !== i ? i : new $(), void 0 !== a ? a : new $() ];
}
function ee() {
function e(i, a) {
!1 !== n && (r(i, a), t.requestAnimationFrame(e));
}
var t = null, n = !1, r = null;
return {
start: function() {
!0 !== n && null !== r && (t.requestAnimationFrame(e), n = !0);
},
stop: function() {
n = !1;
},
setAnimationLoop: function(e) {
r = e;
},
setContext: function(e) {
t = e;
}
};
}
function te(e, t) {
var n = t.isWebGL2, r = new WeakMap();
return {
get: function(e) {
return e.isInterleavedBufferAttribute && (e = e.data), r.get(e);
},
remove: function(t) {
t.isInterleavedBufferAttribute && (t = t.data);
var n = r.get(t);
n && (e.deleteBuffer(n.buffer), r.delete(t));
},
update: function(t, i) {
t.isInterleavedBufferAttribute && (t = t.data);
var a = r.get(t), o = t.updateRange;
if (void 0 === a) r.set(t, function(t, n) {
var r = t.array, i = t.usage, a = e.createBuffer();
return e.bindBuffer(n, a), e.bufferData(n, r, i), t.onUploadCallback(), n = 5126, 
r instanceof Float32Array ? n = 5126 : r instanceof Float64Array ? console.warn("$3.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? n = 5123 : r instanceof Int16Array ? n = 5122 : r instanceof Uint32Array ? n = 5125 : r instanceof Int32Array ? n = 5124 : r instanceof Int8Array ? n = 5120 : r instanceof Uint8Array && (n = 5121), 
{
buffer: a,
type: n,
bytesPerElement: r.BYTES_PER_ELEMENT,
version: t.version
};
}(t, i)), 35048 === t.usage && (o.offset = 0, o.count = -1); else if (a.version < t.version) {
var s = t.array;
e.bindBuffer(i, a.buffer), -1 === o.count ? e.bufferSubData(i, 0, s) : (n ? e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), 
o.offset = 0, o.count = -1), a.version = t.version;
}
}
};
}
function ne(e, t, n, r) {
V.call(this), this.type = "PlaneGmtr", this.parameters = {
width: e,
height: t,
widthSegments: n,
heightSegments: r
}, this.fromBufferGmtr(new re(e, t, n, r)), this.mergeVertices();
}
function re(e, t, n, r) {
B.call(this), this.type = "PlaneBufferGmtr", this.parameters = {
width: e,
height: t,
widthSegments: n,
heightSegments: r
};
var i = (e = e || 1) / 2, a = (t = t || 1) / 2, o = (n = Math.floor(n) || 1) + 1, s = (r = Math.floor(r) || 1) + 1, c = e / n, l = t / r;
t = [], e = [];
for (var u = [], h = [], d = 0; d < s; d++) for (var p = d * l - a, f = 0; f < o; f++) e.push(f * c - i, -p, 0), 
u.push(0, 0, 1), h.push(f / n), h.push(1 - d / r);
for (i = 0; i < r; i++) for (a = 0; a < n; a++) s = a + o * (i + 1), c = a + 1 + o * (i + 1), 
l = a + 1 + o * i, t.push(a + o * i, s, l), t.push(s, c, l);
this.setIndex(t), this.setAttribute("position", new I(e, 3)), this.setAttribute("normal", new I(u, 3)), 
this.setAttribute("uv", new I(h, 2));
}
function ie(e, t, n, r) {
function i(e, n) {
t.buffers.color.setClear(e.r, e.g, e.b, n, r);
}
var a, o, s = new x(0), c = 0, l = null, u = 0, h = null;
return {
getClearColor: function() {
return s;
},
setClearColor: function(e, t) {
s.set(e), i(s, c = void 0 !== t ? t : 1);
},
getClearAlpha: function() {
return c;
},
setClearAlpha: function(e) {
i(s, c = e);
},
render: function(t, r, d, p) {
r = r.background, (d = (d = e.xr).getSession && d.getSession()) && "additive" === d.environmentBlendMode && (r = null), 
null === r ? i(s, c) : r && r.isColor && (i(r, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), 
r && (r.isCubeTexture || r.isWebGLCubeRenderTarget || 306 === r.mapping) ? (void 0 === o && ((o = new z(new ts(1, 1, 1), new H({
type: "BackgroundCubeMtrl",
uniforms: W(ss.cube.uniforms),
vertexShader: ss.cube.vertexShader,
fragmentShader: ss.cube.fragmentShader,
side: 1,
depthTest: !1,
depthWrite: !1,
fog: !1
}))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function(e, t, n) {
this.matrixWorld.copyPosition(n.matrixWorld);
}, Object.defineProperty(o.material, "envMap", {
get: function() {
return this.uniforms.envMap.value;
}
}), n.update(o)), p = r.isWebGLCubeRenderTarget ? r.texture : r, o.material.uniforms.envMap.value = p, 
o.material.uniforms.flipEnvMap.value = p.isCubeTexture ? -1 : 1, l === r && u === p.version && h === e.toneMapping || (o.material.needsUpdate = !0, 
l = r, u = p.version, h = e.toneMapping), t.unshift(o, o.geometry, o.material, 0, 0, null)) : r && r.isTexture && (void 0 === a && ((a = new z(new re(2, 2), new H({
type: "BackgroundMtrl",
uniforms: W(ss.background.uniforms),
vertexShader: ss.background.vertexShader,
fragmentShader: ss.background.fragmentShader,
side: 0,
depthTest: !1,
depthWrite: !1,
fog: !1
}))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
get: function() {
return this.uniforms.t2D.value;
}
}), n.update(a)), a.material.uniforms.t2D.value = r, !0 === r.matrixAutoUpdate && r.updateMatrix(), 
a.material.uniforms.uvTransform.value.copy(r.matrix), l === r && u === r.version && h === e.toneMapping || (a.material.needsUpdate = !0, 
l = r, u = r.version, h = e.toneMapping), t.unshift(a, a.geometry, a.material, 0, 0, null));
}
};
}
function ae() {
function e() {
u.value !== i && (u.value = i, u.needsUpdate = 0 < a), n.numPlanes = a, n.numIntersection = 0;
}
function t(e, t, r, i) {
var a = null !== e ? e.length : 0, o = null;
if (0 !== a) {
if (o = u.value, !0 !== i || null === o) for (i = r + 4 * a, t = t.matrixWorldInverse, 
l.getNormalMatrix(t), (null === o || o.length < i) && (o = new Float32Array(i)), 
i = 0; i !== a; ++i, r += 4) c.copy(e[i]).applyMatrix4(t, l), c.normal.toArray(o, r), 
o[r + 3] = c.constant;
u.value = o, u.needsUpdate = !0;
}
return n.numPlanes = a, n.numIntersection = 0, o;
}
var n = this, i = null, a = 0, o = !1, s = !1, c = new $(), l = new r(), u = {
value: null,
needsUpdate: !1
};
this.uniform = u, this.numIntersection = this.numPlanes = 0, this.init = function(e, n, r) {
var s = 0 !== e.length || n || 0 !== a || o;
return o = n, i = t(e, r, 0), a = e.length, s;
}, this.beginShadows = function() {
s = !0, t(null);
}, this.endShadows = function() {
s = !1, e();
}, this.setState = function(n, r, c, l, h, d) {
if (!o || null === n || 0 === n.length || s && !c) s ? t(null) : e(); else {
var p = 4 * (c = s ? 0 : a), f = h.clippingState || null;
for (u.value = f, f = t(n, l, p, d), n = 0; n !== p; ++n) f[n] = i[n];
h.clippingState = f, this.numIntersection = r ? this.numPlanes : 0, this.numPlanes += c;
}
};
}
function oe(e, t, n) {
function r(e) {
var i = e.target;
for (var s in null !== (e = a.get(i)).index && t.remove(e.index), e.attributes) t.remove(e.attributes[s]);
i.removeEventListener("dispose", r), a.delete(i), (s = o.get(e)) && (t.remove(s), 
o.delete(e)), n.memory.geometries--;
}
function i(e) {
var n = [], r = e.index, i = e.attributes.position;
if (null !== r) {
i = r.array, r = r.version;
for (var a = 0, s = i.length; a < s; a += 3) {
var c = i[a + 0], l = i[a + 1], u = i[a + 2];
n.push(c, l, l, u, u, c);
}
} else for (a = i.array, r = i.version, i = 0, a = a.length / 3 - 1; i < a; i += 3) s = i + 0, 
c = i + 1, l = i + 2, n.push(s, c, c, l, l, s);
(n = new (65535 < U(n) ? N : O)(n, 1)).version = r, t.update(n, 34963), (r = o.get(e)) && t.remove(r), 
o.set(e, n);
}
var a = new WeakMap(), o = new WeakMap();
return {
get: function(e, t) {
var i = a.get(t);
return i || (t.addEventListener("dispose", r), t.isBufferGmtr ? i = t : t.isGmtr && (void 0 === t._bufferGmtr && (t._bufferGmtr = new B().setFromObject(e)), 
i = t._bufferGmtr), a.set(t, i), n.memory.geometries++, i);
},
update: function(e) {
var n = e.index, r = e.attributes;
for (var i in null !== n && t.update(n, 34963), r) t.update(r[i], 34962);
for (var a in e = e.morphAttributes) for (r = 0, i = (n = e[a]).length; r < i; r++) t.update(n[r], 34962);
},
getWireframeAttribute: function(e) {
var t = o.get(e);
if (t) {
var n = e.index;
null !== n && t.version < n.version && i(e);
} else i(e);
return o.get(e);
}
};
}
function se(e, t) {
return Math.abs(t[1]) - Math.abs(e[1]);
}
function ce(e, t, n, r, a, o, s, c, l, u) {
e = void 0 !== e ? e : [], i.call(this, e, void 0 !== t ? t : 301, n, r, a, o, void 0 !== s ? s : 1022, c, l, u), 
this.flipY = !1;
}
function le(e, t, n, r) {
i.call(this, null), this.image = {
data: e || null,
width: t || 1,
height: n || 1,
depth: r || 1
}, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, 
this.needsUpdate = !0;
}
function ue(e, t, n, r) {
i.call(this, null), this.image = {
data: e || null,
width: t || 1,
height: n || 1,
depth: r || 1
}, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, 
this.needsUpdate = !0;
}
function he(e, t, n) {
var r = e[0];
if (0 >= r || 0 < r) return e;
var i = t * n, a = ds[i];
if (void 0 === a && (a = new Float32Array(i), ds[i] = a), 0 !== t) for (r.toArray(a, 0), 
r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(a, i);
return a;
}
function de(e, t) {
if (e.length !== t.length) return !1;
for (var n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1;
return !0;
}
function pe(e, t) {
for (var n = 0, r = t.length; n < r; n++) e[n] = t[n];
}
function fe(e, t) {
var n = ps[t];
void 0 === n && (n = new Int32Array(t), ps[t] = n);
for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
return n;
}
function me(e, t) {
var n = this.cache;
n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t);
}
function ge(e, t) {
var n = this.cache;
void 0 !== t.x ? n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), 
n[0] = t.x, n[1] = t.y) : de(n, t) || (e.uniform2fv(this.addr, t), pe(n, t));
}
function ve(e, t) {
var n = this.cache;
void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), 
n[0] = t.x, n[1] = t.y, n[2] = t.z) : void 0 !== t.r ? n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), 
n[0] = t.r, n[1] = t.g, n[2] = t.b) : de(n, t) || (e.uniform3fv(this.addr, t), pe(n, t));
}
function ye(e, t) {
var n = this.cache;
void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), 
n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w) : de(n, t) || (e.uniform4fv(this.addr, t), 
pe(n, t));
}
function $e(e, t) {
var n = this.cache, r = t.elements;
void 0 === r ? de(n, t) || (e.uniformMatrix2fv(this.addr, !1, t), pe(n, t)) : de(n, r) || (gs.set(r), 
e.uniformMatrix2fv(this.addr, !1, gs), pe(n, r));
}
function be(e, t) {
var n = this.cache, r = t.elements;
void 0 === r ? de(n, t) || (e.uniformMatrix3fv(this.addr, !1, t), pe(n, t)) : de(n, r) || (ms.set(r), 
e.uniformMatrix3fv(this.addr, !1, ms), pe(n, r));
}
function xe(e, t) {
var n = this.cache, r = t.elements;
void 0 === r ? de(n, t) || (e.uniformMatrix4fv(this.addr, !1, t), pe(n, t)) : de(n, r) || (fs.set(r), 
e.uniformMatrix4fv(this.addr, !1, fs), pe(n, r));
}
function we(e, t, n) {
var r = this.cache, i = n.allocateTextureUnit();
r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || cs, i);
}
function _e(e, t, n) {
var r = this.cache, i = n.allocateTextureUnit();
r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || ls, i);
}
function Me(e, t, n) {
var r = this.cache, i = n.allocateTextureUnit();
r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || us, i);
}
function Se(e, t, n) {
var r = this.cache, i = n.allocateTextureUnit();
r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || hs, i);
}
function Ae(e, t) {
var n = this.cache;
n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t);
}
function Te(e, t) {
var n = this.cache;
de(n, t) || (e.uniform2iv(this.addr, t), pe(n, t));
}
function Le(e, t) {
var n = this.cache;
de(n, t) || (e.uniform3iv(this.addr, t), pe(n, t));
}
function Ce(e, t) {
var n = this.cache;
de(n, t) || (e.uniform4iv(this.addr, t), pe(n, t));
}
function Ee(e, t) {
var n = this.cache;
n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t);
}
function Pe(e, t) {
e.uniform1fv(this.addr, t);
}
function ke(e, t) {
e.uniform1iv(this.addr, t);
}
function Oe(e, t) {
e.uniform2iv(this.addr, t);
}
function De(e, t) {
e.uniform3iv(this.addr, t);
}
function Ne(e, t) {
e.uniform4iv(this.addr, t);
}
function Ie(e, t) {
t = he(t, this.size, 2), e.uniform2fv(this.addr, t);
}
function Re(e, t) {
t = he(t, this.size, 3), e.uniform3fv(this.addr, t);
}
function je(e, t) {
t = he(t, this.size, 4), e.uniform4fv(this.addr, t);
}
function Ue(e, t) {
t = he(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t);
}
function Be(e, t) {
t = he(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t);
}
function ze(e, t) {
t = he(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t);
}
function Fe(e, t, n) {
var r = t.length, i = fe(n, r);
for (e.uniform1iv(this.addr, i), e = 0; e !== r; ++e) n.safeSetTexture2D(t[e] || cs, i[e]);
}
function Ge(e, t, n) {
var r = t.length, i = fe(n, r);
for (e.uniform1iv(this.addr, i), e = 0; e !== r; ++e) n.safeSetTextureCube(t[e] || hs, i[e]);
}
function Ve(e, t, n) {
this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
switch (e) {
case 5126:
return me;

case 35664:
return ge;

case 35665:
return ve;

case 35666:
return ye;

case 35674:
return $e;

case 35675:
return be;

case 35676:
return xe;

case 5124:
case 35670:
return Ae;

case 35667:
case 35671:
return Te;

case 35668:
case 35672:
return Le;

case 35669:
case 35673:
return Ce;

case 5125:
return Ee;

case 35678:
case 36198:
case 36298:
case 36306:
case 35682:
return we;

case 35679:
case 36299:
case 36307:
return Me;

case 35680:
case 36300:
case 36308:
case 36293:
return Se;

case 36289:
case 36303:
case 36311:
case 36292:
return _e;
}
}(t.type);
}
function We(e, t, n) {
this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
switch (e) {
case 5126:
return Pe;

case 35664:
return Ie;

case 35665:
return Re;

case 35666:
return je;

case 35674:
return Ue;

case 35675:
return Be;

case 35676:
return ze;

case 5124:
case 35670:
return ke;

case 35667:
case 35671:
return Oe;

case 35668:
case 35672:
return De;

case 35669:
case 35673:
return Ne;

case 35678:
case 36198:
case 36298:
case 36306:
case 35682:
return Fe;

case 35680:
case 36300:
case 36308:
case 36293:
return Ge;
}
}(t.type);
}
function qe(e) {
this.id = e, this.seq = [], this.map = {};
}
function He(e, t) {
this.seq = [], this.map = {};
for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
var i = e.getActiveUniform(t, r), a = e.getUniformLocation(t, i.name), o = this, s = i.name, c = s.length;
for (vs.lastIndex = 0; ;) {
var l = vs.exec(s), u = vs.lastIndex, h = l[1], d = l[3];
if ("]" === l[2] && (h |= 0), void 0 === d || "[" === d && u + 2 === c) {
s = o, i = void 0 === d ? new Ve(h, i, a) : new We(h, i, a), s.seq.push(i), s.map[i.id] = i;
break;
}
void 0 === (d = o.map[h]) && (d = new qe(h), h = o, o = d, h.seq.push(o), h.map[o.id] = o), 
o = d;
}
}
}
function Xe(e, t, n) {
return t = e.createShader(t), e.shaderSource(t, n), e.compileShader(t), t;
}
function Ye(e) {
switch (e) {
case 3e3:
return [ "Linear", "( value )" ];

case 3001:
return [ "sRGB", "( value )" ];

case 3002:
return [ "RGBE", "( value )" ];

case 3004:
return [ "RGBM", "( value, 7.0 )" ];

case 3005:
return [ "RGBM", "( value, 16.0 )" ];

case 3006:
return [ "RGBD", "( value, 256.0 )" ];

case 3007:
return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

case 3003:
return [ "LogLuv", "( value )" ];

default:
throw Error("unsupported encoding: " + e);
}
}
function Je(e, t, n) {
var r = e.getShaderParameter(t, 35713), i = e.getShaderInfoLog(t).trim();
if (r && "" === i) return "";
for (e = e.getShaderSource(t).split("\n"), t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
return "$3.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + (e = e.join("\n"));
}
function Ze(e, t) {
return "vec4 " + e + "( vec4 value ) { return " + (t = Ye(t))[0] + "ToLinear" + t[1] + "; }";
}
function Ke(e) {
return "" !== e;
}
function Qe(e, t) {
return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function et(e, t) {
return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
function tt(e, t) {
if (void 0 === (e = os[t])) throw Error("Can not resolve #include <" + t + ">");
return e.replace($s, tt);
}
function nt(e, t, n, r) {
return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), 
rt(e, t, n, r);
}
function rt(e, t, n, r) {
for (e = "", t = parseInt(t); t < parseInt(n); t++) e += r.replace(/\[ i \]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
return e;
}
function it(e) {
var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), 
t;
}
function at(e, t, n) {
var r, i, a = e.getContext(), o = n.defines, s = n.vertexShader, c = n.fragmentShader, l = function(e) {
var t = "SHADOWMAP_TYPE_BASIC";
return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), 
t;
}(n), u = function(e) {
var t = "ENVMAP_TYPE_CUBE";
if (e.envMap) switch (e.envMapMode) {
case 301:
case 302:
t = "ENVMAP_TYPE_CUBE";
break;

case 306:
case 307:
t = "ENVMAP_TYPE_CUBE_UV";
break;

case 303:
case 304:
t = "ENVMAP_TYPE_EQUIREC";
}
return t;
}(n), h = function(e) {
var t = "ENVMAP_MODE_REFLECTION";
if (e.envMap) switch (e.envMapMode) {
case 302:
case 304:
t = "ENVMAP_MODE_REFRACTION";
}
return t;
}(n), d = function(e) {
var t = "ENVMAP_BLENDING_NONE";
if (e.envMap) switch (e.combine) {
case 0:
t = "ENVMAP_BLENDING_MULTIPLY";
break;

case 1:
t = "ENVMAP_BLENDING_MIX";
break;

case 2:
t = "ENVMAP_BLENDING_ADD";
}
return t;
}(n), p = 0 < e.gammaFactor ? e.gammaFactor : 1, f = n.isWebGL2 ? "" : [ n.extensionDerivatives || n.envMapCubeUV || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || "physical" === n.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : "" ].filter(Ke).join("\n"), m = function(e) {
var t, n = [];
for (t in e) {
var r = e[t];
!1 !== r && n.push("#define " + t + " " + r);
}
return n.join("\n");
}(o), g = a.createProgram();
return n.isRawShaderMtrl ? (0 < (o = [ m ].filter(Ke).join("\n")).length && (o += "\n"), 
0 < (l = [ f, m ].filter(Ke).join("\n")).length && (l += "\n")) : (o = [ it(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(Ke).join("\n"), 
l = [ f, it(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? os.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? function(e, t) {
switch (t) {
case 1:
t = "Linear";
break;

case 2:
t = "Reinhard";
break;

case 3:
t = "Uncharted2";
break;

case 4:
t = "OptimizedCineon";
break;

case 5:
t = "ACESFilmic";
break;

default:
throw Error("unsupported toneMapping: " + t);
}
return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? os.encodings_pars_fragment : "", n.mapEncoding ? Ze("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Ze("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Ze("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Ze("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Ze("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? function(e, t) {
return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = Ye(t))[0] + t[1] + "; }";
}("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n" ].filter(Ke).join("\n")), 
s = et(s = Qe(s = s.replace($s, tt), n), n), c = et(c = Qe(c = c.replace($s, tt), n), n), 
s = s.replace(xs, rt).replace(bs, nt), c = c.replace(xs, rt).replace(bs, nt), n.isWebGL2 && !n.isRawShaderMtrl && (u = !1, 
h = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMtrl && null !== s.match(h) && null !== c.match(h) && (u = !0, 
s = s.replace(h, ""), c = c.replace(h, "")), o = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + o, 
l = [ "#version 300 es\n\n#define varying in", u ? "" : "out highp vec4 pc_fragColor;", u ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad" ].join("\n") + "\n" + l), 
c = l + c, s = Xe(a, 35633, o + s), c = Xe(a, 35632, c), a.attachShader(g, s), a.attachShader(g, c), 
void 0 !== n.index0AttributeName ? a.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(g, 0, "position"), 
a.linkProgram(g), e.debug.checkShaderErrors && (e = a.getProgramInfoLog(g).trim(), 
u = a.getShaderInfoLog(s).trim(), h = a.getShaderInfoLog(c).trim(), p = d = !0, 
!1 === a.getProgramParameter(g, 35714) ? (d = !1, f = Je(a, s, "vertex"), m = Je(a, c, "fragment"), 
console.error("$3.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(g, 35715), "gl.getProgramInfoLog", e, f, m)) : "" !== e ? console.warn("$3.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== u && "" !== h || (p = !1), 
p && (this.diagnostics = {
runnable: d,
programLog: e,
vertexShader: {
log: u,
prefix: o
},
fragmentShader: {
log: h,
prefix: l
}
})), a.deleteShader(s), a.deleteShader(c), this.getUniforms = function() {
return void 0 === r && (r = new He(a, g)), r;
}, this.getAttributes = function() {
if (void 0 === i) {
for (var e = {}, t = a.getProgramParameter(g, 35721), n = 0; n < t; n++) {
var r = a.getActiveAttrib(g, n).name;
e[r] = a.getAttribLocation(g, r);
}
i = e;
}
return i;
}, this.destroy = function() {
a.deleteProgram(g), this.program = void 0;
}, this.name = n.shaderName, this.id = ys++, this.cacheKey = t, this.usedTimes = 1, 
this.program = g, this.vertexShader = s, this.fragmentShader = c, this;
}
function ot(e, t) {
return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
}
function st(e, t) {
return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
}
function ct() {
function e(e, r, i, o, s, c) {
var l = t[n];
return void 0 === l ? (l = {
id: e.id,
object: e,
geometry: r,
material: i,
program: i.program || a,
groupOrder: o,
renderOrder: e.renderOrder,
z: s,
group: c
}, t[n] = l) : (l.id = e.id, l.object = e, l.geometry = r, l.material = i, l.program = i.program || a, 
l.groupOrder = o, l.renderOrder = e.renderOrder, l.z = s, l.group = c), n++, l;
}
var t = [], n = 0, r = [], i = [], a = {
id: -1
};
return {
opaque: r,
transparent: i,
init: function() {
n = 0, r.length = 0, i.length = 0;
},
push: function(t, n, a, o, s, c) {
t = e(t, n, a, o, s, c), (!0 === a.transparent ? i : r).push(t);
},
unshift: function(t, n, a, o, s, c) {
t = e(t, n, a, o, s, c), (!0 === a.transparent ? i : r).unshift(t);
},
finish: function() {
for (var e = n, r = t.length; e < r; e++) {
var i = t[e];
if (null === i.id) break;
i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, 
i.group = null;
}
},
sort: function(e, t) {
1 < r.length && r.sort(e || ot), 1 < i.length && i.sort(t || st);
}
};
}
function lt(e, t) {
return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
}
function ut() {
for (var e = new function() {
var e = {};
return {
get: function(t) {
if (void 0 !== e[t.id]) return e[t.id];
switch (t.type) {
case "DirectionalLight":
var n = {
direction: new l(),
color: new x()
};
break;

case "SpotLight":
n = {
position: new l(),
direction: new l(),
color: new x(),
distance: 0,
coneCos: 0,
penumbraCos: 0,
decay: 0
};
break;

case "PointLight":
n = {
position: new l(),
color: new x(),
distance: 0,
decay: 0
};
break;

case "HemisphereLight":
n = {
direction: new l(),
skyColor: new x(),
groundColor: new x()
};
break;

case "RectAreaLight":
n = {
color: new x(),
position: new l(),
halfWidth: new l(),
halfHeight: new l()
};
}
return e[t.id] = n;
}
};
}(), t = function() {
var e = {};
return {
get: function(t) {
if (void 0 !== e[t.id]) return e[t.id];
switch (t.type) {
case "DirectionalLight":
var r = {
shadowBias: 0,
shadowRadius: 1,
shadowMapSize: new n()
};
break;

case "SpotLight":
r = {
shadowBias: 0,
shadowRadius: 1,
shadowMapSize: new n()
};
break;

case "PointLight":
r = {
shadowBias: 0,
shadowRadius: 1,
shadowMapSize: new n(),
shadowCameraNear: 1,
shadowCameraFar: 1e3
};
}
return e[t.id] = r;
}
};
}(), r = {
version: 0,
hash: {
directionalLength: -1,
pointLength: -1,
spotLength: -1,
rectAreaLength: -1,
hemiLength: -1,
numDirectionalShadows: -1,
numPointShadows: -1,
numSpotShadows: -1
},
ambient: [ 0, 0, 0 ],
probe: [],
directional: [],
directionalShadow: [],
directionalShadowMap: [],
directionalShadowMatrix: [],
spot: [],
spotShadow: [],
spotShadowMap: [],
spotShadowMatrix: [],
rectArea: [],
point: [],
pointShadow: [],
pointShadowMap: [],
pointShadowMatrix: [],
hemi: []
}, i = 0; 9 > i; i++) r.probe.push(new l());
var a = new l(), o = new u(), s = new u();
return {
setup: function(n, i, c) {
for (var l = i = 0, u = 0, h = 0; 9 > h; h++) r.probe[h].set(0, 0, 0);
var d = h = 0, p = 0, f = 0, m = 0, g = 0, v = 0, y = 0;
c = c.matrixWorldInverse, n.sort(lt);
for (var $ = 0, b = n.length; $ < b; $++) {
var x = n[$], w = x.color, _ = x.intensity, M = x.distance, S = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
if (x.isAmbientLight) i += w.r * _, l += w.g * _, u += w.b * _; else if (x.isLightProbe) for (S = 0; 9 > S; S++) r.probe[S].addScaledVector(x.sh.coefficients[S], _); else if (x.isDirectionalLight) {
if ((_ = e.get(x)).color.copy(x.color).multiplyScalar(x.intensity), _.direction.setFromMatrixPosition(x.matrixWorld), 
a.setFromMatrixPosition(x.target.matrixWorld), _.direction.sub(a), _.direction.transformDirection(c), 
x.castShadow) {
var A = x.shadow;
(w = t.get(x)).shadowBias = A.bias, w.shadowRadius = A.radius, w.shadowMapSize = A.mapSize, 
r.directionalShadow[h] = w, r.directionalShadowMap[h] = S, r.directionalShadowMatrix[h] = x.shadow.matrix, 
g++;
}
r.directional[h] = _, h++;
} else x.isSpotLight ? ((A = e.get(x)).position.setFromMatrixPosition(x.matrixWorld), 
A.position.applyMatrix4(c), A.color.copy(w).multiplyScalar(_), A.distance = M, A.direction.setFromMatrixPosition(x.matrixWorld), 
a.setFromMatrixPosition(x.target.matrixWorld), A.direction.sub(a), A.direction.transformDirection(c), 
A.coneCos = Math.cos(x.angle), A.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), 
A.decay = x.decay, x.castShadow && (_ = x.shadow, (w = t.get(x)).shadowBias = _.bias, 
w.shadowRadius = _.radius, w.shadowMapSize = _.mapSize, r.spotShadow[p] = w, r.spotShadowMap[p] = S, 
r.spotShadowMatrix[p] = x.shadow.matrix, y++), r.spot[p] = A, p++) : x.isRectAreaLight ? ((S = e.get(x)).color.copy(w).multiplyScalar(_), 
S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(c), s.identity(), 
o.copy(x.matrixWorld), o.premultiply(c), s.extractRotation(o), S.halfWidth.set(.5 * x.width, 0, 0), 
S.halfHeight.set(0, .5 * x.height, 0), S.halfWidth.applyMatrix4(s), S.halfHeight.applyMatrix4(s), 
r.rectArea[f] = S, f++) : x.isPointLight ? ((_ = e.get(x)).position.setFromMatrixPosition(x.matrixWorld), 
_.position.applyMatrix4(c), _.color.copy(x.color).multiplyScalar(x.intensity), _.distance = x.distance, 
_.decay = x.decay, x.castShadow && (A = x.shadow, (w = t.get(x)).shadowBias = A.bias, 
w.shadowRadius = A.radius, w.shadowMapSize = A.mapSize, w.shadowCameraNear = A.camera.near, 
w.shadowCameraFar = A.camera.far, r.pointShadow[d] = w, r.pointShadowMap[d] = S, 
r.pointShadowMatrix[d] = x.shadow.matrix, v++), r.point[d] = _, d++) : x.isHemisphereLight && ((S = e.get(x)).direction.setFromMatrixPosition(x.matrixWorld), 
S.direction.transformDirection(c), S.direction.normalize(), S.skyColor.copy(x.color).multiplyScalar(_), 
S.groundColor.copy(x.groundColor).multiplyScalar(_), r.hemi[m] = S, m++);
}
r.ambient[0] = i, r.ambient[1] = l, r.ambient[2] = u, (n = r.hash).directionalLength === h && n.pointLength === d && n.spotLength === p && n.rectAreaLength === f && n.hemiLength === m && n.numDirectionalShadows === g && n.numPointShadows === v && n.numSpotShadows === y || (r.directional.length = h, 
r.spot.length = p, r.rectArea.length = f, r.point.length = d, r.hemi.length = m, 
r.directionalShadow.length = g, r.directionalShadowMap.length = g, r.pointShadow.length = v, 
r.pointShadowMap.length = v, r.spotShadow.length = y, r.spotShadowMap.length = y, 
r.directionalShadowMatrix.length = g, r.pointShadowMatrix.length = v, r.spotShadowMatrix.length = y, 
n.directionalLength = h, n.pointLength = d, n.spotLength = p, n.rectAreaLength = f, 
n.hemiLength = m, n.numDirectionalShadows = g, n.numPointShadows = v, n.numSpotShadows = y, 
r.version = ws++);
},
state: r
};
}
function ht() {
var e = new ut(), t = [], n = [];
return {
init: function() {
t.length = 0, n.length = 0;
},
state: {
lightsArray: t,
shadowsArray: n,
lights: e
},
setupLights: function(r) {
e.setup(t, n, r);
},
pushLight: function(e) {
t.push(e);
},
pushShadow: function(e) {
n.push(e);
}
};
}
function dt(e) {
A.call(this), this.type = "MeshDepthMtrl", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, 
this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, 
this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, 
this.setValues(e);
}
function pt(e) {
A.call(this), this.type = "MeshDistanceMtrl", this.referencePosition = new l(), 
this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, 
this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, 
this.displacementBias = 0, this.fog = !1, this.setValues(e);
}
function ft(e, t, r) {
function i(e, t, n) {
var r = f[n = e << 0 | t << 1 | n << 2];
return void 0 === r && (r = new dt({
depthPacking: 3201,
morphTargets: e,
skinning: t
}), f[n] = r), r;
}
function s(e, t, n) {
var r = m[n = e << 0 | t << 1 | n << 2];
return void 0 === r && (r = new pt({
morphTargets: e,
skinning: t
}), m[n] = r), r;
}
function c(t, n, r, a, o, c, l) {
var u = i, h = t.customDepthMtrl;
return !0 === a.isPointLight && (u = s, h = t.customDistanceMtrl), void 0 === h ? (h = !1, 
!0 === r.morphTargets && (h = n.morphAttributes && n.morphAttributes.position && 0 < n.morphAttributes.position.length), 
n = !1, !0 === t.isSkinnedMesh && (!0 === r.skinning ? n = !0 : console.warn("$3.WebGLShadowMap: $3.SkinnedMesh with material.skinning set to false:", t)), 
t = u(h, n, !0 === t.isInstancedMesh)) : t = h, e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length && (h = t.uuid, 
u = r.uuid, void 0 === (n = g[h]) && (n = {}, g[h] = n), void 0 === (h = n[u]) && (h = t.clone(), 
n[u] = h), t = h), t.visible = r.visible, t.wireframe = r.wireframe, t.side = 3 === l ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : v[r.side], 
t.clipShadows = r.clipShadows, t.clippingPlanes = r.clippingPlanes, t.clipIntersection = r.clipIntersection, 
t.wireframeLinewidth = r.wireframeLinewidth, t.linewidth = r.linewidth, !0 === a.isPointLight && !0 === t.isMeshDistanceMtrl && (t.referencePosition.setFromMatrixPosition(a.matrixWorld), 
t.nearDistance = o, t.farDistance = c), t;
}
function l(n, r, i, a, o) {
if (!1 !== n.visible) {
if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || u.intersectsObject(n))) {
n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, n.matrixWorld);
var s = t.update(n), h = n.material;
if (Array.isArray(h)) for (var d = s.groups, p = 0, f = d.length; p < f; p++) {
var m = d[p], g = h[m.materialIndex];
g && g.visible && (g = c(n, s, g, a, i.near, i.far, o), e.renderBufferDirect(i, null, s, g, n, m));
} else h.visible && (h = c(n, s, h, a, i.near, i.far, o), e.renderBufferDirect(i, null, s, h, n, null));
}
for (s = 0, h = (n = n.children).length; s < h; s++) l(n[s], r, i, a, o);
}
}
var u = new Q(), h = new n(), d = new n(), p = new a(), f = [], m = [], g = {}, v = {
0: 1,
1: 0,
2: 2
}, y = new H({
defines: {
SAMPLE_RATE: .25,
HALF_SAMPLE_RATE: .125
},
uniforms: {
shadow_pass: {
value: null
},
resolution: {
value: new n()
},
radius: {
value: 4
}
},
vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
}), $ = y.clone();
$.defines.HORIZONAL_PASS = 1;
var b = new B();
b.setAttribute("position", new L(new Float32Array([ -1, -1, .5, 3, -1, .5, -1, 3, .5 ]), 3));
var x = new z(b, y), w = this;
this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(n, i, a) {
if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate) && 0 !== n.length) {
var s = e.getRenderTarget(), c = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.state;
m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), 
m.setScissorTest(!1);
for (var g = 0, v = n.length; g < v; g++) {
var b = n[g], _ = b.shadow;
if (void 0 === _) console.warn("$3.WebGLShadowMap:", b, "has no shadow."); else {
h.copy(_.mapSize);
var M = _.getFrameExtents();
h.multiply(M), d.copy(_.mapSize), (h.x > r || h.y > r) && (h.x > r && (d.x = Math.floor(r / M.x), 
h.x = d.x * M.x, _.mapSize.x = d.x), h.y > r && (d.y = Math.floor(r / M.y), h.y = d.y * M.y, 
_.mapSize.y = d.y)), null !== _.map || _.isPointLightShadow || 3 !== this.type || (M = {
minFilter: 1006,
magFilter: 1006,
format: 1023
}, _.map = new o(h.x, h.y, M), _.map.texture.name = b.name + ".shadowMap", _.mapPass = new o(h.x, h.y, M), 
_.camera.updateProjectionMatrix()), null === _.map && (_.map = new o(h.x, h.y, {
minFilter: 1003,
magFilter: 1003,
format: 1023
}), _.map.texture.name = b.name + ".shadowMap", _.camera.updateProjectionMatrix()), 
e.setRenderTarget(_.map), e.clear(), M = _.getViewportCount();
for (var S = 0; S < M; S++) {
var A = _.getViewport(S);
p.set(d.x * A.x, d.y * A.y, d.x * A.z, d.y * A.w), m.viewport(p), _.updateMatrices(b, S), 
u = _.getFrustum(), l(i, a, _.camera, b, this.type);
}
_.isPointLightShadow || 3 !== this.type || (b = _, _ = a, M = t.update(x), y.uniforms.shadow_pass.value = b.map.texture, 
y.uniforms.resolution.value = b.mapSize, y.uniforms.radius.value = b.radius, e.setRenderTarget(b.mapPass), 
e.clear(), e.renderBufferDirect(_, null, M, y, x, null), $.uniforms.shadow_pass.value = b.mapPass.texture, 
$.uniforms.resolution.value = b.mapSize, $.uniforms.radius.value = b.radius, e.setRenderTarget(b.map), 
e.clear(), e.renderBufferDirect(_, null, M, $, x, null));
}
}
w.needsUpdate = !1, e.setRenderTarget(s, c, f);
}
};
}
function mt(e, t, n) {
var r = n.isWebGL2;
return {
convert: function(e) {
if (1009 === e) return 5121;
if (1017 === e) return 32819;
if (1018 === e) return 32820;
if (1019 === e) return 33635;
if (1010 === e) return 5120;
if (1011 === e) return 5122;
if (1012 === e) return 5123;
if (1013 === e) return 5124;
if (1014 === e) return 5125;
if (1015 === e) return 5126;
if (1016 === e) {
if (r) return 5131;
var n = t.get("OES_texture_half_float");
return null !== n ? n.HALF_FLOAT_OES : null;
}
if (1021 === e) return 6406;
if (1022 === e) return 6407;
if (1023 === e) return 6408;
if (1024 === e) return 6409;
if (1025 === e) return 6410;
if (1026 === e) return 6402;
if (1027 === e) return 34041;
if (1028 === e) return 6403;
if (1029 === e) return 36244;
if (1030 === e) return 33319;
if (1031 === e) return 33320;
if (1032 === e) return 36248;
if (1033 === e) return 36249;
if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null;
if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
}
if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
}
if (36196 === e) return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
if ((37492 === e || 37496 === e) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) {
if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
}
return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : 1020 === e ? r ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0;
}
};
}
function gt(e) {
Y.call(this), this.cameras = e || [];
}
function vt() {
p.call(this), this.type = "Group";
}
function yt() {
this._grip = this._targetRay = null;
}
function $t(e, t) {
function n(e) {
var t = g.get(e.inputSource);
t && t.dispatchEvent({
type: e.type
});
}
function r() {
g.forEach(function(e, t) {
e.disconnect(t);
}), g.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), A.stop(), 
c.isPresenting = !1, c.dispatchEvent({
type: "sessionend"
});
}
function i(e) {
d = e, A.setContext(u), A.start(), c.isPresenting = !0, c.dispatchEvent({
type: "sessionstart"
});
}
function o(e) {
for (var t = u.inputSources, n = 0; n < m.length; n++) g.set(t[n], m[n]);
for (t = 0; t < e.removed.length; t++) {
n = e.removed[t];
var r = g.get(n);
r && (r.dispatchEvent({
type: "disconnected",
data: n
}), g.delete(n));
}
for (t = 0; t < e.added.length; t++) n = e.added[t], (r = g.get(n)) && r.dispatchEvent({
type: "connected",
data: n
});
}
function s(e, t) {
null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), 
e.matrixWorldInverse.getInverse(e.matrixWorld);
}
var c = this, u = null, h = 1, d = null, p = "local-floor", f = null, m = [], g = new Map(), v = new Y();
v.layers.enable(1), v.viewport = new a();
var y = new Y();
y.layers.enable(2), y.viewport = new a();
var $ = [ v, y ], b = new gt();
b.layers.enable(1), b.layers.enable(2);
var x = null, w = null;
this.isPresenting = this.enabled = !1, this.getController = function(e) {
var t = m[e];
return void 0 === t && (t = new yt(), m[e] = t), t.getTargetRaySpace();
}, this.getControllerGrip = function(e) {
var t = m[e];
return void 0 === t && (t = new yt(), m[e] = t), t.getGripSpace();
}, this.setFramebufferScaleFactor = function(e) {
h = e, !0 === c.isPresenting && console.warn("$3.WebXRManager: Cannot change framebuffer scale while presenting.");
}, this.setReferenceSpaceType = function(e) {
p = e, !0 === c.isPresenting && console.warn("$3.WebXRManager: Cannot change reference space type while presenting.");
}, this.getReferenceSpace = function() {
return d;
}, this.getSession = function() {
return u;
}, this.setSession = function(e) {
null !== (u = e) && (u.addEventListener("select", n), u.addEventListener("selectstart", n), 
u.addEventListener("selectend", n), u.addEventListener("squeeze", n), u.addEventListener("squeezestart", n), 
u.addEventListener("squeezeend", n), u.addEventListener("end", r), !0 !== (e = t.getContextAttributes()).xrCompatible && t.makeXRCompatible(), 
e = new XRWebGLLayer(u, t, {
antialias: e.antialias,
alpha: e.alpha,
depth: e.depth,
stencil: e.stencil,
framebufferScaleFactor: h
}), u.updateRenderState({
baseLayer: e
}), u.requestReferenceSpace(p).then(i), u.addEventListener("inputsourceschange", o));
};
var _ = new l(), M = new l();
this.getCamera = function(e) {
b.near = y.near = v.near = e.near, b.far = y.far = v.far = e.far, x === b.near && w === b.far || (u.updateRenderState({
depthNear: b.near,
depthFar: b.far
}), x = b.near, w = b.far);
var t = e.parent, n = b.cameras;
s(b, t);
for (var r = 0; r < n.length; r++) s(n[r], t);
for (e.matrixWorld.copy(b.matrixWorld), t = 0, r = (e = e.children).length; t < r; t++) e[t].updateMatrixWorld(!0);
if (2 === n.length) {
_.setFromMatrixPosition(v.matrixWorld), M.setFromMatrixPosition(y.matrixWorld), 
n = _.distanceTo(M);
var i = v.projectionMatrix.elements, a = y.projectionMatrix.elements, o = i[14] / (i[10] - 1);
e = i[14] / (i[10] + 1), t = (i[9] + 1) / i[5], r = (i[9] - 1) / i[5];
var c = (i[8] - 1) / i[0], l = (a[8] + 1) / a[0];
a = o * c, i = o * l, c = (l = n / (-c + l)) * -c, v.matrixWorld.decompose(b.position, b.quaternion, b.scale), 
b.translateX(c), b.translateZ(l), b.matrixWorld.compose(b.position, b.quaternion, b.scale), 
b.matrixWorldInverse.getInverse(b.matrixWorld), o += l, l = e + l, b.projectionMatrix.makePerspective(a - c, i + (n - c), t * e / l * o, r * e / l * o, o, l);
} else b.projectionMatrix.copy(v.projectionMatrix);
return b;
};
var S = null, A = new ee();
A.setAnimationLoop(function(t, n) {
if (null !== (f = n.getViewerPose(d))) {
var r = f.views, i = u.renderState.baseLayer;
e.setFramebuffer(i.framebuffer);
var a = !1;
r.length !== b.cameras.length && (b.cameras.length = 0, a = !0);
for (var o = 0; o < r.length; o++) {
var s = r[o], c = i.getViewport(s), l = $[o];
l.matrix.fromArray(s.transform.matrix), l.projectionMatrix.fromArray(s.projectionMatrix), 
l.viewport.set(c.x, c.y, c.width, c.height), 0 === o && b.matrix.copy(l.matrix), 
!0 === a && b.cameras.push(l);
}
}
for (r = u.inputSources, i = 0; i < m.length; i++) m[i].update(r[i], n, d);
S && S(t, n);
}), this.setAnimationLoop = function(e) {
S = e;
}, this.dispose = function() {};
}
function bt(e) {
var t;
function r() {
L = new function(e) {
var t = {};
return {
get: function(n) {
if (void 0 !== t[n]) return t[n];
switch (n) {
case "WEBGL_depth_texture":
var r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
break;

case "EXT_texture_filter_anisotropic":
r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
break;

case "WEBGL_compressed_texture_s3tc":
r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
break;

case "WEBGL_compressed_texture_pvrtc":
r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
break;

default:
r = e.getExtension(n);
}
return null === r && console.warn("$3.WebGLRenderer: " + n + " extension not supported."), 
t[n] = r;
}
};
}(Ce), !1 === (C = new function(e, t, n) {
function r(t) {
if ("highp" === t) {
if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
t = "mediump";
}
return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
}
var i, a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext, o = void 0 !== n.precision ? n.precision : "highp", s = r(o);
s !== o && (console.warn("$3.WebGLRenderer:", o, "not supported, using", s, "instead."), 
o = s), n = !0 === n.logarithmicDepthBuffer, s = e.getParameter(34930);
var c = e.getParameter(35660), l = e.getParameter(3379), u = e.getParameter(34076), h = e.getParameter(34921), d = e.getParameter(36347), p = e.getParameter(36348), f = e.getParameter(36349), m = 0 < c, g = a || !!t.get("OES_texture_float");
return {
isWebGL2: a,
getMaxAnisotropy: function() {
if (void 0 !== i) return i;
var n = t.get("EXT_texture_filter_anisotropic");
return i = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
},
getMaxPrecision: r,
precision: o,
logarithmicDepthBuffer: n,
maxTextures: s,
maxVertexTextures: c,
maxTextureSize: l,
maxCubemapSize: u,
maxAttributes: h,
maxVertexUniforms: d,
maxVaryings: p,
maxFragmentUniforms: f,
vertexTextures: m,
floatFragmentTextures: g,
floatVertexTextures: m && g,
maxSamples: a ? e.getParameter(36183) : 0
};
}(Ce, L, e)).isWebGL2 && (L.get("WEBGL_depth_texture"), L.get("OES_texture_float"), 
L.get("OES_texture_half_float"), L.get("OES_texture_half_float_linear"), L.get("OES_standard_derivatives"), 
L.get("OES_element_index_uint"), L.get("ANGLE_instanced_arrays")), L.get("OES_texture_float_linear"), 
W = new mt(Ce, L, C), (E = new function(e, t, n) {
function r(t, n, r) {
var i = new Uint8Array(4), a = e.createTexture();
for (e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), 
t = 0; t < r; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
return a;
}
function i(n, r) {
v[n] = 1, 0 === y[n] && (e.enableVertexAttribArray(n), y[n] = 1), $[n] !== r && ((p ? e : t.get("ANGLE_instanced_arrays"))[p ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), 
$[n] = r);
}
function o(t) {
!0 !== b[t] && (e.enable(t), b[t] = !0);
}
function s(t) {
!1 !== b[t] && (e.disable(t), b[t] = !1);
}
function c(t, n, r, i, a, c, l, u) {
if (0 === t) w && (s(3042), w = !1); else if (w || (o(3042), w = !0), 5 !== t) {
if (t !== _ || u !== E) {
if (100 === M && 100 === T || (e.blendEquation(32774), T = M = 100), u) switch (t) {
case 1:
e.blendFuncSeparate(1, 771, 1, 771);
break;

case 2:
e.blendFunc(1, 1);
break;

case 3:
e.blendFuncSeparate(0, 0, 769, 771);
break;

case 4:
e.blendFuncSeparate(0, 768, 0, 770);
break;

default:
console.error("$3.WebGLState: Invalid blending: ", t);
} else switch (t) {
case 1:
e.blendFuncSeparate(770, 771, 1, 771);
break;

case 2:
e.blendFunc(770, 1);
break;

case 3:
e.blendFunc(0, 769);
break;

case 4:
e.blendFunc(0, 768);
break;

default:
console.error("$3.WebGLState: Invalid blending: ", t);
}
C = L = A = S = null, _ = t, E = u;
}
} else a = a || n, c = c || r, l = l || i, n === M && a === T || (e.blendEquationSeparate(G[n], G[a]), 
M = n, T = a), r === S && i === A && c === L && l === C || (e.blendFuncSeparate(V[r], V[i], V[c], V[l]), 
S = r, A = i, L = c, C = l), _ = t, E = null;
}
function l(t) {
P !== t && (t ? e.frontFace(2304) : e.frontFace(2305), P = t);
}
function u(t) {
0 !== t ? (o(2884), t !== k && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : s(2884), 
k = t;
}
function h(t, n, r) {
t ? (o(32823), (D !== n || N !== r) && (e.polygonOffset(n, r), D = n, N = r)) : s(32823);
}
function d(t) {
void 0 === t && (t = 33984 + I - 1), j !== t && (e.activeTexture(t), j = t);
}
var p = n.isWebGL2, f = new function() {
var t = !1, n = new a(), r = null, i = new a(0, 0, 0, 0);
return {
setMask: function(n) {
r === n || t || (e.colorMask(n, n, n, n), r = n);
},
setLocked: function(e) {
t = e;
},
setClear: function(t, r, a, o, s) {
!0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), 
i.copy(n));
},
reset: function() {
t = !1, r = null, i.set(-1, 0, 0, 0);
}
};
}(), m = new function() {
var t = !1, n = null, r = null, i = null;
return {
setTest: function(e) {
e ? o(2929) : s(2929);
},
setMask: function(r) {
n === r || t || (e.depthMask(r), n = r);
},
setFunc: function(t) {
if (r !== t) {
if (t) switch (t) {
case 0:
e.depthFunc(512);
break;

case 1:
e.depthFunc(519);
break;

case 2:
e.depthFunc(513);
break;

case 3:
e.depthFunc(515);
break;

case 4:
e.depthFunc(514);
break;

case 5:
e.depthFunc(518);
break;

case 6:
e.depthFunc(516);
break;

case 7:
e.depthFunc(517);
break;

default:
e.depthFunc(515);
} else e.depthFunc(515);
r = t;
}
},
setLocked: function(e) {
t = e;
},
setClear: function(t) {
i !== t && (e.clearDepth(t), i = t);
},
reset: function() {
t = !1, i = r = n = null;
}
};
}(), g = new function() {
var t = !1, n = null, r = null, i = null, a = null, c = null, l = null, u = null, h = null;
return {
setTest: function(e) {
t || (e ? o(2960) : s(2960));
},
setMask: function(r) {
n === r || t || (e.stencilMask(r), n = r);
},
setFunc: function(t, n, o) {
r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o);
},
setOp: function(t, n, r) {
c === t && l === n && u === r || (e.stencilOp(t, n, r), c = t, l = n, u = r);
},
setLocked: function(e) {
t = e;
},
setClear: function(t) {
h !== t && (e.clearStencil(t), h = t);
},
reset: function() {
t = !1, h = u = l = c = a = i = r = n = null;
}
};
}();
n = e.getParameter(34921);
var v = new Uint8Array(n), y = new Uint8Array(n), $ = new Uint8Array(n), b = {}, x = null, w = null, _ = null, M = null, S = null, A = null, T = null, L = null, C = null, E = !1, P = null, k = null, O = null, D = null, N = null, I = e.getParameter(35661), R = !1;
n = 0, -1 !== (n = e.getParameter(7938)).indexOf("WebGL") ? (n = parseFloat(/^WebGL ([0-9])/.exec(n)[1]), 
R = 1 <= n) : -1 !== n.indexOf("OpenGL ES") && (n = parseFloat(/^OpenGL ES ([0-9])/.exec(n)[1]), 
R = 2 <= n);
var j = null, U = {}, B = new a(), z = new a(), F = {};
F[3553] = r(3553, 3553, 1), F[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), 
m.setClear(1), g.setClear(0), o(2929), m.setFunc(3), l(!1), u(1), o(2884), c(0);
var G = {
100: 32774,
101: 32778,
102: 32779
};
p ? (G[103] = 32775, G[104] = 32776) : null !== (n = t.get("EXT_blend_minmax")) && (G[103] = n.MIN_EXT, 
G[104] = n.MAX_EXT);
var V = {
200: 0,
201: 1,
202: 768,
204: 770,
210: 776,
208: 774,
206: 772,
203: 769,
205: 771,
209: 775,
207: 773
};
return {
buffers: {
color: f,
depth: m,
stencil: g
},
initAttributes: function() {
for (var e = 0, t = v.length; e < t; e++) v[e] = 0;
},
enableAttribute: function(e) {
i(e, 0);
},
enableAttributeAndDivisor: i,
disableUnusedAttributes: function() {
for (var t = 0, n = y.length; t !== n; ++t) y[t] !== v[t] && (e.disableVertexAttribArray(t), 
y[t] = 0);
},
vertexAttribPointer: function(t, n, r, i, a, o) {
!0 !== p || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, i, a, o) : e.vertexAttribIPointer(t, n, r, i, a, o);
},
enable: o,
disable: s,
useProgram: function(t) {
return x !== t && (e.useProgram(t), x = t, !0);
},
setBlending: c,
setMtrl: function(e, t) {
2 === e.side ? s(2884) : o(2884);
var n = 1 === e.side;
t && (n = !n), l(n), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), 
m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), 
t = e.stencilWrite, g.setTest(t), t && (g.setMask(e.stencilWriteMask), g.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), 
g.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), h(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
},
setFlipSided: l,
setCullFace: u,
setLineWidth: function(t) {
t !== O && (R && e.lineWidth(t), O = t);
},
setPolygonOffset: h,
setScissorTest: function(e) {
e ? o(3089) : s(3089);
},
activeTexture: d,
bindTexture: function(t, n) {
null === j && d();
var r = U[j];
void 0 === r && (r = {
type: void 0,
texture: void 0
}, U[j] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || F[t]), r.type = t, 
r.texture = n);
},
unbindTexture: function() {
var t = U[j];
void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, 
t.texture = void 0);
},
compressedTexImage2D: function() {
try {
e.compressedTexImage2D.apply(e, arguments);
} catch (e) {
console.error("$3.WebGLState:", e);
}
},
texImage2D: function() {
try {
e.texImage2D.apply(e, arguments);
} catch (e) {
console.error("$3.WebGLState:", e);
}
},
texImage3D: function() {
try {
e.texImage3D.apply(e, arguments);
} catch (e) {
console.error("$3.WebGLState:", e);
}
},
scissor: function(t) {
!1 === B.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), B.copy(t));
},
viewport: function(t) {
!1 === z.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), z.copy(t));
},
reset: function() {
for (var t = 0; t < y.length; t++) 1 === y[t] && (e.disableVertexAttribArray(t), 
y[t] = 0);
b = {}, j = null, U = {}, k = P = _ = x = null, f.reset(), m.reset(), g.reset();
}
};
}(Ce, L, C)).scissor(pe.copy(xe).multiplyScalar(ve).floor()), E.viewport(de.copy(be).multiplyScalar(ve).floor()), 
P = new function(e) {
var t = {
frame: 0,
calls: 0,
triangles: 0,
points: 0,
lines: 0
};
return {
memory: {
geometries: 0,
textures: 0
},
render: t,
programs: null,
autoReset: !0,
reset: function() {
t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
},
update: function(e, n, r) {
switch (r = r || 1, t.calls++, n) {
case 4:
t.triangles += e / 3 * r;
break;

case 1:
t.lines += e / 2 * r;
break;

case 3:
t.lines += r * (e - 1);
break;

case 2:
t.lines += r * e;
break;

case 0:
t.points += r * e;
break;

default:
console.error("$3.WebGLInfo: Unknown draw mode:", n);
}
}
};
}(Ce), k = new function() {
var e = new WeakMap();
return {
get: function(t) {
var n = e.get(t);
return void 0 === n && (n = {}, e.set(t, n)), n;
},
remove: function(t) {
e.delete(t);
},
update: function(t, n, r) {
e.get(t)[n] = r;
},
dispose: function() {
e = new WeakMap();
}
};
}(), O = new function(e, t, n, r, i, a, o) {
function s(e, t) {
return k ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
}
function c(e, t, n, r) {
var i = 1;
if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), 1 > i || !0 === t) {
if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (r = t ? da.floorPowerOfTwo : Math.floor)(i * e.width), 
i = r(i * e.height), void 0 === S && (S = s(t, i)), (n = n ? s(t, i) : S).width = t, 
n.height = i, n.getContext("2d").drawImage(e, 0, 0, t, i), console.warn("$3.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + i + ")."), 
n;
"data" in e && console.warn("$3.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").");
}
return e;
}
function l(e) {
return da.isPowerOfTwo(e.width) && da.isPowerOfTwo(e.height);
}
function u(e, t) {
return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter;
}
function h(t, n, i, a) {
e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E;
}
function d(n, r, i) {
if (!1 === A) return r;
if (null !== n) {
if (void 0 !== e[n]) return e[n];
console.warn("$3.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
}
return n = r, 6403 === r && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 
5121 === i && (n = 33321)), 6407 === r && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 
5121 === i && (n = 32849)), 6408 === r && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 
5121 === i && (n = 32856)), 33325 !== n && 33326 !== n && 34842 !== n && 34836 !== n || t.get("EXT_color_buffer_float"), 
n;
}
function p(e) {
return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729;
}
function f(t) {
(t = t.target).removeEventListener("dispose", f);
var n = r.get(t);
void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture), r.remove(t)), t.isVideoTexture && P.delete(t), 
o.memory.textures--;
}
function m(t) {
(t = t.target).removeEventListener("dispose", m);
var n = r.get(t), i = r.get(t.texture);
if (t) {
if (void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture), t.depthTexture && t.depthTexture.dispose(), 
t.isWebGLCubeRenderTarget) for (i = 0; 6 > i; i++) e.deleteFramebuffer(n.__webglFramebuffer[i]), 
n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[i]); else e.deleteFramebuffer(n.__webglFramebuffer), 
n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), 
n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), 
n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
r.remove(t.texture), r.remove(t);
}
o.memory.textures--;
}
function g(e, t) {
var i = r.get(e);
if (e.isVideoTexture) {
var a = o.render.frame;
P.get(e) !== a && (P.set(e, a), e.update());
}
if (0 < e.version && i.__version !== e.version) if (void 0 === (a = e.image)) console.warn("$3.WebGLRenderer: Texture marked for update but image is undefined"); else {
if (!1 !== a.complete) return void x(i, e, t);
console.warn("$3.WebGLRenderer: Texture marked for update but image is incomplete");
}
n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
}
function v(t, i) {
if (6 === t.image.length) {
var o = r.get(t);
if (0 < t.version && o.__version !== t.version) {
b(o, t), n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture), e.pixelStorei(37440, t.flipY);
var s = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), p = t.image[0] && t.image[0].isDataTexture;
i = [];
for (var f = 0; 6 > f; f++) i[f] = s || p ? p ? t.image[f].image : t.image[f] : c(t.image[f], !1, !0, L);
var m = l(f = i[0]) || A, g = a.convert(t.format), v = a.convert(t.type), y = d(t.internalFormat, g, v);
if ($(34067, t, m), s) {
for (p = 0; 6 > p; p++) {
var x = i[p].mipmaps;
for (s = 0; s < x.length; s++) {
var w = x[s];
1023 !== t.format && 1022 !== t.format ? null !== g ? n.compressedTexImage2D(34069 + p, s, y, w.width, w.height, 0, w.data) : console.warn("$3.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + p, s, y, w.width, w.height, 0, g, v, w.data);
}
}
o.__maxMipLevel = x.length - 1;
} else {
for (x = t.mipmaps, s = 0; 6 > s; s++) if (p) for (n.texImage2D(34069 + s, 0, y, i[s].width, i[s].height, 0, g, v, i[s].data), 
w = 0; w < x.length; w++) {
var _ = x[w].image[s].image;
n.texImage2D(34069 + s, w + 1, y, _.width, _.height, 0, g, v, _.data);
} else for (n.texImage2D(34069 + s, 0, y, g, v, i[s]), w = 0; w < x.length; w++) n.texImage2D(34069 + s, w + 1, y, g, v, x[w].image[s]);
o.__maxMipLevel = x.length;
}
u(t, m) && h(34067, t, f.width, f.height), o.__version = t.version, t.onUpdate && t.onUpdate(t);
} else n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture);
}
}
function y(e, t) {
n.activeTexture(33984 + t), n.bindTexture(34067, r.get(e).__webglTexture);
}
function $(n, a, o) {
o ? (e.texParameteri(n, 10242, D[a.wrapS]), e.texParameteri(n, 10243, D[a.wrapT]), 
32879 !== n && 35866 !== n || e.texParameteri(n, 32882, D[a.wrapR]), e.texParameteri(n, 10240, N[a.magFilter]), 
e.texParameteri(n, 10241, N[a.minFilter])) : (e.texParameteri(n, 10242, 33071), 
e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), 
1001 === a.wrapS && 1001 === a.wrapT || console.warn("$3.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to $3.ClampToEdgeWrapping."), 
e.texParameteri(n, 10240, p(a.magFilter)), e.texParameteri(n, 10241, p(a.minFilter)), 
1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("$3.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to $3.NearestFilter or $3.LinearFilter.")), 
!(o = t.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === t.get("OES_texture_float_linear") || 1016 === a.type && null === (A || t.get("OES_texture_half_float_linear")) || !(1 < a.anisotropy || r.get(a).__currentAnisotropy) || (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), 
r.get(a).__currentAnisotropy = a.anisotropy);
}
function b(t, n) {
void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", f), 
t.__webglTexture = e.createTexture(), o.memory.textures++);
}
function x(t, r, i) {
var o = 3553;
r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), b(t, r), 
n.activeTexture(33984 + i), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, r.flipY), 
e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), 
i = (i = !A && (1001 !== r.wrapS || 1001 !== r.wrapT || 1003 !== r.minFilter && 1006 !== r.minFilter)) && !1 === l(r.image);
var s = l(i = c(r.image, i, !1, C)) || A, p = a.convert(r.format), f = a.convert(r.type), m = d(r.internalFormat, p, f);
$(o, r, s);
var g = r.mipmaps;
if (r.isDepthTexture) m = 6402, A ? m = 1015 === r.type ? 36012 : 1014 === r.type ? 33190 : 1020 === r.type ? 35056 : 33189 : 1015 === r.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 
1026 === r.format && 6402 === m && 1012 !== r.type && 1014 !== r.type && (console.warn("$3.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), 
r.type = 1012, f = a.convert(r.type)), 1027 === r.format && 6402 === m && (m = 34041, 
1020 !== r.type && (console.warn("$3.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), 
r.type = 1020, f = a.convert(r.type))), n.texImage2D(3553, 0, m, i.width, i.height, 0, p, f, null); else if (r.isDataTexture) if (0 < g.length && s) {
for (var v = 0, y = g.length; v < y; v++) {
var x = g[v];
n.texImage2D(3553, v, m, x.width, x.height, 0, p, f, x.data);
}
r.generateMipmaps = !1, t.__maxMipLevel = g.length - 1;
} else n.texImage2D(3553, 0, m, i.width, i.height, 0, p, f, i.data), t.__maxMipLevel = 0; else if (r.isCompressedTexture) {
for (v = 0, y = g.length; v < y; v++) x = g[v], 1023 !== r.format && 1022 !== r.format ? null !== p ? n.compressedTexImage2D(3553, v, m, x.width, x.height, 0, x.data) : console.warn("$3.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, v, m, x.width, x.height, 0, p, f, x.data);
t.__maxMipLevel = g.length - 1;
} else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, m, i.width, i.height, i.depth, 0, p, f, i.data), 
t.__maxMipLevel = 0; else if (r.isDataTexture3D) n.texImage3D(32879, 0, m, i.width, i.height, i.depth, 0, p, f, i.data), 
t.__maxMipLevel = 0; else if (0 < g.length && s) {
for (v = 0, y = g.length; v < y; v++) x = g[v], n.texImage2D(3553, v, m, p, f, x);
r.generateMipmaps = !1, t.__maxMipLevel = g.length - 1;
} else n.texImage2D(3553, 0, m, p, f, i), t.__maxMipLevel = 0;
u(r, s) && h(o, r, i.width, i.height), t.__version = r.version, r.onUpdate && r.onUpdate(r);
}
function w(t, i, o, s) {
var c = a.convert(i.texture.format), l = a.convert(i.texture.type), u = d(i.texture.internalFormat, c, l);
n.texImage2D(s, 0, u, i.width, i.height, 0, c, l, null), e.bindFramebuffer(36160, t), 
e.framebufferTexture2D(36160, o, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(36160, null);
}
function _(t, n, r) {
if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
var i = 33189;
r ? ((r = n.depthTexture) && r.isDepthTexture && (1015 === r.type ? i = 36012 : 1014 === r.type && (i = 33190)), 
r = M(n), e.renderbufferStorageMultisample(36161, r, i, n.width, n.height)) : e.renderbufferStorage(36161, i, n.width, n.height), 
e.framebufferRenderbuffer(36160, 36096, 36161, t);
} else n.depthBuffer && n.stencilBuffer ? (r ? (r = M(n), e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height)) : e.renderbufferStorage(36161, 34041, n.width, n.height), 
e.framebufferRenderbuffer(36160, 33306, 36161, t)) : (t = a.convert(n.texture.format), 
i = a.convert(n.texture.type), t = d(n.texture.internalFormat, t, i), r ? (r = M(n), 
e.renderbufferStorageMultisample(36161, r, t, n.width, n.height)) : e.renderbufferStorage(36161, t, n.width, n.height));
e.bindRenderbuffer(36161, null);
}
function M(e) {
return A && e.isWebGLMultisampleRenderTarget ? Math.min(E, e.samples) : 0;
}
var S, A = i.isWebGL2, T = i.maxTextures, L = i.maxCubemapSize, C = i.maxTextureSize, E = i.maxSamples, P = new WeakMap(), k = !1;
try {
k = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
} catch (e) {}
var O = 0, D = {
1000: 10497,
1001: 33071,
1002: 33648
}, N = {
1003: 9728,
1004: 9984,
1005: 9986,
1006: 9729,
1007: 9985,
1008: 9987
}, I = !1, R = !1;
this.allocateTextureUnit = function() {
var e = O;
return e >= T && console.warn("$3.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + T), 
O += 1, e;
}, this.resetTextureUnits = function() {
O = 0;
}, this.setTexture2D = g, this.setTexture2DArray = function(e, t) {
var i = r.get(e);
0 < e.version && i.__version !== e.version ? x(i, e, t) : (n.activeTexture(33984 + t), 
n.bindTexture(35866, i.__webglTexture));
}, this.setTexture3D = function(e, t) {
var i = r.get(e);
0 < e.version && i.__version !== e.version ? x(i, e, t) : (n.activeTexture(33984 + t), 
n.bindTexture(32879, i.__webglTexture));
}, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(t) {
var i = r.get(t), s = r.get(t.texture);
t.addEventListener("dispose", m), s.__webglTexture = e.createTexture(), o.memory.textures++;
var c = !0 === t.isWebGLCubeRenderTarget, p = !0 === t.isWebGLMultisampleRenderTarget, f = l(t) || A;
if (!A || 1022 !== t.texture.format || 1015 !== t.texture.type && 1016 !== t.texture.type || (t.texture.format = 1023, 
console.warn("$3.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), 
c) for (i.__webglFramebuffer = [], p = 0; 6 > p; p++) i.__webglFramebuffer[p] = e.createFramebuffer(); else if (i.__webglFramebuffer = e.createFramebuffer(), 
p) if (A) {
i.__webglMultisampledFramebuffer = e.createFramebuffer(), i.__webglColorRenderbuffer = e.createRenderbuffer(), 
e.bindRenderbuffer(36161, i.__webglColorRenderbuffer), p = a.convert(t.texture.format);
var v = a.convert(t.texture.type);
p = d(t.texture.internalFormat, p, v), v = M(t), e.renderbufferStorageMultisample(36161, v, p, t.width, t.height), 
e.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), 
e.bindRenderbuffer(36161, null), t.depthBuffer && (i.__webglDepthRenderbuffer = e.createRenderbuffer(), 
_(i.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null);
} else console.warn("$3.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
if (c) {
for (n.bindTexture(34067, s.__webglTexture), $(34067, t.texture, f), s = 0; 6 > s; s++) w(i.__webglFramebuffer[s], t, 36064, 34069 + s);
u(t.texture, f) && h(34067, t.texture, t.width, t.height), n.bindTexture(34067, null);
} else n.bindTexture(3553, s.__webglTexture), $(3553, t.texture, f), w(i.__webglFramebuffer, t, 36064, 3553), 
u(t.texture, f) && h(3553, t.texture, t.width, t.height), n.bindTexture(3553, null);
if (t.depthBuffer) {
if (i = r.get(t), f = !0 === t.isWebGLCubeRenderTarget, t.depthTexture) {
if (f) throw Error("target.depthTexture not supported in Cube render targets");
if (t && t.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
if (e.bindFramebuffer(36160, i.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of $3.DepthTexture");
if (r.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, 
t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), 
i = r.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, i, 0); else {
if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
e.framebufferTexture2D(36160, 33306, 3553, i, 0);
}
} else if (f) for (i.__webglDepthbuffer = [], f = 0; 6 > f; f++) e.bindFramebuffer(36160, i.__webglFramebuffer[f]), 
i.__webglDepthbuffer[f] = e.createRenderbuffer(), _(i.__webglDepthbuffer[f], t, !1); else e.bindFramebuffer(36160, i.__webglFramebuffer), 
i.__webglDepthbuffer = e.createRenderbuffer(), _(i.__webglDepthbuffer, t, !1);
e.bindFramebuffer(36160, null);
}
}, this.updateRenderTargetMipmap = function(e) {
var t = e.texture, i = l(e) || A;
if (u(t, i)) {
i = e.isWebGLCubeRenderTarget ? 34067 : 3553;
var a = r.get(t).__webglTexture;
n.bindTexture(i, a), h(i, t, e.width, e.height), n.bindTexture(i, null);
}
}, this.updateMultisampleRenderTarget = function(t) {
if (t.isWebGLMultisampleRenderTarget) if (A) {
var n = r.get(t);
e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
var i = t.width, a = t.height, o = 16384;
t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728), 
e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
} else console.warn("$3.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
}, this.safeSetTexture2D = function(e, t) {
e && e.isWebGLRenderTarget && (!1 === I && (console.warn("$3.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), 
I = !0), e = e.texture), g(e, t);
}, this.safeSetTextureCube = function(e, t) {
e && e.isWebGLCubeRenderTarget && (!1 === R && (console.warn("$3.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), 
R = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t);
};
}(Ce, L, E, k, C, W, P), D = new te(Ce, C), N = new oe(Ce, D, P), I = new function(e, t, n, r) {
var i = new WeakMap();
return {
update: function(e) {
var a = r.render.frame, o = e.geometry, s = t.get(e, o);
return i.get(s) !== a && (o.isGmtr && s.updateFromObject(e), t.update(s), i.set(s, a)), 
e.isInstancedMesh && n.update(e.instanceMatrix, 34962), s;
},
dispose: function() {
i = new WeakMap();
}
};
}(Ce, N, D, P), F = new function(e) {
var t = {}, n = new Float32Array(8);
return {
update: function(r, i, a, o) {
var s = r.morphTargetInfluences, c = void 0 === s ? 0 : s.length;
if (void 0 === (r = t[i.id])) {
r = [];
for (var l = 0; l < c; l++) r[l] = [ l, 0 ];
t[i.id] = r;
}
l = a.morphTargets && i.morphAttributes.position, a = a.morphNormals && i.morphAttributes.normal;
for (var u = 0; u < c; u++) 0 !== r[u][1] && (l && i.deleteAttribute("morphTarget" + u), 
a && i.deleteAttribute("morphNormal" + u));
for (u = 0; u < c; u++) {
var h = r[u];
h[0] = u, h[1] = s[u];
}
for (r.sort(se), c = s = 0; 8 > c; c++) (h = r[c]) && (u = h[0], h = h[1]) ? (l && i.setAttribute("morphTarget" + c, l[u]), 
a && i.setAttribute("morphNormal" + c, a[u]), n[c] = h, s += h) : n[c] = 0;
i = i.morphTargetsRelative ? 1 : 1 - s, o.getUniforms().setValue(e, "morphTargetBaseInfluence", i), 
o.getUniforms().setValue(e, "morphTargetInfluences", n);
}
};
}(Ce), R = new function(e, t, n) {
function r(e) {
if (e) e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("$3.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), 
t = e.texture.encoding); else var t = 3e3;
return t;
}
var i = [], a = n.isWebGL2, o = n.logarithmicDepthBuffer, s = n.floatVertexTextures, c = n.maxVertexUniforms, l = n.vertexTextures, u = n.precision, h = {
MeshDepthMtrl: "depth",
MeshDistanceMtrl: "distanceRGBA",
MeshNormalMtrl: "normal",
MeshBasicMtrl: "basic",
MeshLambertMtrl: "lambert",
MeshPhongMtrl: "phong",
MeshToonMtrl: "toon",
MeshStandardMtrl: "physical",
MeshPhysicalMtrl: "physical",
MeshMatcapMtrl: "matcap",
LineBasicMtrl: "basic",
LineDashedMtrl: "dashed",
PointsMtrl: "points",
ShadowMtrl: "shadow",
SpriteMtrl: "sprite"
}, d = "precision isWebGL2 supportsVertexTextures outputEncoding instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatMap clearcoatRoughnessMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
this.getParameters = function(i, d, p, f, m, g, v) {
var y = f.fog;
f = i.isMeshStandardMtrl ? f.environment : null, f = i.envMap || f;
var $ = h[i.type];
if (v.isSkinnedMesh) {
var b = v.skeleton.bones;
if (s) b = 1024; else {
var x = Math.min(Math.floor((c - 20) / 4), b.length);
x < b.length ? (console.warn("$3.WebGLRenderer: Skeleton has " + b.length + " bones. This GPU supports " + x + "."), 
b = 0) : b = x;
}
} else b = 0;
null !== i.precision && (u = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("$3.WebGLProgram.getParameters:", i.precision, "not supported, using", u, "instead."), 
$ ? (x = ss[$], x = {
name: i.type,
uniforms: ns.clone(x.uniforms),
vertexShader: x.vertexShader,
fragmentShader: x.fragmentShader
}) : x = {
name: i.type,
uniforms: i.uniforms,
vertexShader: i.vertexShader,
fragmentShader: i.fragmentShader
}, i.onBeforeCompile(x, e);
var w = e.getRenderTarget();
return {
isWebGL2: a,
shaderID: $,
shaderName: x.name,
uniforms: x.uniforms,
vertexShader: x.vertexShader,
fragmentShader: x.fragmentShader,
defines: i.defines,
isRawShaderMtrl: i.isRawShaderMtrl,
isShaderMtrl: i.isShaderMtrl,
precision: u,
instancing: !0 === v.isInstancedMesh,
supportsVertexTextures: l,
outputEncoding: null !== w ? r(w.texture) : e.outputEncoding,
map: !!i.map,
mapEncoding: r(i.map),
matcap: !!i.matcap,
matcapEncoding: r(i.matcap),
envMap: !!f,
envMapMode: f && f.mapping,
envMapEncoding: r(f),
envMapCubeUV: !!f && (306 === f.mapping || 307 === f.mapping),
lightMap: !!i.lightMap,
lightMapEncoding: r(i.lightMap),
aoMap: !!i.aoMap,
emissiveMap: !!i.emissiveMap,
emissiveMapEncoding: r(i.emissiveMap),
bumpMap: !!i.bumpMap,
normalMap: !!i.normalMap,
objectSpaceNormalMap: 1 === i.normalMapType,
tangentSpaceNormalMap: 0 === i.normalMapType,
clearcoatMap: !!i.clearcoatMap,
clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
clearcoatNormalMap: !!i.clearcoatNormalMap,
displacementMap: !!i.displacementMap,
roughnessMap: !!i.roughnessMap,
metalnessMap: !!i.metalnessMap,
specularMap: !!i.specularMap,
alphaMap: !!i.alphaMap,
gradientMap: !!i.gradientMap,
sheen: !!i.sheen,
combine: i.combine,
vertexTangents: i.normalMap && i.vertexTangents,
vertexColors: i.vertexColors,
vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
fog: !!y,
useFog: i.fog,
fogExp2: y && y.isFogExp2,
flatShading: i.flatShading,
sizeAttenuation: i.sizeAttenuation,
logarithmicDepthBuffer: o,
skinning: i.skinning && 0 < b,
maxBones: b,
useVertexTexture: s,
morphTargets: i.morphTargets,
morphNormals: i.morphNormals,
maxMorphTargets: e.maxMorphTargets,
maxMorphNormals: e.maxMorphNormals,
numDirLights: d.directional.length,
numPointLights: d.point.length,
numSpotLights: d.spot.length,
numRectAreaLights: d.rectArea.length,
numHemiLights: d.hemi.length,
numDirLightShadows: d.directionalShadowMap.length,
numPointLightShadows: d.pointShadowMap.length,
numSpotLightShadows: d.spotShadowMap.length,
numClippingPlanes: m,
numClipIntersection: g,
dithering: i.dithering,
shadowMapEnabled: e.shadowMap.enabled && 0 < p.length,
shadowMapType: e.shadowMap.type,
toneMapping: i.toneMapped ? e.toneMapping : 0,
physicallyCorrectLights: e.physicallyCorrectLights,
premultipliedAlpha: i.premultipliedAlpha,
alphaTest: i.alphaTest,
doubleSided: 2 === i.side,
flipSided: 1 === i.side,
depthPacking: void 0 !== i.depthPacking && i.depthPacking,
index0AttributeName: i.index0AttributeName,
extensionDerivatives: i.extensions && i.extensions.derivatives,
extensionFragDepth: i.extensions && i.extensions.fragDepth,
extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
rendererExtensionFragDepth: a || null !== t.get("EXT_frag_depth"),
rendererExtensionDrawBuffers: a || null !== t.get("WEBGL_draw_buffers"),
rendererExtensionShaderTextureLod: a || null !== t.get("EXT_shader_texture_lod"),
onBeforeCompile: i.onBeforeCompile
};
}, this.getProgramCacheKey = function(t) {
var n = [];
if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), 
void 0 !== t.defines) for (var r in t.defines) n.push(r), n.push(t.defines[r]);
if (void 0 === t.isRawShaderMtrl) {
for (r = 0; r < d.length; r++) n.push(t[d[r]]);
n.push(e.outputEncoding), n.push(e.gammaFactor);
}
return n.push(t.onBeforeCompile.toString()), n.join();
}, this.acquireProgram = function(t, n) {
for (var r, a = 0, o = i.length; a < o; a++) {
var s = i[a];
if (s.cacheKey === n) {
++(r = s).usedTimes;
break;
}
}
return void 0 === r && (r = new at(e, n, t), i.push(r)), r;
}, this.releaseProgram = function(e) {
if (0 == --e.usedTimes) {
var t = i.indexOf(e);
i[t] = i[i.length - 1], i.pop(), e.destroy();
}
}, this.programs = i;
}(q, L, C), j = new function(e) {
function t(t, n, r) {
if (t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), 
n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), 
(r = n.envMap || r) && (t.envMap.value = r, t.flipEnvMap.value = r.isCubeTexture ? -1 : 1, 
t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio, 
t.maxMipLevel.value = e.get(r).__maxMipLevel), n.lightMap && (t.lightMap.value = n.lightMap, 
t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, 
t.aoMapIntensity.value = n.aoMapIntensity), n.map) var i = n.map; else n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap && (i = n.emissiveMap);
if (void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), 
t.uvTransform.value.copy(i.matrix)), n.aoMap) var a = n.aoMap; else n.lightMap && (a = n.lightMap);
void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), 
t.uv2Transform.value.copy(a.matrix));
}
function n(e, t, n) {
e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), 
t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), 
t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), 
t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 
1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, 
e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), 
(t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity);
}
return {
refreshFogUniforms: function(e, t) {
e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density);
},
refreshMtrlUniforms: function(e, r, i, a, o) {
if (r.isMeshBasicMtrl) t(e, r); else if (r.isMeshLambertMtrl) t(e, r), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap); else if (r.isMeshToonMtrl) t(e, r), 
e.specular.value.copy(r.specular), e.shininess.value = Math.max(r.shininess, 1e-4), 
r.gradientMap && (e.gradientMap.value = r.gradientMap), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), 
r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), 
r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 
1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, 
e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias); else if (r.isMeshPhongMtrl) t(e, r), 
e.specular.value.copy(r.specular), e.shininess.value = Math.max(r.shininess, 1e-4), 
r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), r.bumpMap && (e.bumpMap.value = r.bumpMap, 
e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, 
e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), 
r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, 
e.displacementBias.value = r.displacementBias); else if (r.isMeshStandardMtrl) t(e, r, i), 
r.isMeshPhysicalMtrl ? (n(e, r, i), e.reflectivity.value = r.reflectivity, e.clearcoat.value = r.clearcoat, 
e.clearcoatRoughness.value = r.clearcoatRoughness, r.sheen && e.sheen.value.copy(r.sheen), 
r.clearcoatMap && (e.clearcoatMap.value = r.clearcoatMap), r.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = r.clearcoatRoughnessMap), 
r.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(r.clearcoatNormalScale), 
e.clearcoatNormalMap.value = r.clearcoatNormalMap, 1 === r.side && e.clearcoatNormalScale.value.negate()), 
e.transparency.value = r.transparency) : n(e, r, i); else if (r.isMeshMatcapMtrl) t(e, r), 
r.matcap && (e.matcap.value = r.matcap), r.bumpMap && (e.bumpMap.value = r.bumpMap, 
e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, 
e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), 
r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, 
e.displacementBias.value = r.displacementBias); else if (r.isMeshDepthMtrl) t(e, r), 
r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, 
e.displacementBias.value = r.displacementBias); else if (r.isMeshDistanceMtrl) t(e, r), 
r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, 
e.displacementBias.value = r.displacementBias), e.referencePosition.value.copy(r.referencePosition), 
e.nearDistance.value = r.nearDistance, e.farDistance.value = r.farDistance; else if (r.isMeshNormalMtrl) t(e, r), 
r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), 
r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 
1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, 
e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias); else if (r.isLineBasicMtrl) e.diffuse.value.copy(r.color), 
e.opacity.value = r.opacity, r.isLineDashedMtrl && (e.dashSize.value = r.dashSize, 
e.totalSize.value = r.dashSize + r.gapSize, e.scale.value = r.scale); else if (r.isPointsMtrl) {
if (e.diffuse.value.copy(r.color), e.opacity.value = r.opacity, e.size.value = r.size * a, 
e.scale.value = .5 * o, r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), 
r.map) var s = r.map; else r.alphaMap && (s = r.alphaMap);
void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix));
} else if (r.isSpriteMtrl) {
if (e.diffuse.value.copy(r.color), e.opacity.value = r.opacity, e.rotation.value = r.rotation, 
r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), r.map) var c = r.map; else r.alphaMap && (c = r.alphaMap);
void 0 !== c && (!0 === c.matrixAutoUpdate && c.updateMatrix(), e.uvTransform.value.copy(c.matrix));
} else r.isShadowMtrl ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMtrl && (r.uniformsNeedUpdate = !1);
}
};
}(k), U = new function() {
function e(n) {
(n = n.target).removeEventListener("dispose", e), t.delete(n);
}
var t = new WeakMap();
return {
get: function(n, r) {
var i = t.get(n);
if (void 0 === i) {
var a = new ct();
t.set(n, new WeakMap()), t.get(n).set(r, a), n.addEventListener("dispose", e);
} else void 0 === (a = i.get(r)) && (a = new ct(), i.set(r, a));
return a;
},
dispose: function() {
t = new WeakMap();
}
};
}(), B = new function() {
function e(n) {
(n = n.target).removeEventListener("dispose", e), t.delete(n);
}
var t = new WeakMap();
return {
get: function(n, r) {
if (!1 === t.has(n)) {
var i = new ht();
t.set(n, new WeakMap()), t.get(n).set(r, i), n.addEventListener("dispose", e);
} else !1 === t.get(n).has(r) ? (i = new ht(), t.get(n).set(r, i)) : i = t.get(n).get(r);
return i;
},
dispose: function() {
t = new WeakMap();
}
};
}(), z = new ie(q, E, I, w), G = new function(e, t, n, r) {
var i, a = r.isWebGL2;
this.setMode = function(e) {
i = e;
}, this.render = function(t, r) {
e.drawArrays(i, t, r), n.update(r, i);
}, this.renderInstances = function(r, o, s, c) {
if (0 !== c) {
if (a) {
r = e;
var l = "drawArraysInstanced";
} else if (l = "drawArraysInstancedANGLE", null === (r = t.get("ANGLE_instanced_arrays"))) return void console.error("$3.WebGLBufferRenderer: using $3.InstancedBufferGmtr but hardware does not support extension ANGLE_instanced_arrays.");
r[l](i, o, s, c), n.update(s, i, c);
}
};
}(Ce, L, P, C), V = new function(e, t, n, r) {
var i, a, o, s = r.isWebGL2;
this.setMode = function(e) {
i = e;
}, this.setIndex = function(e) {
a = e.type, o = e.bytesPerElement;
}, this.render = function(t, r) {
e.drawElements(i, r, a, t * o), n.update(r, i);
}, this.renderInstances = function(r, c, l, u) {
if (0 !== u) {
if (s) {
r = e;
var h = "drawElementsInstanced";
} else if (h = "drawElementsInstancedANGLE", null === (r = t.get("ANGLE_instanced_arrays"))) return void console.error("$3.WebGLIndexedBufferRenderer: using $3.InstancedBufferGmtr but hardware does not support extension ANGLE_instanced_arrays.");
r[h](i, l, a, c * o, u), n.update(l, i, u);
}
};
}(Ce, L, P, C), P.programs = R.programs, q.capabilities = C, q.extensions = L, q.properties = k, 
q.renderLists = U, q.state = E, q.info = P;
}
function i(e) {
e.preventDefault(), console.log("$3.WebGLRenderer: Context Lost."), H = !0;
}
function o() {
console.log("$3.WebGLRenderer: Context Restored."), H = !1, r();
}
function s(e) {
(e = e.target).removeEventListener("dispose", s), c(e), k.remove(e);
}
function c(e) {
var t = k.get(e).program;
e.program = void 0, void 0 !== t && R.releaseProgram(t);
}
function h(e, t, n, r) {
for (var i = 0, a = e.length; i < a; i++) {
var o = e[i], s = o.object, c = o.geometry, l = void 0 === r ? o.material : r;
if (o = o.group, n.isArrayCamera) {
he = n;
for (var u = n.cameras, h = 0, p = u.length; h < p; h++) {
var f = u[h];
s.layers.test(f.layers) && (E.viewport(de.copy(f.viewport)), T.setupLights(f), d(s, t, f, c, l, o));
}
} else he = null, d(s, t, n, c, l, o);
}
}
function d(e, n, r, i, a, o) {
if (e.onBeforeRender(q, n, r, i, a, o), T = B.get(n, he || r), e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld), 
e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
var s = m(r, n, a, e);
E.setMtrl(a), ce = t = null, le = !1, function(e, t) {
e.render(function(e) {
q.renderBufferImmediate(e, t);
});
}(e, s);
} else q.renderBufferDirect(r, n, i, a, e, o);
e.onAfterRender(q, n, r, i, a, o), T = B.get(n, he || r);
}
function p(e, t, n) {
var r = k.get(e), i = T.state.lights, a = i.state.version;
n = R.getParameters(e, i.state, T.state.shadowsArray, t, Me.numPlanes, Me.numIntersection, n);
var o = R.getProgramCacheKey(n), l = r.program, u = !0;
if (void 0 === l) e.addEventListener("dispose", s); else if (l.cacheKey !== o) c(e); else {
if (r.lightsStateVersion !== a) r.lightsStateVersion = a; else if (void 0 !== n.shaderID) return;
u = !1;
}
if (u && (l = R.acquireProgram(n, o), r.program = l, r.uniforms = n.uniforms, r.outputEncoding = n.outputEncoding, 
e.program = l), n = l.getAttributes(), e.morphTargets) for (o = e.numSupportedMorphTargets = 0; o < q.maxMorphTargets; o++) 0 <= n["morphTarget" + o] && e.numSupportedMorphTargets++;
if (e.morphNormals) for (o = e.numSupportedMorphNormals = 0; o < q.maxMorphNormals; o++) 0 <= n["morphNormal" + o] && e.numSupportedMorphNormals++;
n = r.uniforms, (e.isShaderMtrl || e.isRawShaderMtrl) && !0 !== e.clipping || (r.numClippingPlanes = Me.numPlanes, 
r.numIntersection = Me.numIntersection, n.clippingPlanes = Me.uniform), r.environment = e.isMeshStandardMtrl ? t.environment : null, 
r.fog = t.fog, r.needsLights = e.isMeshLambertMtrl || e.isMeshToonMtrl || e.isMeshPhongMtrl || e.isMeshStandardMtrl || e.isShadowMtrl || e.isShaderMtrl && !0 === e.lights, 
r.lightsStateVersion = a, r.needsLights && (n.ambientLightColor.value = i.state.ambient, 
n.lightProbe.value = i.state.probe, n.directionalLights.value = i.state.directional, 
n.directionalLightShadows.value = i.state.directionalShadow, n.spotLights.value = i.state.spot, 
n.spotLightShadows.value = i.state.spotShadow, n.rectAreaLights.value = i.state.rectArea, 
n.pointLights.value = i.state.point, n.pointLightShadows.value = i.state.pointShadow, 
n.hemisphereLights.value = i.state.hemi, n.directionalShadowMap.value = i.state.directionalShadowMap, 
n.directionalShadowMatrix.value = i.state.directionalShadowMatrix, n.spotShadowMap.value = i.state.spotShadowMap, 
n.spotShadowMatrix.value = i.state.spotShadowMatrix, n.pointShadowMap.value = i.state.pointShadowMap, 
n.pointShadowMatrix.value = i.state.pointShadowMatrix), e = r.program.getUniforms(), 
e = He.seqWithValue(e.seq, n), r.uniformsList = e;
}
function m(e, t, n, r) {
O.resetTextureUnits();
var i = t.fog, a = n.isMeshStandardMtrl ? t.environment : null, o = null === Z ? q.outputEncoding : Z.texture.encoding, s = k.get(n), c = T.state.lights;
Se && (Ae || e !== ue) && Me.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, s, e === ue && n.id === re), 
n.version === s.__version ? void 0 === s.program ? p(n, t, r) : n.fog && s.fog !== i ? p(n, t, r) : s.environment !== a ? p(n, t, r) : s.needsLights && s.lightsStateVersion !== c.state.version ? p(n, t, r) : void 0 === s.numClippingPlanes || s.numClippingPlanes === Me.numPlanes && s.numIntersection === Me.numIntersection ? s.outputEncoding !== o && p(n, t, r) : p(n, t, r) : (p(n, t, r), 
s.__version = n.version);
var l = !1, u = !1, h = !1;
if (o = (t = s.program).getUniforms(), c = s.uniforms, E.useProgram(t.program) && (h = u = l = !0), 
n.id !== re && (re = n.id, u = !0), (l || ue !== e) && (o.setValue(Ce, "projectionMatrix", e.projectionMatrix), 
C.logarithmicDepthBuffer && o.setValue(Ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), 
ue !== e && (ue = e, h = u = !0), (n.isShaderMtrl || n.isMeshPhongMtrl || n.isMeshToonMtrl || n.isMeshStandardMtrl || n.envMap) && (void 0 !== (l = o.map.cameraPosition) && l.setValue(Ce, Le.setFromMatrixPosition(e.matrixWorld))), 
(n.isMeshPhongMtrl || n.isMeshToonMtrl || n.isMeshLambertMtrl || n.isMeshBasicMtrl || n.isMeshStandardMtrl || n.isShaderMtrl) && o.setValue(Ce, "isOrthographic", !0 === e.isOrthographicCamera), 
(n.isMeshPhongMtrl || n.isMeshToonMtrl || n.isMeshLambertMtrl || n.isMeshBasicMtrl || n.isMeshStandardMtrl || n.isShaderMtrl || n.skinning) && o.setValue(Ce, "viewMatrix", e.matrixWorldInverse)), 
n.skinning && (o.setOptional(Ce, r, "bindMatrix"), o.setOptional(Ce, r, "bindMatrixInverse"), 
e = r.skeleton)) if (l = e.bones, C.floatVertexTextures) {
if (void 0 === e.boneTexture) {
l = Math.sqrt(4 * l.length), l = da.ceilPowerOfTwo(l), l = Math.max(l, 4);
var d = new Float32Array(l * l * 4);
d.set(e.boneMatrices);
var f = new K(d, l, l, 1023, 1015);
e.boneMatrices = d, e.boneTexture = f, e.boneTextureSize = l;
}
o.setValue(Ce, "boneTexture", e.boneTexture, O), o.setValue(Ce, "boneTextureSize", e.boneTextureSize);
} else o.setOptional(Ce, e, "boneMatrices");
return (u || s.receiveShadow !== r.receiveShadow) && (s.receiveShadow = r.receiveShadow, 
o.setValue(Ce, "receiveShadow", r.receiveShadow)), u && (o.setValue(Ce, "toneMappingExposure", q.toneMappingExposure), 
o.setValue(Ce, "toneMappingWhitePoint", q.toneMappingWhitePoint), s.needsLights && (u = h, 
c.ambientLightColor.needsUpdate = u, c.lightProbe.needsUpdate = u, c.directionalLights.needsUpdate = u, 
c.directionalLightShadows.needsUpdate = u, c.pointLights.needsUpdate = u, c.pointLightShadows.needsUpdate = u, 
c.spotLights.needsUpdate = u, c.spotLightShadows.needsUpdate = u, c.rectAreaLights.needsUpdate = u, 
c.hemisphereLights.needsUpdate = u), i && n.fog && j.refreshFogUniforms(c, i), j.refreshMtrlUniforms(c, n, a, ve, ge), 
void 0 !== c.ltc_1 && (c.ltc_1.value = as.LTC_1), void 0 !== c.ltc_2 && (c.ltc_2.value = as.LTC_2), 
He.upload(Ce, s.uniformsList, c, O)), n.isShaderMtrl && !0 === n.uniformsNeedUpdate && (He.upload(Ce, s.uniformsList, c, O), 
n.uniformsNeedUpdate = !1), n.isSpriteMtrl && o.setValue(Ce, "center", r.center), 
o.setValue(Ce, "modelViewMatrix", r.modelViewMatrix), o.setValue(Ce, "normalMatrix", r.normalMatrix), 
o.setValue(Ce, "modelMatrix", r.matrixWorld), t;
}
var g = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), v = void 0 !== e.context ? e.context : null, y = void 0 !== e.alpha && e.alpha, $ = void 0 === e.depth || e.depth, b = void 0 === e.stencil || e.stencil, x = void 0 !== e.antialias && e.antialias, w = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, _ = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, M = void 0 !== e.powerPreference ? e.powerPreference : "default", S = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat, A = null, T = null;
this.domElement = g, this.debug = {
checkShaderErrors: !0
}, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, 
this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, 
this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, 
this.toneMappingWhitePoint = this.toneMappingExposure = 1, this.maxMorphTargets = 8, 
this.maxMorphNormals = 4;
var L, C, E, P, k, O, D, N, I, R, j, U, B, z, F, G, V, W, q = this, H = !1, X = null, Y = 0, J = 0, Z = null, ne = null, re = -1, ce = t = null, le = !1, ue = null, he = null, de = new a(), pe = new a(), fe = null, me = g.width, ge = g.height, ve = 1, ye = null, $e = null, be = new a(0, 0, me, ge), xe = new a(0, 0, me, ge), we = !1, _e = new Q(), Me = new ae(), Se = !1, Ae = !1, Te = new u(), Le = new l();
try {
y = {
alpha: y,
depth: $,
stencil: b,
antialias: x,
premultipliedAlpha: w,
preserveDrawingBuffer: _,
powerPreference: M,
failIfMajorPerformanceCaveat: S
}, g.addEventListener("webglcontextlost", i, !1), g.addEventListener("webglcontextrestored", o, !1);
var Ce = v || g.getContext("webgl", y) || g.getContext("experimental-webgl", y);
if (null === Ce) {
if (null !== g.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
throw Error("Error creating WebGL context.");
}
void 0 === Ce.getShaderPrecisionFormat && (Ce.getShaderPrecisionFormat = function() {
return {
rangeMin: 1,
rangeMax: 1,
precision: 1
};
});
} catch (e) {
throw console.error("$3.WebGLRenderer: " + e.message), e;
}
r();
var Ee = new $t(q, Ce);
this.xr = Ee;
var Pe = new ft(q, I, C.maxTextureSize);
this.shadowMap = Pe, this.getContext = function() {
return Ce;
}, this.getContextAttributes = function() {
return Ce.getContextAttributes();
}, this.forceContextLoss = function() {
var e = L.get("WEBGL_lose_context");
e && e.loseContext();
}, this.forceContextRestore = function() {
var e = L.get("WEBGL_lose_context");
e && e.restoreContext();
}, this.getPixelRatio = function() {
return ve;
}, this.setPixelRatio = function(e) {
void 0 !== e && (ve = e, this.setSize(me, ge, !1));
}, this.getSize = function(e) {
return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), 
e = new n()), e.set(me, ge);
}, this.setSize = function(e, t, n) {
Ee.isPresenting ? console.warn("$3.WebGLRenderer: Can't change size while VR device is presenting.") : (me = e, 
ge = t, g.width = Math.floor(e * ve), g.height = Math.floor(t * ve), !1 !== n && (g.style.width = e + "px", 
g.style.height = t + "px"), this.setViewport(0, 0, e, t));
}, this.getDrawingBufferSize = function(e) {
return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), 
e = new n()), e.set(me * ve, ge * ve).floor();
}, this.setDrawingBufferSize = function(e, t, n) {
me = e, ge = t, ve = n, g.width = Math.floor(e * n), g.height = Math.floor(t * n), 
this.setViewport(0, 0, e, t);
}, this.getCurrentViewport = function(e) {
return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), 
e = new a()), e.copy(de);
}, this.getViewport = function(e) {
return e.copy(be);
}, this.setViewport = function(e, t, n, r) {
e.isVector4 ? be.set(e.x, e.y, e.z, e.w) : be.set(e, t, n, r), E.viewport(de.copy(be).multiplyScalar(ve).floor());
}, this.getScissor = function(e) {
return e.copy(xe);
}, this.setScissor = function(e, t, n, r) {
e.isVector4 ? xe.set(e.x, e.y, e.z, e.w) : xe.set(e, t, n, r), E.scissor(pe.copy(xe).multiplyScalar(ve).floor());
}, this.getScissorTest = function() {
return we;
}, this.setScissorTest = function(e) {
E.setScissorTest(we = e);
}, this.setOpaqueSort = function(e) {
ye = e;
}, this.setTransparentSort = function(e) {
$e = e;
}, this.getClearColor = function() {
return z.getClearColor();
}, this.setClearColor = function() {
z.setClearColor.apply(z, arguments);
}, this.getClearAlpha = function() {
return z.getClearAlpha();
}, this.setClearAlpha = function() {
z.setClearAlpha.apply(z, arguments);
}, this.clear = function(e, t, n) {
var r = 0;
(void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === n || n) && (r |= 1024), 
Ce.clear(r);
}, this.clearColor = function() {
this.clear(!0, !1, !1);
}, this.clearDepth = function() {
this.clear(!1, !0, !1);
}, this.clearStencil = function() {
this.clear(!1, !1, !0);
}, this.dispose = function() {
g.removeEventListener("webglcontextlost", i, !1), g.removeEventListener("webglcontextrestored", o, !1), 
U.dispose(), B.dispose(), k.dispose(), I.dispose(), Ee.dispose(), De.stop();
}, this.renderBufferImmediate = function(e, t) {
E.initAttributes();
var n = k.get(e);
e.hasPositions && !n.position && (n.position = Ce.createBuffer()), e.hasNormals && !n.normal && (n.normal = Ce.createBuffer()), 
e.hasUvs && !n.uv && (n.uv = Ce.createBuffer()), e.hasColors && !n.color && (n.color = Ce.createBuffer()), 
t = t.getAttributes(), e.hasPositions && (Ce.bindBuffer(34962, n.position), Ce.bufferData(34962, e.positionArray, 35048), 
E.enableAttribute(t.position), Ce.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), 
e.hasNormals && (Ce.bindBuffer(34962, n.normal), Ce.bufferData(34962, e.normalArray, 35048), 
E.enableAttribute(t.normal), Ce.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), 
e.hasUvs && (Ce.bindBuffer(34962, n.uv), Ce.bufferData(34962, e.uvArray, 35048), 
E.enableAttribute(t.uv), Ce.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (Ce.bindBuffer(34962, n.color), 
Ce.bufferData(34962, e.colorArray, 35048), E.enableAttribute(t.color), Ce.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), 
E.disableUnusedAttributes(), Ce.drawArrays(4, 0, e.count), e.count = 0;
};
var ke = new f();
this.renderBufferDirect = function(e, n, r, i, a, o) {
null === n && (n = ke);
var s = a.isMesh && 0 > a.matrixWorld.determinant(), c = m(e, n, i, a);
E.setMtrl(i, s);
var l = !1;
if (t === r.id && ce === c.id && le === (!0 === i.wireframe) || (t = r.id, ce = c.id, 
le = !0 === i.wireframe, l = !0), (i.morphTargets || i.morphNormals) && (F.update(a, r, i, c), 
l = !0), !0 === a.isInstancedMesh && (l = !0), e = r.index, n = r.attributes.position, 
null === e) {
if (void 0 === n || 0 === n.count) return;
} else if (0 === e.count) return;
var u = 1;
if (!0 === i.wireframe && (e = N.getWireframeAttribute(r), u = 2), s = G, null !== e) {
var h = D.get(e);
(s = V).setIndex(h);
}
if (l) {
if (!1 !== C.isWebGL2 || !a.isInstancedMesh && !r.isInstancedBufferGmtr || null !== L.get("ANGLE_instanced_arrays")) {
E.initAttributes(), l = r.attributes, c = c.getAttributes();
var d = i.defaultAttributeValues;
for (_ in c) {
var p = c[_];
if (0 <= p) {
var f = l[_];
if (void 0 !== f) {
var g = f.normalized, v = f.itemSize, y = D.get(f);
if (void 0 !== y) {
var $ = y.buffer, b = y.type;
if (y = y.bytesPerElement, f.isInterleavedBufferAttribute) {
var x = f.data, w = x.stride;
f = f.offset, x && x.isInstancedInterleavedBuffer ? (E.enableAttributeAndDivisor(p, x.meshPerAttribute), 
void 0 === r._maxInstanceCount && (r._maxInstanceCount = x.meshPerAttribute * x.count)) : E.enableAttribute(p), 
Ce.bindBuffer(34962, $), E.vertexAttribPointer(p, v, b, g, w * y, f * y);
} else f.isInstancedBufferAttribute ? (E.enableAttributeAndDivisor(p, f.meshPerAttribute), 
void 0 === r._maxInstanceCount && (r._maxInstanceCount = f.meshPerAttribute * f.count)) : E.enableAttribute(p), 
Ce.bindBuffer(34962, $), E.vertexAttribPointer(p, v, b, g, 0, 0);
}
} else if ("instanceMatrix" === _) void 0 !== (v = D.get(a.instanceMatrix)) && (g = v.buffer, 
v = v.type, E.enableAttributeAndDivisor(p + 0, 1), E.enableAttributeAndDivisor(p + 1, 1), 
E.enableAttributeAndDivisor(p + 2, 1), E.enableAttributeAndDivisor(p + 3, 1), Ce.bindBuffer(34962, g), 
Ce.vertexAttribPointer(p + 0, 4, v, !1, 64, 0), Ce.vertexAttribPointer(p + 1, 4, v, !1, 64, 16), 
Ce.vertexAttribPointer(p + 2, 4, v, !1, 64, 32), Ce.vertexAttribPointer(p + 3, 4, v, !1, 64, 48)); else if (void 0 !== d && void 0 !== (g = d[_])) switch (g.length) {
case 2:
Ce.vertexAttrib2fv(p, g);
break;

case 3:
Ce.vertexAttrib3fv(p, g);
break;

case 4:
Ce.vertexAttrib4fv(p, g);
break;

default:
Ce.vertexAttrib1fv(p, g);
}
}
}
E.disableUnusedAttributes();
}
null !== e && Ce.bindBuffer(34963, h.buffer);
}
var _ = r.drawRange.start * u;
l = null !== o ? o.start * u : 0, h = Math.max(_, l), 0 !== (o = Math.max(0, Math.min(null !== e ? e.count : n.count, _ + r.drawRange.count * u, l + (null !== o ? o.count * u : 1 / 0)) - 1 - h + 1)) && (a.isMesh ? !0 === i.wireframe ? (E.setLineWidth(i.wireframeLinewidth * (null === Z ? ve : 1)), 
s.setMode(1)) : s.setMode(4) : a.isLine ? (void 0 === (i = i.linewidth) && (i = 1), 
E.setLineWidth(i * (null === Z ? ve : 1)), a.isLineSegments ? s.setMode(1) : a.isLineLoop ? s.setMode(2) : s.setMode(3)) : a.isPoints ? s.setMode(0) : a.isSprite && s.setMode(4), 
a.isInstancedMesh ? s.renderInstances(r, h, o, a.count) : r.isInstancedBufferGmtr ? s.renderInstances(r, h, o, Math.min(r.instanceCount, r._maxInstanceCount)) : s.render(h, o));
}, this.compile = function(e, t) {
(T = B.get(e, t)).init(), e.traverse(function(e) {
e.isLight && (T.pushLight(e), e.castShadow && T.pushShadow(e));
}), T.setupLights(t);
var n = {};
e.traverse(function(t) {
var r = t.material;
if (r) if (Array.isArray(r)) for (var i = 0; i < r.length; i++) {
var a = r[i];
!1 == a.uuid in n && (p(a, e, t), n[a.uuid] = !0);
} else !1 == r.uuid in n && (p(r, e, t), n[r.uuid] = !0);
});
};
var Oe = null, De = new ee();
De.setAnimationLoop(function(e) {
Ee.isPresenting || Oe && Oe(e);
}), "undefined" != typeof window && De.setContext(window), this.setAnimationLoop = function(e) {
Oe = e, Ee.setAnimationLoop(e), De.start();
}, this.render = function(e, n, r, i) {
if (void 0 !== r) {
console.warn("$3.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
var a = r;
}
if (void 0 !== i) {
console.warn("$3.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
var o = i;
}
n && n.isCamera ? H || (ce = t = null, le = !1, re = -1, ue = null, !0 === e.autoUpdate && e.updateMatrixWorld(), 
null === n.parent && n.updateMatrixWorld(), Ee.enabled && Ee.isPresenting && (n = Ee.getCamera(n)), 
e.isScene && e.onBeforeRender(q, e, n, a || Z), (T = B.get(e, n)).init(), Te.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), 
_e.setFromProjectionMatrix(Te), Ae = this.localClippingEnabled, Se = Me.init(this.clippingPlanes, Ae, n), 
(A = U.get(e, n)).init(), function e(t, n, r, i) {
if (!1 !== t.visible) {
if (t.layers.test(n.layers)) if (t.isGroup) r = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(n); else if (t.isLight) T.pushLight(t), 
t.castShadow && T.pushShadow(t); else if (t.isSprite) {
if (!t.frustumCulled || _e.intersectsSprite(t)) {
i && Le.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Te);
var a = I.update(t), o = t.material;
o.visible && A.push(t, a, o, r, Le.z, null);
}
} else if (t.isImmediateRenderObject) i && Le.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Te), 
A.push(t, null, t.material, r, Le.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== P.render.frame && (t.skeleton.update(), 
t.skeleton.frame = P.render.frame), !t.frustumCulled || _e.intersectsObject(t))) if (i && Le.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Te), 
a = I.update(t), o = t.material, Array.isArray(o)) for (var s = a.groups, c = 0, l = s.length; c < l; c++) {
var u = s[c], h = o[u.materialIndex];
h && h.visible && A.push(t, a, h, r, Le.z, u);
} else o.visible && A.push(t, a, o, r, Le.z, null);
for (a = 0, o = (t = t.children).length; a < o; a++) e(t[a], n, r, i);
}
}(e, n, 0, q.sortObjects), A.finish(), !0 === q.sortObjects && A.sort(ye, $e), Se && Me.beginShadows(), 
Pe.render(T.state.shadowsArray, e, n), T.setupLights(n), Se && Me.endShadows(), 
this.info.autoReset && this.info.reset(), void 0 !== a && this.setRenderTarget(a), 
z.render(A, e, n, o), r = A.opaque, i = A.transparent, e.overrideMtrl ? (a = e.overrideMtrl, 
r.length && h(r, e, n, a), i.length && h(i, e, n, a)) : (r.length && h(r, e, n), 
i.length && h(i, e, n)), e.isScene && e.onAfterRender(q, e, n), null !== Z && (O.updateRenderTargetMipmap(Z), 
O.updateMultisampleRenderTarget(Z)), E.buffers.depth.setTest(!0), E.buffers.depth.setMask(!0), 
E.buffers.color.setMask(!0), E.setPolygonOffset(!1), T = A = null) : console.error("$3.WebGLRenderer.render: camera is not an instance of $3.Camera.");
}, this.setFramebuffer = function(e) {
X !== e && null === Z && Ce.bindFramebuffer(36160, e), X = e;
}, this.getActiveCubeFace = function() {
return Y;
}, this.getActiveMipmapLevel = function() {
return J;
}, this.getRenderTarget = function() {
return Z;
}, this.setRenderTarget = function(e, t, n) {
Z = e, Y = t, J = n, e && void 0 === k.get(e).__webglFramebuffer && O.setupRenderTarget(e);
var r = X, i = !1;
e ? (r = k.get(e).__webglFramebuffer, e.isWebGLCubeRenderTarget ? (r = r[t || 0], 
i = !0) : r = e.isWebGLMultisampleRenderTarget ? k.get(e).__webglMultisampledFramebuffer : r, 
de.copy(e.viewport), pe.copy(e.scissor), fe = e.scissorTest) : (de.copy(be).multiplyScalar(ve).floor(), 
pe.copy(xe).multiplyScalar(ve).floor(), fe = we), ne !== r && (Ce.bindFramebuffer(36160, r), 
ne = r), E.viewport(de), E.scissor(pe), E.setScissorTest(fe), i && (e = k.get(e.texture), 
Ce.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, n || 0));
}, this.readRenderTargetPixels = function(e, t, n, r, i, a, o) {
if (e && e.isWebGLRenderTarget) {
var s = k.get(e).__webglFramebuffer;
if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
o = !1, s !== ne && (Ce.bindFramebuffer(36160, s), o = !0);
try {
var c = e.texture, l = c.format, u = c.type;
1023 !== l && W.convert(l) !== Ce.getParameter(35739) ? console.error("$3.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === u || W.convert(u) === Ce.getParameter(35738) || 1015 === u && (C.isWebGL2 || L.get("OES_texture_float") || L.get("WEBGL_color_buffer_float")) || 1016 === u && (C.isWebGL2 ? L.get("EXT_color_buffer_float") : L.get("EXT_color_buffer_half_float")) ? 36053 === Ce.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && Ce.readPixels(t, n, r, i, W.convert(l), W.convert(u), a) : console.error("$3.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("$3.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
} finally {
o && Ce.bindFramebuffer(36160, ne);
}
}
} else console.error("$3.WebGLRenderer.readRenderTargetPixels: renderTarget is not $3.WebGLRenderTarget.");
}, this.copyFramebufferToTexture = function(e, t, n) {
void 0 === n && (n = 0);
var r = Math.pow(2, -n), i = Math.floor(t.image.width * r);
r = Math.floor(t.image.height * r);
var a = W.convert(t.format);
O.setTexture2D(t, 0), Ce.copyTexImage2D(3553, n, a, e.x, e.y, i, r, 0), E.unbindTexture();
}, this.copyTextureToTexture = function(e, t, n, r) {
void 0 === r && (r = 0);
var i = t.image.width, a = t.image.height, o = W.convert(n.format), s = W.convert(n.type);
O.setTexture2D(n, 0), t.isDataTexture ? Ce.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? Ce.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : Ce.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 
0 === r && n.generateMipmaps && Ce.generateMipmap(3553), E.unbindTexture();
}, this.initTexture = function(e) {
O.setTexture2D(e, 0), E.unbindTexture();
}, "undefined" != typeof __$3_DEVTOOLS__ && __$3_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
detail: this
}));
}
function xt(e, t) {
this.name = "", this.color = new x(e), this.density = void 0 !== t ? t : 25e-5;
}
function wt(e, t, n) {
this.name = "", this.color = new x(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3;
}
function _t(e, t) {
this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, 
this.updateRange = {
offset: 0,
count: -1
}, this.version = 0, this.uuid = da.generateUUID();
}
function Mt(e, t, n, r) {
this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r;
}
function St(e) {
A.call(this), this.type = "SpriteMtrl", this.color = new x(16777215), this.alphaMap = this.map = null, 
this.rotation = 0, this.transparent = this.sizeAttenuation = !0, this.setValues(e);
}
function At(e) {
if (p.call(this), this.type = "Sprite", void 0 === Ms) {
Ms = new B();
var t = new Float32Array([ -.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1 ]);
t = new _t(t, 5), Ms.setIndex([ 0, 1, 2, 0, 2, 3 ]), Ms.setAttribute("position", new Mt(t, 3, 0, !1)), 
Ms.setAttribute("uv", new Mt(t, 2, 3, !1));
}
this.geometry = Ms, this.material = void 0 !== e ? e : new St(), this.center = new n(.5, .5);
}
function Tt(e, t, n, r, i, a) {
Ls.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Cs.x = a * Ls.x - i * Ls.y, 
Cs.y = i * Ls.x + a * Ls.y) : Cs.copy(Ls), e.copy(t), e.x += Cs.x, e.y += Cs.y, 
e.applyMatrix4(Es);
}
function Lt() {
p.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
levels: {
enumerable: !0,
value: []
}
}), this.autoUpdate = !0;
}
function Ct(e, t) {
e && e.isGmtr && console.error("$3.SkinnedMesh no longer supports $3.Gmtr. Use $3.BufferGmtr instead."), 
z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new u(), 
this.bindMatrixInverse = new u();
}
function Et(e, t) {
if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), 
this.frame = -1, void 0 === t) this.calculateInverses(); else if (this.bones.length === t.length) this.boneInverses = t.slice(0); else for (console.warn("$3.Skeleton boneInverses is the wrong length."), 
this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new u());
}
function Pt() {
p.call(this), this.type = "Bone";
}
function kt(e, t, n) {
z.call(this, e, t), this.instanceMatrix = new L(new Float32Array(16 * n), 16), this.count = n, 
this.frustumCulled = !1;
}
function Ot(e) {
A.call(this), this.type = "LineBasicMtrl", this.color = new x(16777215), this.linewidth = 1, 
this.linejoin = this.linecap = "round", this.morphTargets = !1, this.setValues(e);
}
function Dt(e, t, n) {
1 === n && console.error("$3.Line: parameter $3.LinePieces no longer supported. Use $3.LineSegments instead."), 
p.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new B(), this.material = void 0 !== t ? t : new Ot(), 
this.updateMorphTargets();
}
function Nt(e, t) {
Dt.call(this, e, t), this.type = "LineSegments";
}
function It(e, t) {
Dt.call(this, e, t), this.type = "LineLoop";
}
function Rt(e) {
A.call(this), this.type = "PointsMtrl", this.color = new x(16777215), this.alphaMap = this.map = null, 
this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e);
}
function jt(e, t) {
p.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new B(), 
this.material = void 0 !== t ? t : new Rt(), this.updateMorphTargets();
}
function Ut(e, t, n, r, i, a, o) {
var s = ic.distanceSqToPoint(e);
s < n && (n = new l(), ic.closestPointToPoint(e, n), n.applyMatrix4(r), (e = i.ray.origin.distanceTo(n)) < i.near || e > i.far || a.push({
distance: e,
distanceToRay: Math.sqrt(s),
point: n,
index: t,
face: null,
object: o
}));
}
function Bt(e, t, n, r, a, o, s, c, l) {
i.call(this, e, t, n, r, a, o, s, c, l), this.format = void 0 !== s ? s : 1022, 
this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== a ? a : 1006, 
this.generateMipmaps = !1;
}
function zt(e, t, n, r, a, o, s, c, l, u, h, d) {
i.call(this, null, o, s, c, l, u, r, a, h, d), this.image = {
width: t,
height: n
}, this.mipmaps = e, this.generateMipmaps = this.flipY = !1;
}
function Ft(e, t, n, r, a, o, s, c, l) {
i.call(this, e, t, n, r, a, o, s, c, l), this.needsUpdate = !0;
}
function Gt(e, t, n, r, a, o, s, c, l, u) {
if (1026 !== (u = void 0 !== u ? u : 1026) && 1027 !== u) throw Error("DepthTexture format must be either $3.DepthFormat or $3.DepthStencilFormat");
void 0 === n && 1026 === u && (n = 1012), void 0 === n && 1027 === u && (n = 1020), 
i.call(this, null, r, a, o, s, c, u, n, l), this.image = {
width: e,
height: t
}, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== c ? c : 1003, 
this.generateMipmaps = this.flipY = !1;
}
function Vt(e) {
B.call(this), this.type = "WireframeGmtr";
var t = [], n = [ 0, 0 ], r = {}, i = [ "a", "b", "c" ];
if (e && e.isGmtr) {
for (var a = e.faces, o = 0, s = a.length; o < s; o++) for (var c = a[o], u = 0; 3 > u; u++) {
var h = c[i[u]], d = c[i[(u + 1) % 3]];
n[0] = Math.min(h, d), n[1] = Math.max(h, d), void 0 === r[h = n[0] + "," + n[1]] && (r[h] = {
index1: n[0],
index2: n[1]
});
}
for (var p in r) n = r[p], a = e.vertices[n.index1], t.push(a.x, a.y, a.z), a = e.vertices[n.index2], 
t.push(a.x, a.y, a.z);
} else if (e && e.isBufferGmtr) if (p = new l(), null !== e.index) {
for (i = e.attributes.position, o = e.index, 0 === (e = e.groups).length && (e = [ {
start: 0,
count: o.count,
materialIndex: 0
} ]), s = 0, c = e.length; s < c; ++s) for (u = d = (h = e[s]).start, h = d + h.count; u < h; u += 3) for (d = 0; 3 > d; d++) {
var f = o.getX(u + d), m = o.getX(u + (d + 1) % 3);
n[0] = Math.min(f, m), n[1] = Math.max(f, m), void 0 === r[f = n[0] + "," + n[1]] && (r[f] = {
index1: n[0],
index2: n[1]
});
}
for (a in r) n = r[a], p.fromBufferAttribute(i, n.index1), t.push(p.x, p.y, p.z), 
p.fromBufferAttribute(i, n.index2), t.push(p.x, p.y, p.z);
} else for (n = 0, a = (r = e.attributes.position).count / 3; n < a; n++) for (e = 0; 3 > e; e++) p.fromBufferAttribute(r, 3 * n + e), 
t.push(p.x, p.y, p.z), p.fromBufferAttribute(r, 3 * n + (e + 1) % 3), t.push(p.x, p.y, p.z);
this.setAttribute("position", new I(t, 3));
}
function Wt(e, t, n) {
V.call(this), this.type = "ParametricGmtr", this.parameters = {
func: e,
slices: t,
stacks: n
}, this.fromBufferGmtr(new qt(e, t, n)), this.mergeVertices();
}
function qt(e, t, n) {
B.call(this), this.type = "ParametricBufferGmtr", this.parameters = {
func: e,
slices: t,
stacks: n
};
var r = [], i = [], a = [], o = [], s = new l(), c = new l(), u = new l(), h = new l(), d = new l();
3 > e.length && console.error("$3.ParametricGmtr: Function must now modify a Vector3 as third parameter.");
for (var p = t + 1, f = 0; f <= n; f++) for (var m = f / n, g = 0; g <= t; g++) {
var v = g / t;
e(v, m, c), i.push(c.x, c.y, c.z), 0 <= v - 1e-5 ? (e(v - 1e-5, m, u), h.subVectors(c, u)) : (e(v + 1e-5, m, u), 
h.subVectors(u, c)), 0 <= m - 1e-5 ? (e(v, m - 1e-5, u), d.subVectors(c, u)) : (e(v, m + 1e-5, u), 
d.subVectors(u, c)), s.crossVectors(h, d).normalize(), a.push(s.x, s.y, s.z), o.push(v, m);
}
for (e = 0; e < n; e++) for (s = 0; s < t; s++) c = e * p + s + 1, u = (e + 1) * p + s + 1, 
h = (e + 1) * p + s, r.push(e * p + s, c, h), r.push(c, u, h);
this.setIndex(r), this.setAttribute("position", new I(i, 3)), this.setAttribute("normal", new I(a, 3)), 
this.setAttribute("uv", new I(o, 2));
}
function Ht(e, t, n, r) {
V.call(this), this.type = "PolyhedronGmtr", this.parameters = {
vertices: e,
indices: t,
radius: n,
detail: r
}, this.fromBufferGmtr(new Xt(e, t, n, r)), this.mergeVertices();
}
function Xt(e, t, r, i) {
function a(e) {
c.push(e.x, e.y, e.z);
}
function o(t, n) {
t *= 3, n.x = e[t + 0], n.y = e[t + 1], n.z = e[t + 2];
}
function s(e, t, n, r) {
0 > r && 1 === e.x && (u[t] = e.x - 1), 0 === n.x && 0 === n.z && (u[t] = r / 2 / Math.PI + .5);
}
B.call(this), this.type = "PolyhedronBufferGmtr", this.parameters = {
vertices: e,
indices: t,
radius: r,
detail: i
}, r = r || 1;
var c = [], u = [];
!function(e) {
for (var n = new l(), r = new l(), i = new l(), s = 0; s < t.length; s += 3) {
o(t[s + 0], n), o(t[s + 1], r), o(t[s + 2], i);
for (var c = n, u = r, h = i, d = Math.pow(2, e), p = [], f = 0; f <= d; f++) {
p[f] = [];
for (var m = c.clone().lerp(h, f / d), g = u.clone().lerp(h, f / d), v = d - f, y = 0; y <= v; y++) p[f][y] = 0 === y && f === d ? m : m.clone().lerp(g, y / v);
}
for (c = 0; c < d; c++) for (u = 0; u < 2 * (d - c) - 1; u++) h = Math.floor(u / 2), 
0 == u % 2 ? (a(p[c][h + 1]), a(p[c + 1][h]), a(p[c][h])) : (a(p[c][h + 1]), a(p[c + 1][h + 1]), 
a(p[c + 1][h]));
}
}(i = i || 0), function(e) {
for (var t = new l(), n = 0; n < c.length; n += 3) t.x = c[n + 0], t.y = c[n + 1], 
t.z = c[n + 2], t.normalize().multiplyScalar(e), c[n + 0] = t.x, c[n + 1] = t.y, 
c[n + 2] = t.z;
}(r), function() {
for (var e = new l(), t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], 
e.z = c[t + 2], u.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
e = new l(), t = new l();
for (var r = new l(), i = new l(), a = new n(), o = new n(), h = new n(), d = 0, p = 0; d < c.length; d += 9, 
p += 6) {
e.set(c[d + 0], c[d + 1], c[d + 2]), t.set(c[d + 3], c[d + 4], c[d + 5]), r.set(c[d + 6], c[d + 7], c[d + 8]), 
a.set(u[p + 0], u[p + 1]), o.set(u[p + 2], u[p + 3]), h.set(u[p + 4], u[p + 5]), 
i.copy(e).add(t).add(r).divideScalar(3);
var f = Math.atan2(i.z, -i.x);
s(a, p + 0, e, f), s(o, p + 2, t, f), s(h, p + 4, r, f);
}
for (e = 0; e < u.length; e += 6) t = u[e + 0], r = u[e + 2], i = u[e + 4], a = Math.min(t, r, i), 
.9 < Math.max(t, r, i) && .1 > a && (.2 > t && (u[e + 0] += 1), .2 > r && (u[e + 2] += 1), 
.2 > i && (u[e + 4] += 1));
}(), this.setAttribute("position", new I(c, 3)), this.setAttribute("normal", new I(c.slice(), 3)), 
this.setAttribute("uv", new I(u, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals();
}
function Yt(e, t) {
V.call(this), this.type = "TetrahedronGmtr", this.parameters = {
radius: e,
detail: t
}, this.fromBufferGmtr(new Jt(e, t)), this.mergeVertices();
}
function Jt(e, t) {
Xt.call(this, [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], e, t), 
this.type = "TetrahedronBufferGmtr", this.parameters = {
radius: e,
detail: t
};
}
function Zt(e, t) {
V.call(this), this.type = "OctahedronGmtr", this.parameters = {
radius: e,
detail: t
}, this.fromBufferGmtr(new Kt(e, t)), this.mergeVertices();
}
function Kt(e, t) {
Xt.call(this, [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], e, t), 
this.type = "OctahedronBufferGmtr", this.parameters = {
radius: e,
detail: t
};
}
function Qt(e, t) {
V.call(this), this.type = "IcosahedronGmtr", this.parameters = {
radius: e,
detail: t
}, this.fromBufferGmtr(new en(e, t)), this.mergeVertices();
}
function en(e, t) {
var n = (1 + Math.sqrt(5)) / 2;
Xt.call(this, [ -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], e, t), 
this.type = "IcosahedronBufferGmtr", this.parameters = {
radius: e,
detail: t
};
}
function tn(e, t) {
V.call(this), this.type = "DodecahedronGmtr", this.parameters = {
radius: e,
detail: t
}, this.fromBufferGmtr(new nn(e, t)), this.mergeVertices();
}
function nn(e, t) {
var n = (1 + Math.sqrt(5)) / 2, r = 1 / n;
Xt.call(this, [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], e, t), 
this.type = "DodecahedronBufferGmtr", this.parameters = {
radius: e,
detail: t
};
}
function rn(e, t, n, r, i, a) {
V.call(this), this.type = "TubeGmtr", this.parameters = {
path: e,
tubularSegments: t,
radius: n,
radialSegments: r,
closed: i
}, void 0 !== a && console.warn("$3.TubeGmtr: taper has been removed."), e = new an(e, t, n, r, i), 
this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, 
this.fromBufferGmtr(e), this.mergeVertices();
}
function an(e, t, r, i, a) {
function o(n) {
d = e.getPointAt(n / t, d);
var a = s.normals[n];
n = s.binormals[n];
for (var o = 0; o <= i; o++) {
var l = o / i * Math.PI * 2, h = Math.sin(l);
l = -Math.cos(l), u.x = l * a.x + h * n.x, u.y = l * a.y + h * n.y, u.z = l * a.z + h * n.z, 
u.normalize(), f.push(u.x, u.y, u.z), c.x = d.x + r * u.x, c.y = d.y + r * u.y, 
c.z = d.z + r * u.z, p.push(c.x, c.y, c.z);
}
}
B.call(this), this.type = "TubeBufferGmtr", this.parameters = {
path: e,
tubularSegments: t,
radius: r,
radialSegments: i,
closed: a
}, t = t || 64, r = r || 1, i = i || 8, a = a || !1;
var s = e.computeFrenetFrames(t, a);
this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
var c = new l(), u = new l(), h = new n(), d = new l(), p = [], f = [], m = [], g = [];
!function() {
for (var e = 0; e < t; e++) o(e);
for (o(!1 === a ? t : 0), e = 0; e <= t; e++) for (var n = 0; n <= i; n++) h.x = e / t, 
h.y = n / i, m.push(h.x, h.y);
for (e = 1; e <= t; e++) for (n = 1; n <= i; n++) {
var r = (i + 1) * e + (n - 1), s = (i + 1) * e + n, c = (i + 1) * (e - 1) + n;
g.push((i + 1) * (e - 1) + (n - 1), r, c), g.push(r, s, c);
}
}(), this.setIndex(g), this.setAttribute("position", new I(p, 3)), this.setAttribute("normal", new I(f, 3)), 
this.setAttribute("uv", new I(m, 2));
}
function on(e, t, n, r, i, a, o) {
V.call(this), this.type = "TorusKnotGmtr", this.parameters = {
radius: e,
tube: t,
tubularSegments: n,
radialSegments: r,
p: i,
q: a
}, void 0 !== o && console.warn("$3.TorusKnotGmtr: heightScale has been deprecated. Use .scale( x, y, z ) instead."), 
this.fromBufferGmtr(new sn(e, t, n, r, i, a)), this.mergeVertices();
}
function sn(e, t, n, r, i, a) {
function o(e, t, n, r, i) {
var a = Math.sin(e);
t = n / t * e, n = Math.cos(t), i.x = r * (2 + n) * .5 * Math.cos(e), i.y = r * (2 + n) * a * .5, 
i.z = r * Math.sin(t) * .5;
}
B.call(this), this.type = "TorusKnotBufferGmtr", this.parameters = {
radius: e,
tube: t,
tubularSegments: n,
radialSegments: r,
p: i,
q: a
}, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, 
a = a || 3;
for (var s = [], c = [], u = [], h = [], d = new l(), p = new l(), f = new l(), m = new l(), g = new l(), v = new l(), y = new l(), $ = 0; $ <= n; ++$) {
var b = $ / n * i * Math.PI * 2;
for (o(b, i, a, e, f), o(b + .01, i, a, e, m), v.subVectors(m, f), y.addVectors(m, f), 
g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), b = 0; b <= r; ++b) {
var x = b / r * Math.PI * 2, w = -t * Math.cos(x);
x = t * Math.sin(x), d.x = f.x + (w * y.x + x * g.x), d.y = f.y + (w * y.y + x * g.y), 
d.z = f.z + (w * y.z + x * g.z), c.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), 
u.push(p.x, p.y, p.z), h.push($ / n), h.push(b / r);
}
}
for (e = 1; e <= n; e++) for (t = 1; t <= r; t++) i = (r + 1) * e + (t - 1), a = (r + 1) * e + t, 
d = (r + 1) * (e - 1) + t, s.push((r + 1) * (e - 1) + (t - 1), i, d), s.push(i, a, d);
this.setIndex(s), this.setAttribute("position", new I(c, 3)), this.setAttribute("normal", new I(u, 3)), 
this.setAttribute("uv", new I(h, 2));
}
function cn(e, t, n, r, i) {
V.call(this), this.type = "TorusGmtr", this.parameters = {
radius: e,
tube: t,
radialSegments: n,
tubularSegments: r,
arc: i
}, this.fromBufferGmtr(new ln(e, t, n, r, i)), this.mergeVertices();
}
function ln(e, t, n, r, i) {
B.call(this), this.type = "TorusBufferGmtr", this.parameters = {
radius: e,
tube: t,
radialSegments: n,
tubularSegments: r,
arc: i
}, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
for (var a = [], o = [], s = [], c = [], u = new l(), h = new l(), d = new l(), p = 0; p <= n; p++) for (var f = 0; f <= r; f++) {
var m = f / r * i, g = p / n * Math.PI * 2;
h.x = (e + t * Math.cos(g)) * Math.cos(m), h.y = (e + t * Math.cos(g)) * Math.sin(m), 
h.z = t * Math.sin(g), o.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), 
d.subVectors(h, u).normalize(), s.push(d.x, d.y, d.z), c.push(f / r), c.push(p / n);
}
for (e = 1; e <= n; e++) for (t = 1; t <= r; t++) i = (r + 1) * (e - 1) + t - 1, 
u = (r + 1) * (e - 1) + t, h = (r + 1) * e + t, a.push((r + 1) * e + t - 1, i, h), 
a.push(i, u, h);
this.setIndex(a), this.setAttribute("position", new I(o, 3)), this.setAttribute("normal", new I(s, 3)), 
this.setAttribute("uv", new I(c, 2));
}
function un(e, t, n, r, i) {
for (var a, o = 0, s = t, c = n - r; s < n; s += r) o += (e[c] - e[s]) * (e[s + 1] + e[c + 1]), 
c = s;
if (i === 0 < o) for (i = t; i < n; i += r) a = Sn(i, e[i], e[i + 1], a); else for (i = n - r; i >= t; i -= r) a = Sn(i, e[i], e[i + 1], a);
return a && $n(a, a.next) && (An(a), a = a.next), a;
}
function hn(e, t) {
if (!e) return e;
t || (t = e);
do {
var n = !1;
if (e.steiner || !$n(e, e.next) && 0 !== yn(e.prev, e, e.next)) e = e.next; else {
if (An(e), (e = t = e.prev) === e.next) break;
n = !0;
}
} while (n || e !== t);
return t;
}
function dn(e, t, n, r) {
var i = e.prev, a = e.next;
if (0 <= yn(i, e, a)) return !1;
var o = i.x > e.x ? i.x > a.x ? i.x : a.x : e.x > a.x ? e.x : a.x, s = i.y > e.y ? i.y > a.y ? i.y : a.y : e.y > a.y ? e.y : a.y, c = mn(i.x < e.x ? i.x < a.x ? i.x : a.x : e.x < a.x ? e.x : a.x, i.y < e.y ? i.y < a.y ? i.y : a.y : e.y < a.y ? e.y : a.y, t, n, r);
for (t = mn(o, s, t, n, r), n = e.prevZ, r = e.nextZ; n && n.z >= c && r && r.z <= t; ) {
if (n !== e.prev && n !== e.next && vn(i.x, i.y, e.x, e.y, a.x, a.y, n.x, n.y) && 0 <= yn(n.prev, n, n.next)) return !1;
if (n = n.prevZ, r !== e.prev && r !== e.next && vn(i.x, i.y, e.x, e.y, a.x, a.y, r.x, r.y) && 0 <= yn(r.prev, r, r.next)) return !1;
r = r.nextZ;
}
for (;n && n.z >= c; ) {
if (n !== e.prev && n !== e.next && vn(i.x, i.y, e.x, e.y, a.x, a.y, n.x, n.y) && 0 <= yn(n.prev, n, n.next)) return !1;
n = n.prevZ;
}
for (;r && r.z <= t; ) {
if (r !== e.prev && r !== e.next && vn(i.x, i.y, e.x, e.y, a.x, a.y, r.x, r.y) && 0 <= yn(r.prev, r, r.next)) return !1;
r = r.nextZ;
}
return !0;
}
function pn(e, t) {
return e.x - t.x;
}
function fn(e, t) {
var n = t, r = e.x, i = e.y, a = -1 / 0;
do {
if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
var o = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
if (o <= r && o > a) {
if (a = o, o === r) {
if (i === n.y) return n;
if (i === n.next.y) return n.next;
}
var s = n.x < n.next.x ? n : n.next;
}
}
n = n.next;
} while (n !== t);
if (!s) return null;
if (r === a) return s;
t = s, o = s.x;
var c = s.y, l = 1 / 0;
n = s;
do {
if (r >= n.x && n.x >= o && r !== n.x && vn(i < c ? r : a, i, o, c, i < c ? a : r, i, n.x, n.y)) {
var u, h = Math.abs(i - n.y) / (r - n.x);
if ((u = _n(n, e)) && !(u = h < l) && (u = h === l) && !(u = n.x > s.x) && (u = n.x === s.x)) {
var d = n;
u = 0 > yn((u = s).prev, u, d.prev) && 0 > yn(d.next, u, u.next);
}
u && (s = n, l = h);
}
n = n.next;
} while (n !== t);
return s;
}
function mn(e, t, n, r, i) {
return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
}
function gn(e) {
var t = e, n = e;
do {
(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
} while (t !== e);
return n;
}
function vn(e, t, n, r, i, a, o, s) {
return 0 <= (i - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (r - s) - (n - o) * (t - s) && 0 <= (n - o) * (a - s) - (i - o) * (r - s);
}
function yn(e, t, n) {
return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
}
function $n(e, t) {
return e.x === t.x && e.y === t.y;
}
function bn(e, t, n, r) {
var i = wn(yn(e, t, n)), a = wn(yn(e, t, r)), o = wn(yn(n, r, e)), s = wn(yn(n, r, t));
return !!(i !== a && o !== s || 0 === i && xn(e, n, t) || 0 === a && xn(e, r, t) || 0 === o && xn(n, e, r) || 0 === s && xn(n, t, r));
}
function xn(e, t, n) {
return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);
}
function wn(e) {
return 0 < e ? 1 : 0 > e ? -1 : 0;
}
function _n(e, t) {
return 0 > yn(e.prev, e, e.next) ? 0 <= yn(e, t, e.next) && 0 <= yn(e, e.prev, t) : 0 > yn(e, t, e.prev) || 0 > yn(e, e.next, t);
}
function Mn(e, t) {
var n = new Tn(e.i, e.x, e.y), r = new Tn(t.i, t.x, t.y), i = e.next, a = t.prev;
return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, 
r.prev = a, r;
}
function Sn(e, t, n, r) {
return e = new Tn(e, t, n), r ? (e.next = r.next, e.prev = r, r.next.prev = e, r.next = e) : (e.prev = e, 
e.next = e), e;
}
function An(e) {
e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), 
e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function Tn(e, t, n) {
this.i = e, this.x = t, this.y = n, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, 
this.steiner = !1;
}
function Ln(e) {
var t = e.length;
2 < t && e[t - 1].equals(e[0]) && e.pop();
}
function Cn(e, t) {
for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
}
function En(e, t) {
V.call(this), this.type = "ExtrudeGmtr", this.parameters = {
shapes: e,
options: t
}, this.fromBufferGmtr(new Pn(e, t)), this.mergeVertices();
}
function Pn(e, t) {
function r(e) {
function r(e, t, n) {
return t || console.error("$3.ExtrudeGmtr: vec does not exist"), t.clone().multiplyScalar(n).add(e);
}
function s(e, t, r) {
var i = e.x - t.x, a = e.y - t.y, o = r.x - e.x, s = r.y - e.y, c = i * i + a * a;
if (Math.abs(i * s - a * o) > Number.EPSILON) {
var l = Math.sqrt(c), u = Math.sqrt(o * o + s * s);
if (c = t.x - a / l, t = t.y + i / l, 2 >= (a = (o = c + i * (s = ((r.x - s / u - c) * s - (r.y + o / u - t) * o) / (i * s - a * o)) - e.x) * o + (i = t + a * s - e.y) * i)) return new n(o, i);
a = Math.sqrt(a / 2);
} else e = !1, i > Number.EPSILON ? o > Number.EPSILON && (e = !0) : i < -Number.EPSILON ? o < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(s) && (e = !0), 
e ? (o = -a, a = Math.sqrt(c)) : (o = i, i = a, a = Math.sqrt(c / 2));
return new n(o / a, i / a);
}
function c(e, t) {
for (var n = e.length; 0 <= --n; ) {
var r = n, o = n - 1;
0 > o && (o = e.length - 1);
for (var s = 0, c = g + 2 * w; s < c; s++) {
var l = N * s, u = N * (s + 1), h = t + o + l, f = t + o + u;
u = t + r + u, d(t + r + l), d(h), d(u), d(h), d(f), d(u), l = a.length / 3, p((l = M.generateSideWallUV(i, a, l - 6, l - 3, l - 2, l - 1))[0]), 
p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3]);
}
}
}
function u(e, t, n) {
f.push(e), f.push(t), f.push(n);
}
function h(e, t, n) {
d(e), d(t), d(n), e = a.length / 3, p((e = M.generateTopUV(i, a, e - 3, e - 2, e - 1))[0]), 
p(e[1]), p(e[2]);
}
function d(e) {
a.push(f[3 * e]), a.push(f[3 * e + 1]), a.push(f[3 * e + 2]);
}
function p(e) {
o.push(e.x), o.push(e.y);
}
var f = [], m = void 0 !== t.curveSegments ? t.curveSegments : 12, g = void 0 !== t.steps ? t.steps : 1, v = void 0 !== t.depth ? t.depth : 100, y = void 0 === t.bevelEnabled || t.bevelEnabled, $ = void 0 !== t.bevelThickness ? t.bevelThickness : 6, b = void 0 !== t.bevelSize ? t.bevelSize : $ - 2, x = void 0 !== t.bevelOffset ? t.bevelOffset : 0, w = void 0 !== t.bevelSegments ? t.bevelSegments : 3, _ = t.extrudePath, M = void 0 !== t.UVGenerator ? t.UVGenerator : lc;
void 0 !== t.amount && (console.warn("$3.ExtrudeBufferGmtr: amount has been renamed to depth."), 
v = t.amount);
var S = !1;
if (_) {
var A = _.getSpacedPoints(g);
S = !0, y = !1;
var T = _.computeFrenetFrames(g, !1), L = new l(), C = new l(), E = new l();
}
y || (x = b = $ = w = 0), _ = (e = e.extractPoints(m)).shape;
var P = e.holes;
if (!cc.isClockWise(_)) for (_ = _.reverse(), e = 0, m = P.length; e < m; e++) {
var k = P[e];
cc.isClockWise(k) && (P[e] = k.reverse());
}
var O = cc.triangulateShape(_, P), D = _;
for (e = 0, m = P.length; e < m; e++) _ = _.concat(P[e]);
var N = _.length, I = O.length;
e = [], m = 0;
for (var R = (k = D.length) - 1, j = m + 1; m < k; m++, R++, j++) R === k && (R = 0), 
j === k && (j = 0), e[m] = s(D[m], D[R], D[j]);
m = [], k = e.concat(), j = 0;
for (var U = P.length; j < U; j++) {
var B = P[j];
R = [];
for (var z = 0, F = B.length, G = F - 1, V = z + 1; z < F; z++, G++, V++) G === F && (G = 0), 
V === F && (V = 0), R[z] = s(B[z], B[G], B[V]);
m.push(R), k = k.concat(R);
}
for (j = 0; j < w; j++) {
for (R = j / w, U = $ * Math.cos(R * Math.PI / 2), B = b * Math.sin(R * Math.PI / 2) + x, 
R = 0, z = D.length; R < z; R++) u((F = r(D[R], e[R], B)).x, F.y, -U);
for (z = 0, F = P.length; z < F; z++) {
G = P[z], R = m[z], V = 0;
for (var W = G.length; V < W; V++) {
var q = r(G[V], R[V], B);
u(q.x, q.y, -U);
}
}
}
for (R = b + x, j = 0; j < N; j++) U = y ? r(_[j], k[j], R) : _[j], S ? (C.copy(T.normals[0]).multiplyScalar(U.x), 
L.copy(T.binormals[0]).multiplyScalar(U.y), E.copy(A[0]).add(C).add(L), u(E.x, E.y, E.z)) : u(U.x, U.y, 0);
for (j = 1; j <= g; j++) for (U = 0; U < N; U++) B = y ? r(_[U], k[U], R) : _[U], 
S ? (C.copy(T.normals[j]).multiplyScalar(B.x), L.copy(T.binormals[j]).multiplyScalar(B.y), 
E.copy(A[j]).add(C).add(L), u(E.x, E.y, E.z)) : u(B.x, B.y, v / g * j);
for (T = w - 1; 0 <= T; T--) {
for (C = T / w, L = $ * Math.cos(C * Math.PI / 2), C = b * Math.sin(C * Math.PI / 2) + x, 
E = 0, _ = D.length; E < _; E++) u((k = r(D[E], e[E], C)).x, k.y, v + L);
for (E = 0, _ = P.length; E < _; E++) for (k = P[E], R = m[E], j = 0, U = k.length; j < U; j++) B = r(k[j], R[j], C), 
S ? u(B.x, B.y + A[g - 1].y, A[g - 1].x + L) : u(B.x, B.y, v + L);
}
!function() {
var e = a.length / 3;
if (y) {
for (var t = 0 * N, n = 0; n < I; n++) {
var r = O[n];
h(r[2] + t, r[1] + t, r[0] + t);
}
for (t = N * (g + 2 * w), n = 0; n < I; n++) h((r = O[n])[0] + t, r[1] + t, r[2] + t);
} else {
for (t = 0; t < I; t++) h((n = O[t])[2], n[1], n[0]);
for (t = 0; t < I; t++) h((n = O[t])[0] + N * g, n[1] + N * g, n[2] + N * g);
}
i.addGroup(e, a.length / 3 - e, 0);
}(), function() {
var e = a.length / 3, t = 0;
c(D, t), t += D.length;
for (var n = 0, r = P.length; n < r; n++) {
var o = P[n];
c(o, t), t += o.length;
}
i.addGroup(e, a.length / 3 - e, 1);
}();
}
B.call(this), this.type = "ExtrudeBufferGmtr", this.parameters = {
shapes: e,
options: t
}, e = Array.isArray(e) ? e : [ e ];
for (var i = this, a = [], o = [], s = 0, c = e.length; s < c; s++) r(e[s]);
this.setAttribute("position", new I(a, 3)), this.setAttribute("uv", new I(o, 2)), 
this.computeVertexNormals();
}
function kn(e, t, n) {
if (n.shapes = [], Array.isArray(e)) for (var r = 0, i = e.length; r < i; r++) n.shapes.push(e[r].uuid); else n.shapes.push(e.uuid);
return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), 
n;
}
function On(e, t) {
V.call(this), this.type = "TextGmtr", this.parameters = {
text: e,
parameters: t
}, this.fromBufferGmtr(new Dn(e, t)), this.mergeVertices();
}
function Dn(e, t) {
var n = (t = t || {}).font;
if (!n || !n.isFont) return console.error("$3.TextGmtr: font parameter is not an instance of $3.Font."), 
new V();
e = n.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, 
void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), 
void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Pn.call(this, e, t), this.type = "TextBufferGmtr";
}
function Nn(e, t, n, r, i, a, o) {
V.call(this), this.type = "SphereGmtr", this.parameters = {
radius: e,
widthSegments: t,
heightSegments: n,
phiStart: r,
phiLength: i,
thetaStart: a,
thetaLength: o
}, this.fromBufferGmtr(new In(e, t, n, r, i, a, o)), this.mergeVertices();
}
function In(e, t, n, r, i, a, o) {
B.call(this), this.type = "SphereBufferGmtr", this.parameters = {
radius: e,
widthSegments: t,
heightSegments: n,
phiStart: r,
phiLength: i,
thetaStart: a,
thetaLength: o
}, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), 
r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, a = void 0 !== a ? a : 0, 
o = void 0 !== o ? o : Math.PI;
for (var s = Math.min(a + o, Math.PI), c = 0, u = [], h = new l(), d = new l(), p = [], f = [], m = [], g = [], v = 0; v <= n; v++) {
var y = [], $ = v / n, b = 0;
0 == v && 0 == a ? b = .5 / t : v == n && s == Math.PI && (b = -.5 / t);
for (var x = 0; x <= t; x++) {
var w = x / t;
h.x = -e * Math.cos(r + w * i) * Math.sin(a + $ * o), h.y = e * Math.cos(a + $ * o), 
h.z = e * Math.sin(r + w * i) * Math.sin(a + $ * o), f.push(h.x, h.y, h.z), d.copy(h).normalize(), 
m.push(d.x, d.y, d.z), g.push(w + b, 1 - $), y.push(c++);
}
u.push(y);
}
for (e = 0; e < n; e++) for (r = 0; r < t; r++) i = u[e][r + 1], o = u[e][r], c = u[e + 1][r], 
h = u[e + 1][r + 1], (0 !== e || 0 < a) && p.push(i, o, h), (e !== n - 1 || s < Math.PI) && p.push(o, c, h);
this.setIndex(p), this.setAttribute("position", new I(f, 3)), this.setAttribute("normal", new I(m, 3)), 
this.setAttribute("uv", new I(g, 2));
}
function Rn(e, t, n, r, i, a) {
V.call(this), this.type = "RingGmtr", this.parameters = {
innerRadius: e,
outerRadius: t,
thetaSegments: n,
phiSegments: r,
thetaStart: i,
thetaLength: a
}, this.fromBufferGmtr(new jn(e, t, n, r, i, a)), this.mergeVertices();
}
function jn(e, t, r, i, a, o) {
B.call(this), this.type = "RingBufferGmtr", this.parameters = {
innerRadius: e,
outerRadius: t,
thetaSegments: r,
phiSegments: i,
thetaStart: a,
thetaLength: o
}, e = e || .5, t = t || 1, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, 
r = void 0 !== r ? Math.max(3, r) : 8;
var s = [], c = [], u = [], h = [], d = e;
e = (t - e) / (i = void 0 !== i ? Math.max(1, i) : 1);
for (var p = new l(), f = new n(), m = 0; m <= i; m++) {
for (var g = 0; g <= r; g++) {
var v = a + g / r * o;
p.x = d * Math.cos(v), p.y = d * Math.sin(v), c.push(p.x, p.y, p.z), u.push(0, 0, 1), 
f.x = (p.x / t + 1) / 2, f.y = (p.y / t + 1) / 2, h.push(f.x, f.y);
}
d += e;
}
for (t = 0; t < i; t++) for (a = t * (r + 1), o = 0; o < r; o++) e = (d = o + a) + r + 1, 
p = d + r + 2, f = d + 1, s.push(d, e, f), s.push(e, p, f);
this.setIndex(s), this.setAttribute("position", new I(c, 3)), this.setAttribute("normal", new I(u, 3)), 
this.setAttribute("uv", new I(h, 2));
}
function Un(e, t, n, r) {
V.call(this), this.type = "LatheGmtr", this.parameters = {
points: e,
segments: t,
phiStart: n,
phiLength: r
}, this.fromBufferGmtr(new Bn(e, t, n, r)), this.mergeVertices();
}
function Bn(e, t, r, i) {
B.call(this), this.type = "LatheBufferGmtr", this.parameters = {
points: e,
segments: t,
phiStart: r,
phiLength: i
}, t = Math.floor(t) || 12, r = r || 0, i = i || 2 * Math.PI, i = da.clamp(i, 0, 2 * Math.PI);
for (var a = [], o = [], s = [], c = 1 / t, u = new l(), h = new n(), d = 0; d <= t; d++) {
var p = r + d * c * i, f = Math.sin(p);
p = Math.cos(p);
for (var m = 0; m <= e.length - 1; m++) u.x = e[m].x * f, u.y = e[m].y, u.z = e[m].x * p, 
o.push(u.x, u.y, u.z), h.x = d / t, h.y = m / (e.length - 1), s.push(h.x, h.y);
}
for (r = 0; r < t; r++) for (c = 0; c < e.length - 1; c++) h = (u = c + r * e.length) + e.length, 
d = u + e.length + 1, f = u + 1, a.push(u, h, f), a.push(h, d, f);
if (this.setIndex(a), this.setAttribute("position", new I(o, 3)), this.setAttribute("uv", new I(s, 2)), 
this.computeVertexNormals(), i === 2 * Math.PI) for (i = this.attributes.normal.array, 
a = new l(), o = new l(), s = new l(), t = t * e.length * 3, c = r = 0; r < e.length; r++, 
c += 3) a.x = i[c + 0], a.y = i[c + 1], a.z = i[c + 2], o.x = i[t + c + 0], o.y = i[t + c + 1], 
o.z = i[t + c + 2], s.addVectors(a, o).normalize(), i[c + 0] = i[t + c + 0] = s.x, 
i[c + 1] = i[t + c + 1] = s.y, i[c + 2] = i[t + c + 2] = s.z;
}
function zn(e, t) {
V.call(this), this.type = "ShapeGmtr", "object" == typeof t && (console.warn("$3.ShapeGmtr: Options parameter has been removed."), 
t = t.curveSegments), this.parameters = {
shapes: e,
curveSegments: t
}, this.fromBufferGmtr(new Fn(e, t)), this.mergeVertices();
}
function Fn(e, t) {
function n(e) {
var n = i.length / 3, s = e.extractPoints(t);
e = s.shape;
var l = s.holes;
!1 === cc.isClockWise(e) && (e = e.reverse()), s = 0;
for (var u = l.length; s < u; s++) {
var h = l[s];
!0 === cc.isClockWise(h) && (l[s] = h.reverse());
}
for (s = cc.triangulateShape(e, l), u = 0, h = l.length; u < h; u++) e = e.concat(l[u]);
for (l = 0, u = e.length; l < u; l++) h = e[l], i.push(h.x, h.y, 0), a.push(0, 0, 1), 
o.push(h.x, h.y);
for (e = 0, l = s.length; e < l; e++) u = s[e], r.push(u[0] + n, u[1] + n, u[2] + n), 
c += 3;
}
B.call(this), this.type = "ShapeBufferGmtr", this.parameters = {
shapes: e,
curveSegments: t
}, t = t || 12;
var r = [], i = [], a = [], o = [], s = 0, c = 0;
if (!1 === Array.isArray(e)) n(e); else for (var l = 0; l < e.length; l++) n(e[l]), 
this.addGroup(s, c, l), s += c, c = 0;
this.setIndex(r), this.setAttribute("position", new I(i, 3)), this.setAttribute("normal", new I(a, 3)), 
this.setAttribute("uv", new I(o, 2));
}
function Gn(e, t) {
if (t.shapes = [], Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) t.shapes.push(e[n].uuid); else t.shapes.push(e.uuid);
return t;
}
function Vn(e, t) {
B.call(this), this.type = "EdgesGmtr", this.parameters = {
thresholdAngle: t
};
var n = [];
t = Math.cos(da.DEG2RAD * (void 0 !== t ? t : 1));
var r = [ 0, 0 ], i = {}, a = [ "a", "b", "c" ];
if (e.isBufferGmtr) {
var o = new V();
o.fromBufferGmtr(e);
} else o = e.clone();
o.mergeVertices(), o.computeFaceNormals(), e = o.vertices;
for (var s = 0, c = (o = o.faces).length; s < c; s++) for (var l = o[s], u = 0; 3 > u; u++) {
var h = l[a[u]], d = l[a[(u + 1) % 3]];
r[0] = Math.min(h, d), r[1] = Math.max(h, d), void 0 === i[h = r[0] + "," + r[1]] ? i[h] = {
index1: r[0],
index2: r[1],
face1: s,
face2: void 0
} : i[h].face2 = s;
}
for (h in i) (void 0 === (r = i[h]).face2 || o[r.face1].normal.dot(o[r.face2].normal) <= t) && (a = e[r.index1], 
n.push(a.x, a.y, a.z), a = e[r.index2], n.push(a.x, a.y, a.z));
this.setAttribute("position", new I(n, 3));
}
function Wn(e, t, n, r, i, a, o, s) {
V.call(this), this.type = "CylinderGmtr", this.parameters = {
radiusTop: e,
radiusBottom: t,
height: n,
radialSegments: r,
heightSegments: i,
openEnded: a,
thetaStart: o,
thetaLength: s
}, this.fromBufferGmtr(new qn(e, t, n, r, i, a, o, s)), this.mergeVertices();
}
function qn(e, t, r, i, a, o, s, c) {
function u(r) {
var a, o = new n(), u = new l(), v = 0, b = !0 === r ? e : t, x = !0 === r ? 1 : -1, w = g;
for (a = 1; a <= i; a++) p.push(0, y * x, 0), f.push(0, x, 0), m.push(.5, .5), g++;
a = g;
for (var _ = 0; _ <= i; _++) {
var M = _ / i * c + s, S = Math.cos(M);
M = Math.sin(M), u.x = b * M, u.y = y * x, u.z = b * S, p.push(u.x, u.y, u.z), f.push(0, x, 0), 
o.x = .5 * S + .5, o.y = .5 * M * x + .5, m.push(o.x, o.y), g++;
}
for (o = 0; o < i; o++) u = w + o, b = a + o, !0 === r ? d.push(b, b + 1, u) : d.push(b + 1, b, u), 
v += 3;
h.addGroup($, v, !0 === r ? 1 : 2), $ += v;
}
B.call(this), this.type = "CylinderBufferGmtr", this.parameters = {
radiusTop: e,
radiusBottom: t,
height: r,
radialSegments: i,
heightSegments: a,
openEnded: o,
thetaStart: s,
thetaLength: c
};
var h = this;
e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, r = r || 1, i = Math.floor(i) || 8, 
a = Math.floor(a) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI;
var d = [], p = [], f = [], m = [], g = 0, v = [], y = r / 2, $ = 0;
!function() {
for (var n = new l(), o = new l(), u = 0, b = (t - e) / r, x = 0; x <= a; x++) {
for (var w = [], _ = x / a, M = _ * (t - e) + e, S = 0; S <= i; S++) {
var A = S / i, T = A * c + s, L = Math.sin(T);
T = Math.cos(T), o.x = M * L, o.y = -_ * r + y, o.z = M * T, p.push(o.x, o.y, o.z), 
n.set(L, b, T).normalize(), f.push(n.x, n.y, n.z), m.push(A, 1 - _), w.push(g++);
}
v.push(w);
}
for (n = 0; n < i; n++) for (o = 0; o < a; o++) b = v[o + 1][n], x = v[o + 1][n + 1], 
w = v[o][n + 1], d.push(v[o][n], b, w), d.push(b, x, w), u += 6;
h.addGroup($, u, 0), $ += u;
}(), !1 === o && (0 < e && u(!0), 0 < t && u(!1)), this.setIndex(d), this.setAttribute("position", new I(p, 3)), 
this.setAttribute("normal", new I(f, 3)), this.setAttribute("uv", new I(m, 2));
}
function Hn(e, t, n, r, i, a, o) {
Wn.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeGmtr", this.parameters = {
radius: e,
height: t,
radialSegments: n,
heightSegments: r,
openEnded: i,
thetaStart: a,
thetaLength: o
};
}
function Xn(e, t, n, r, i, a, o) {
qn.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeBufferGmtr", this.parameters = {
radius: e,
height: t,
radialSegments: n,
heightSegments: r,
openEnded: i,
thetaStart: a,
thetaLength: o
};
}
function Yn(e, t, n, r) {
V.call(this), this.type = "CircleGmtr", this.parameters = {
radius: e,
segments: t,
thetaStart: n,
thetaLength: r
}, this.fromBufferGmtr(new Jn(e, t, n, r)), this.mergeVertices();
}
function Jn(e, t, r, i) {
B.call(this), this.type = "CircleBufferGmtr", this.parameters = {
radius: e,
segments: t,
thetaStart: r,
thetaLength: i
}, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, r = void 0 !== r ? r : 0, 
i = void 0 !== i ? i : 2 * Math.PI;
var a = [], o = [], s = [], c = [], u = new l(), h = new n();
o.push(0, 0, 0), s.push(0, 0, 1), c.push(.5, .5);
for (var d = 0, p = 3; d <= t; d++, p += 3) {
var f = r + d / t * i;
u.x = e * Math.cos(f), u.y = e * Math.sin(f), o.push(u.x, u.y, u.z), s.push(0, 0, 1), 
h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, c.push(h.x, h.y);
}
for (e = 1; e <= t; e++) a.push(e, e + 1, 0);
this.setIndex(a), this.setAttribute("position", new I(o, 3)), this.setAttribute("normal", new I(s, 3)), 
this.setAttribute("uv", new I(c, 2));
}
function Zn(e) {
A.call(this), this.type = "ShadowMtrl", this.color = new x(0), this.transparent = !0, 
this.setValues(e);
}
function Kn(e) {
H.call(this, e), this.type = "RawShaderMtrl";
}
function Qn(e) {
A.call(this), this.defines = {
STANDARD: ""
}, this.type = "MeshStandardMtrl", this.color = new x(16777215), this.roughness = 1, 
this.metalness = 0, this.lightMap = this.map = null, this.lightMapIntensity = 1, 
this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, 
this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, 
this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, 
this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, 
this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, 
this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexTangents = this.morphNormals = this.morphTargets = this.skinning = !1, 
this.setValues(e);
}
function er(e) {
Qn.call(this), this.defines = {
STANDARD: "",
PHYSICAL: ""
}, this.type = "MeshPhysicalMtrl", this.clearcoat = 0, this.clearcoatMap = null, 
this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new n(1, 1), 
this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, 
this.setValues(e);
}
function tr(e) {
A.call(this), this.type = "MeshPhongMtrl", this.color = new x(16777215), this.specular = new x(1118481), 
this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, 
this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, 
this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, 
this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, 
this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, 
this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e);
}
function nr(e) {
A.call(this), this.defines = {
TOON: ""
}, this.type = "MeshToonMtrl", this.color = new x(16777215), this.specular = new x(1118481), 
this.shininess = 30, this.lightMap = this.gradientMap = this.map = null, this.lightMapIntensity = 1, 
this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, 
this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, 
this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, 
this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = this.specularMap = null, 
this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e);
}
function rr(e) {
A.call(this), this.type = "MeshNormalMtrl", this.bumpMap = null, this.bumpScale = 1, 
this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, 
this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, 
this.morphNormals = this.morphTargets = this.skinning = this.fog = !1, this.setValues(e);
}
function ir(e) {
A.call(this), this.type = "MeshLambertMtrl", this.color = new x(16777215), this.lightMap = this.map = null, 
this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), 
this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, 
this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e);
}
function ar(e) {
A.call(this), this.defines = {
MATCAP: ""
}, this.type = "MeshMatcapMtrl", this.color = new x(16777215), this.bumpMap = this.map = this.matcap = null, 
this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), 
this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, 
this.alphaMap = null, this.morphNormals = this.morphTargets = this.skinning = !1, 
this.setValues(e);
}
function or(e) {
Ot.call(this), this.type = "LineDashedMtrl", this.scale = 1, this.dashSize = 3, 
this.gapSize = 1, this.setValues(e);
}
function sr(e, t, n, r) {
this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), 
this.sampleValues = t, this.valueSize = n;
}
function cr(e, t, n, r) {
sr.call(this, e, t, n, r), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
}
function lr(e, t, n, r) {
sr.call(this, e, t, n, r);
}
function ur(e, t, n, r) {
sr.call(this, e, t, n, r);
}
function hr(e, t, n, r) {
if (void 0 === e) throw Error("$3.KeyframeTrack: track name is undefined");
if (void 0 === t || 0 === t.length) throw Error("$3.KeyframeTrack: no keyframes in track named " + e);
this.name = e, this.times = dc.convertArray(t, this.TimeBufferType), this.values = dc.convertArray(n, this.ValueBufferType), 
this.setInterpolation(r || this.DefaultInterpolation);
}
function dr(e, t, n) {
hr.call(this, e, t, n);
}
function pr(e, t, n, r) {
hr.call(this, e, t, n, r);
}
function fr(e, t, n, r) {
hr.call(this, e, t, n, r);
}
function mr(e, t, n, r) {
sr.call(this, e, t, n, r);
}
function gr(e, t, n, r) {
hr.call(this, e, t, n, r);
}
function vr(e, t, n, r) {
hr.call(this, e, t, n, r);
}
function yr(e, t, n, r) {
hr.call(this, e, t, n, r);
}
function $r(e, t, n, r) {
this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.blendMode = void 0 !== r ? r : 2500, 
this.uuid = da.generateUUID(), 0 > this.duration && this.resetDuration();
}
function br(e) {
if (void 0 === e.type) throw Error("$3.KeyframeTrack: track type undefined, can not parse");
var t = function(e) {
switch (e.toLowerCase()) {
case "scalar":
case "double":
case "float":
case "number":
case "integer":
return fr;

case "vector":
case "vector2":
case "vector3":
case "vector4":
return yr;

case "color":
return pr;

case "quaternion":
return gr;

case "bool":
case "boolean":
return dr;

case "string":
return vr;
}
throw Error("$3.KeyframeTrack: Unsupported typeName: " + e);
}(e.type);
if (void 0 === e.times) {
var n = [], r = [];
dc.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r;
}
return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
}
function xr(e, t, n) {
var r = this, i = !1, a = 0, o = 0, s = void 0, c = [];
this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
o++, !1 === i && void 0 !== r.onStart && r.onStart(e, a, o), i = !0;
}, this.itemEnd = function(e) {
a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (i = !1, void 0 !== r.onLoad) && r.onLoad();
}, this.itemError = function(e) {
void 0 !== r.onError && r.onError(e);
}, this.resolveURL = function(e) {
return s ? s(e) : e;
}, this.setURLModifier = function(e) {
return s = e, this;
}, this.addHandler = function(e, t) {
return c.push(e, t), this;
}, this.removeHandler = function(e) {
return -1 !== (e = c.indexOf(e)) && c.splice(e, 2), this;
}, this.getHandler = function(e) {
for (var t = 0, n = c.length; t < n; t += 2) {
var r = c[t], i = c[t + 1];
if (r.global && (r.lastIndex = 0), r.test(e)) return i;
}
return null;
};
}
function wr(e) {
this.manager = void 0 !== e ? e : fc, this.crossOrigin = "anonymous", this.resourcePath = this.path = "", 
this.requestHeader = {};
}
function _r(e) {
wr.call(this, e);
}
function Mr(e) {
wr.call(this, e);
}
function Sr(e) {
wr.call(this, e);
}
function Ar(e) {
wr.call(this, e);
}
function Tr(e) {
wr.call(this, e);
}
function Lr(e) {
wr.call(this, e);
}
function Cr(e) {
wr.call(this, e);
}
function Er() {
this.type = "Curve", this.arcLengthDivisions = 200;
}
function Pr(e, t, n, r, i, a, o, s) {
Er.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, 
this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, 
this.aClockwise = o || !1, this.aRotation = s || 0;
}
function kr(e, t, n, r, i, a) {
Pr.call(this, e, t, n, n, r, i, a), this.type = "ArcCurve";
}
function Or() {
var e = 0, t = 0, n = 0, r = 0;
return {
initCatmullRom: function(i, a, o, s, c) {
e = a, t = i = c * (o - i), n = -3 * a + 3 * o - 2 * i - (s = c * (s - a)), r = 2 * a - 2 * o + i + s;
},
initNonuniformCatmullRom: function(i, a, o, s, c, l, u) {
e = a, t = i = ((a - i) / c - (o - i) / (c + l) + (o - a) / l) * l, n = -3 * a + 3 * o - 2 * i - (s = ((o - a) / l - (s - a) / (l + u) + (s - o) / u) * l), 
r = 2 * a - 2 * o + i + s;
},
calc: function(i) {
var a = i * i;
return e + t * i + n * a + r * a * i;
}
};
}
function Dr(e, t, n, r) {
Er.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, 
this.curveType = n || "centripetal", this.tension = r || .5;
}
function Nr(e, t, n, r, i) {
var a = e * e;
return (2 * n - 2 * r + (t = .5 * (r - t)) + (i = .5 * (i - n))) * e * a + (-3 * n + 3 * r - 2 * t - i) * a + t * e + n;
}
function Ir(e, t, n, r) {
var i = 1 - e;
return i * i * t + 2 * (1 - e) * e * n + e * e * r;
}
function Rr(e, t, n, r, i) {
var a = 1 - e, o = 1 - e;
return a * a * a * t + 3 * o * o * e * n + 3 * (1 - e) * e * e * r + e * e * e * i;
}
function jr(e, t, r, i) {
Er.call(this), this.type = "CubicBezierCurve", this.v0 = e || new n(), this.v1 = t || new n(), 
this.v2 = r || new n(), this.v3 = i || new n();
}
function Ur(e, t, n, r) {
Er.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new l(), this.v1 = t || new l(), 
this.v2 = n || new l(), this.v3 = r || new l();
}
function Br(e, t) {
Er.call(this), this.type = "LineCurve", this.v1 = e || new n(), this.v2 = t || new n();
}
function zr(e, t) {
Er.call(this), this.type = "LineCurve3", this.v1 = e || new l(), this.v2 = t || new l();
}
function Fr(e, t, r) {
Er.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new n(), this.v1 = t || new n(), 
this.v2 = r || new n();
}
function Gr(e, t, n) {
Er.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new l(), this.v1 = t || new l(), 
this.v2 = n || new l();
}
function Vr(e) {
Er.call(this), this.type = "SplineCurve", this.points = e || [];
}
function Wr() {
Er.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
function qr(e) {
Wr.call(this), this.type = "Path", this.currentPoint = new n(), e && this.setFromPoints(e);
}
function Hr(e) {
qr.call(this, e), this.uuid = da.generateUUID(), this.type = "Shape", this.holes = [];
}
function Xr(e, t) {
p.call(this), this.type = "Light", this.color = new x(e), this.intensity = void 0 !== t ? t : 1, 
this.receiveShadow = void 0;
}
function Yr(e, t, n) {
Xr.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(p.DefaultUp), 
this.updateMatrix(), this.groundColor = new x(t);
}
function Jr(e) {
this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), 
this.mapPass = this.map = null, this.matrix = new u(), this._frustum = new Q(), 
this._frameExtents = new n(1, 1), this._viewportCount = 1, this._viewports = [ new a(0, 0, 1, 1) ];
}
function Zr() {
Jr.call(this, new Y(50, 1, .5, 500));
}
function Kr(e, t, n, r, i, a) {
Xr.call(this, e, t), this.type = "SpotLight", this.position.copy(p.DefaultUp), this.updateMatrix(), 
this.target = new p(), Object.defineProperty(this, "power", {
get: function() {
return this.intensity * Math.PI;
},
set: function(e) {
this.intensity = e / Math.PI;
}
}), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, 
this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Zr();
}
function Qr() {
Jr.call(this, new Y(90, 1, .5, 500)), this._frameExtents = new n(4, 2), this._viewportCount = 6, 
this._viewports = [ new a(2, 1, 1, 1), new a(0, 1, 1, 1), new a(3, 1, 1, 1), new a(1, 1, 1, 1), new a(3, 0, 1, 1), new a(1, 0, 1, 1) ], 
this._cubeDirections = [ new l(1, 0, 0), new l(-1, 0, 0), new l(0, 0, 1), new l(0, 0, -1), new l(0, 1, 0), new l(0, -1, 0) ], 
this._cubeUps = [ new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 0, 1), new l(0, 0, -1) ];
}
function ei(e, t, n, r) {
Xr.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
get: function() {
return 4 * this.intensity * Math.PI;
},
set: function(e) {
this.intensity = e / (4 * Math.PI);
}
}), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Qr();
}
function ti(e, t, n, r, i, a) {
X.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, 
this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, 
this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== a ? a : 2e3, 
this.updateProjectionMatrix();
}
function ni() {
Jr.call(this, new ti(-5, 5, 5, -5, .5, 500));
}
function ri(e, t) {
Xr.call(this, e, t), this.type = "DirectionalLight", this.position.copy(p.DefaultUp), 
this.updateMatrix(), this.target = new p(), this.shadow = new ni();
}
function ii(e, t) {
Xr.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0;
}
function ai(e, t, n, r) {
Xr.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, 
this.height = void 0 !== r ? r : 10;
}
function oi() {
this.coefficients = [];
for (var e = 0; 9 > e; e++) this.coefficients.push(new l());
}
function si(e, t) {
Xr.call(this, void 0, t), this.type = "LightProbe", this.sh = void 0 !== e ? e : new oi();
}
function ci(e) {
wr.call(this, e), this.textures = {};
}
function li() {
B.call(this), this.type = "InstancedBufferGmtr", this.instanceCount = 1 / 0;
}
function ui(e, t, n, r) {
"number" == typeof n && (r = n, n = !1, console.error("$3.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), 
L.call(this, e, t, n), this.meshPerAttribute = r || 1;
}
function hi(e) {
wr.call(this, e);
}
function di(e) {
wr.call(this, e);
}
function pi(e) {
"undefined" == typeof createImageBitmap && console.warn("$3.ImageBitmapLoader: createImageBitmap() not supported."), 
"undefined" == typeof fetch && console.warn("$3.ImageBitmapLoader: fetch() not supported."), 
wr.call(this, e), this.options = void 0;
}
function fi() {
this.type = "ShapePath", this.color = new x(), this.subPaths = [], this.currentPath = null;
}
function mi(e) {
this.type = "Font", this.data = e;
}
function gi(e) {
wr.call(this, e);
}
function vi(e) {
wr.call(this, e);
}
function yi(e, t, n) {
si.call(this, void 0, n), e = new x().set(e), n = new x().set(t), t = new l(e.r, e.g, e.b), 
e = new l(n.r, n.g, n.b);
var r = (n = Math.sqrt(Math.PI)) * Math.sqrt(.75);
this.sh.coefficients[0].copy(t).add(e).multiplyScalar(n), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(r);
}
function $i(e, t) {
si.call(this, void 0, t), e = new x().set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
function bi() {
this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Y(), 
this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Y(), 
this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
focus: null,
fov: null,
aspect: null,
near: null,
far: null,
zoom: null,
eyeSep: null
};
}
function xi(e) {
this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, 
this.running = !1;
}
function wi() {
p.call(this), this.type = "AudioListener", this.context = Tc.getContext(), this.gain = this.context.createGain(), 
this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, 
this._clock = new xi();
}
function _i(e) {
p.call(this), this.type = "Audio", this.listener = e, this.context = e.context, 
this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, 
this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.loopEnd = this.loopStart = 0, 
this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, 
this.sourceType = "empty", this._progress = this._startedAt = 0, this.filters = [];
}
function Mi(e) {
_i.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", 
this.panner.connect(this.gain);
}
function Si(e, t) {
this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, 
this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
}
function Ai(e, t, n) {
switch (this.binding = e, this.valueSize = n, t) {
case "quaternion":
e = this._slerp, t = this._slerpAdditive;
var r = this._setAdditiveIdentityQuaternion;
this.buffer = new Float64Array(6 * n), this._workIndex = 5;
break;

case "string":
case "bool":
t = e = this._select, r = this._setAdditiveIdentityOther, this.buffer = Array(5 * n);
break;

default:
e = this._lerp, t = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
}
this._mixBufferRegion = e, this._mixBufferRegionAdditive = t, this._setIdentity = r, 
this._origIndex = 3, this._addIndex = 4, this.referenceCount = this.useCount = this.cumulativeWeightAdditive = this.cumulativeWeight = 0;
}
function Ti(e, t, n) {
n = n || Li.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, n);
}
function Li(e, t, n) {
this.path = t, this.parsedPath = n || Li.parseTrackName(t), this.node = Li.findNode(e, this.parsedPath.nodeName) || e, 
this.rootNode = e;
}
function Ci() {
this.uuid = da.generateUUID(), this._objects = Array.prototype.slice.call(arguments), 
this.nCachedObjects_ = 0;
var e = {};
this._indicesByUUID = e;
for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
var r = this;
this.stats = {
objects: {
get total() {
return r._objects.length;
},
get inUse() {
return this.total - r.nCachedObjects_;
}
},
get bindingsPerObject() {
return r._bindings.length;
}
};
}
function Ei(e, t, n, r) {
this._mixer = e, this._clip = t, this._localRoot = n || null, this.blendMode = r || t.blendMode, 
t = (e = t.tracks).length, n = Array(t), r = {
endingStart: 2400,
endingEnd: 2400
};
for (var i = 0; i !== t; ++i) {
var a = e[i].createInterpolant(null);
n[i] = a, a.settings = r;
}
this._interpolantSettings = r, this._interpolants = n, this._propertyBindings = Array(t), 
this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, 
this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, 
this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, 
this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
}
function Pi(e) {
this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
}
function ki(e, t) {
"string" == typeof e && (console.warn("$3.Uniform: Type parameter is no longer needed."), 
e = t), this.value = e;
}
function Oi(e, t, n) {
_t.call(this, e, t), this.meshPerAttribute = n || 1;
}
function Di(e, t, n, r) {
this.ray = new y(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, 
this.layers = new d(), this.params = {
Mesh: {},
Line: {
threshold: 1
},
LOD: {},
Points: {
threshold: 1
},
Sprite: {}
}, Object.defineProperties(this.params, {
PointCloud: {
get: function() {
return console.warn("$3.Raycaster: params.PointCloud has been renamed to params.Points."), 
this.Points;
}
}
});
}
function Ni(e, t) {
return e.distance - t.distance;
}
function Ii(e, t, n, r) {
if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
r = 0;
for (var i = (e = e.children).length; r < i; r++) Ii(e[r], t, n, !0);
}
}
function Ri(e, t, n) {
return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, 
this;
}
function ji(e, t, n) {
return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, 
this;
}
function Ui(e, t) {
this.min = void 0 !== e ? e : new n(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new n(-1 / 0, -1 / 0);
}
function Bi(e, t) {
this.start = void 0 !== e ? e : new l(), this.end = void 0 !== t ? t : new l();
}
function zi(e) {
p.call(this), this.material = e, this.render = function() {}, this.hasUvs = this.hasColors = this.hasNormals = this.hasPositions = !1, 
this.uvArray = this.colorArray = this.normalArray = this.positionArray = null, this.count = 0;
}
function Fi(e, t) {
p.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, 
this.matrixAutoUpdate = !1, this.color = t, e = new B(), t = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ];
for (var n = 0, r = 1; 32 > n; n++, r++) {
var i = n / 32 * Math.PI * 2, a = r / 32 * Math.PI * 2;
t.push(Math.cos(i), Math.sin(i), 1, Math.cos(a), Math.sin(a), 1);
}
e.setAttribute("position", new I(t, 3)), t = new Ot({
fog: !1,
toneMapped: !1
}), this.cone = new Nt(e, t), this.add(this.cone), this.update();
}
function Gi(e) {
for (var t = function e(t) {
var n = [];
t && t.isBone && n.push(t);
for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
return n;
}(e), n = new B(), r = [], i = [], a = new x(0, 0, 1), o = new x(0, 1, 0), s = 0; s < t.length; s++) {
var c = t[s];
c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), 
i.push(o.r, o.g, o.b));
}
n.setAttribute("position", new I(r, 3)), n.setAttribute("color", new I(i, 3)), r = new Ot({
vertexColors: !0,
depthTest: !1,
depthWrite: !1,
toneMapped: !1,
transparent: !0
}), Nt.call(this, n, r), this.type = "SkeletonHelper", this.root = e, this.bones = t, 
this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
}
function Vi(e, t, n) {
this.light = e, this.light.updateMatrixWorld(), this.color = n, e = new In(t, 4, 2), 
t = new T({
wireframe: !0,
fog: !1,
toneMapped: !1
}), z.call(this, e, t), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, 
this.matrixAutoUpdate = !1, this.update();
}
function Wi(e, t, n) {
p.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, 
this.matrixAutoUpdate = !1, this.color = n, (e = new Kt(t)).rotateY(.5 * Math.PI), 
this.material = new T({
wireframe: !0,
fog: !1,
toneMapped: !1
}), void 0 === this.color && (this.material.vertexColors = !0), t = e.getAttribute("position"), 
t = new Float32Array(3 * t.count), e.setAttribute("color", new L(t, 3)), this.add(new z(e, this.material)), 
this.update();
}
function qi(e, t, n, r) {
e = e || 10, t = t || 10, n = new x(void 0 !== n ? n : 4473924), r = new x(void 0 !== r ? r : 8947848);
var i = t / 2, a = e / t, o = e / 2;
e = [];
for (var s = [], c = 0, l = 0, u = -o; c <= t; c++, u += a) {
e.push(-o, 0, u, o, 0, u), e.push(u, 0, -o, u, 0, o);
var h = c === i ? n : r;
h.toArray(s, l), l += 3, h.toArray(s, l), l += 3, h.toArray(s, l), l += 3, h.toArray(s, l), 
l += 3;
}
(t = new B()).setAttribute("position", new I(e, 3)), t.setAttribute("color", new I(s, 3)), 
n = new Ot({
vertexColors: !0,
toneMapped: !1
}), Nt.call(this, t, n), this.type = "GridHelper";
}
function Hi(e, t, n, r, i, a) {
e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new x(void 0 !== i ? i : 4473924), 
a = new x(void 0 !== a ? a : 8947848);
for (var o = [], s = [], c = 0; c <= t; c++) {
var l = c / t * 2 * Math.PI, u = Math.sin(l) * e;
l = Math.cos(l) * e, o.push(0, 0, 0), o.push(u, 0, l), u = 1 & c ? i : a, s.push(u.r, u.g, u.b), 
s.push(u.r, u.g, u.b);
}
for (t = 0; t <= n; t++) for (c = 1 & t ? i : a, u = e - e / n * t, l = 0; l < r; l++) {
var h = l / r * 2 * Math.PI, d = Math.sin(h) * u;
h = Math.cos(h) * u, o.push(d, 0, h), s.push(c.r, c.g, c.b), h = (l + 1) / r * 2 * Math.PI, 
d = Math.sin(h) * u, h = Math.cos(h) * u, o.push(d, 0, h), s.push(c.r, c.g, c.b);
}
(e = new B()).setAttribute("position", new I(o, 3)), e.setAttribute("color", new I(s, 3)), 
o = new Ot({
vertexColors: !0,
toneMapped: !1
}), Nt.call(this, e, o), this.type = "PolarGridHelper";
}
function Xi(e, t, n) {
p.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, 
this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1), (e = new B()).setAttribute("position", new I([ -t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0 ], 3)), 
t = new Ot({
fog: !1,
toneMapped: !1
}), this.lightPlane = new Dt(e, t), this.add(this.lightPlane), (e = new B()).setAttribute("position", new I([ 0, 0, 0, 0, 0, 1 ], 3)), 
this.targetLine = new Dt(e, t), this.add(this.targetLine), this.update();
}
function Yi(e) {
function t(e, t, r) {
n(e, r), n(t, r);
}
function n(e, t) {
a.push(0, 0, 0), o.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(a.length / 3 - 1);
}
var r = new B(), i = new Ot({
color: 16777215,
vertexColors: !0,
toneMapped: !1
}), a = [], o = [], s = {}, c = new x(16755200), l = new x(16711680), u = new x(43775), h = new x(16777215), d = new x(3355443);
t("n1", "n2", c), t("n2", "n4", c), t("n4", "n3", c), t("n3", "n1", c), t("f1", "f2", c), 
t("f2", "f4", c), t("f4", "f3", c), t("f3", "f1", c), t("n1", "f1", c), t("n2", "f2", c), 
t("n3", "f3", c), t("n4", "f4", c), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), 
t("p", "n4", l), t("u1", "u2", u), t("u2", "u3", u), t("u3", "u1", u), t("c", "t", h), 
t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), 
r.setAttribute("position", new I(a, 3)), r.setAttribute("color", new I(o, 3)), Nt.call(this, r, i), 
this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), 
this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
}
function Ji(e, t, n, r, i, a, o) {
if (al.set(i, a, o).unproject(r), void 0 !== (e = t[e])) for (n = n.getAttribute("position"), 
t = 0, r = e.length; t < r; t++) n.setXYZ(e[t], al.x, al.y, al.z);
}
function Zi(e, t) {
this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
var n = new Float32Array(24), r = new B();
r.setIndex(new L(e, 1)), r.setAttribute("position", new L(n, 3)), Nt.call(this, r, new Ot({
color: t,
toneMapped: !1
})), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
}
function Ki(e, t) {
this.type = "Box3Helper", this.box = e, t = t || 16776960, e = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
var n = new B();
n.setIndex(new L(e, 1)), n.setAttribute("position", new I([ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 ], 3)), 
Nt.call(this, n, new Ot({
color: t,
toneMapped: !1
})), this.type = "Box3Helper", this.geometry.computeBoundingSphere();
}
function Qi(e, t, n) {
this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== n ? n : 16776960, 
(t = new B()).setAttribute("position", new I([ 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ], 3)), 
t.computeBoundingSphere(), Dt.call(this, t, new Ot({
color: e,
toneMapped: !1
})), this.type = "PlaneHelper", (t = new B()).setAttribute("position", new I([ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1 ], 3)), 
t.computeBoundingSphere(), this.add(new z(t, new T({
color: e,
opacity: .2,
transparent: !0,
depthWrite: !1,
toneMapped: !1
})));
}
function ea(e, t, n, r, i, a) {
p.call(this), this.type = "ArrowHelper", void 0 === e && (e = new l(0, 0, 1)), void 0 === t && (t = new l(0, 0, 0)), 
void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), 
void 0 === a && (a = .2 * i), void 0 === cl && ((cl = new B()).setAttribute("position", new I([ 0, 0, 0, 0, 1, 0 ], 3)), 
(ll = new qn(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Dt(cl, new Ot({
color: r,
toneMapped: !1
})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new z(ll, new T({
color: r,
toneMapped: !1
})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), 
this.setLength(n, i, a);
}
function ta(e) {
var t = [ 0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e ];
(e = new B()).setAttribute("position", new I(t, 3)), e.setAttribute("color", new I([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ], 3)), 
t = new Ot({
vertexColors: !0,
toneMapped: !1
}), Nt.call(this, e, t), this.type = "AxesHelper";
}
function na(e) {
this._renderer = e, this._pingPongRenderTarget = null, (e = new Kn({
defines: {
n: 20
},
uniforms: {
envMap: {
value: null
},
samples: {
value: 1
},
weights: {
value: e = new Float32Array(20)
},
latitudinal: {
value: !1
},
dTheta: {
value: 0
},
mipInt: {
value: 0
},
poleAxis: {
value: new l(0, 1, 0)
},
inputEncoding: {
value: fl[3e3]
},
outputEncoding: {
value: fl[3e3]
}
},
vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
blending: 0,
depthTest: !1,
depthWrite: !1
})).type = "SphericalGaussianBlur", this._blurMtrl = e, this._cubemapShader = this._equirectShader = null, 
this._compileMtrl(this._blurMtrl);
}
function ra(e) {
return (e = new o(3 * hl, 3 * hl, e)).texture.mapping = 306, e.texture.name = "PMREM.cubeUv", 
e.scissorTest = !0, e;
}
function ia(e, t, n, r, i) {
e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i);
}
function aa() {
var e = new n(1, 1);
return (e = new Kn({
uniforms: {
envMap: {
value: null
},
texelSize: {
value: e
},
inputEncoding: {
value: fl[3e3]
},
outputEncoding: {
value: fl[3e3]
}
},
vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
blending: 0,
depthTest: !1,
depthWrite: !1
})).type = "EquirectangularToCubeUV", e;
}
function oa() {
var e = new Kn({
uniforms: {
envMap: {
value: null
},
inputEncoding: {
value: fl[3e3]
},
outputEncoding: {
value: fl[3e3]
}
},
vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
blending: 0,
depthTest: !1,
depthWrite: !1
});
return e.type = "CubemapToCubeUV", e;
}
function sa(e) {
console.warn("$3.ClosedSplineCurve3 has been deprecated. Use $3.CatmullRomCurve3 instead."), 
Dr.call(this, e), this.type = "catmullrom", this.closed = !0;
}
function ca(e) {
console.warn("$3.SplineCurve3 has been deprecated. Use $3.CatmullRomCurve3 instead."), 
Dr.call(this, e), this.type = "catmullrom";
}
function la(e) {
console.warn("$3.Spline has been removed. Use $3.CatmullRomCurve3 instead."), Dr.call(this, e), 
this.type = "catmullrom";
}
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
}), void 0 === Math.sign && (Math.sign = function(e) {
return 0 > e ? -1 : 0 < e ? 1 : +e;
}), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
get: function() {
return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
}
}), void 0 === Object.assign && (Object.assign = function(e) {
if (null == e) throw new TypeError("Cannot convert undefined or null to object");
for (var t = Object(e), n = 1; n < arguments.length; n++) {
var r = arguments[n];
if (null != r) for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
}
return t;
}), Object.assign(t.prototype, {
addEventListener: function(e, t) {
void 0 === this._listeners && (this._listeners = {});
var n = this._listeners;
void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
},
hasEventListener: function(e, t) {
if (void 0 === this._listeners) return !1;
var n = this._listeners;
return void 0 !== n[e] && -1 !== n[e].indexOf(t);
},
removeEventListener: function(e, t) {
void 0 !== this._listeners && (void 0 !== (e = this._listeners[e]) && (-1 !== (t = e.indexOf(t)) && e.splice(t, 1)));
},
dispatchEvent: function(e) {
if (void 0 !== this._listeners) {
var t = this._listeners[e.type];
if (void 0 !== t) {
e.target = this;
for (var n = 0, r = (t = t.slice(0)).length; n < r; n++) t[n].call(this, e);
}
}
}
});
for (var ua = [], ha = 0; 256 > ha; ha++) ua[ha] = (16 > ha ? "0" : "") + ha.toString(16);
var da = {
DEG2RAD: Math.PI / 180,
RAD2DEG: 180 / Math.PI,
generateUUID: function() {
var e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0;
return (ua[255 & e] + ua[e >> 8 & 255] + ua[e >> 16 & 255] + ua[e >> 24 & 255] + "-" + ua[255 & t] + ua[t >> 8 & 255] + "-" + ua[t >> 16 & 15 | 64] + ua[t >> 24 & 255] + "-" + ua[63 & n | 128] + ua[n >> 8 & 255] + "-" + ua[n >> 16 & 255] + ua[n >> 24 & 255] + ua[255 & r] + ua[r >> 8 & 255] + ua[r >> 16 & 255] + ua[r >> 24 & 255]).toUpperCase();
},
clamp: function(e, t, n) {
return Math.max(t, Math.min(n, e));
},
euclideanModulo: function(e, t) {
return (e % t + t) % t;
},
mapLinear: function(e, t, n, r, i) {
return r + (e - t) * (i - r) / (n - t);
},
lerp: function(e, t, n) {
return (1 - n) * e + n * t;
},
smoothstep: function(e, t, n) {
return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
},
smootherstep: function(e, t, n) {
return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
},
randInt: function(e, t) {
return e + Math.floor(Math.random() * (t - e + 1));
},
randFloat: function(e, t) {
return e + Math.random() * (t - e);
},
randFloatSpread: function(e) {
return e * (.5 - Math.random());
},
degToRad: function(e) {
return e * da.DEG2RAD;
},
radToDeg: function(e) {
return e * da.RAD2DEG;
},
isPowerOfTwo: function(e) {
return 0 == (e & e - 1) && 0 !== e;
},
ceilPowerOfTwo: function(e) {
return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
},
floorPowerOfTwo: function(e) {
return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
},
setQuaternionFromProperEuler: function(e, t, n, r, i) {
var a = Math.cos, o = Math.sin, s = a(n / 2);
n = o(n / 2);
var c = a((t + r) / 2), l = o((t + r) / 2), u = a((t - r) / 2), h = o((t - r) / 2);
switch (a = a((r - t) / 2), t = o((r - t) / 2), i) {
case "XYX":
e.set(s * l, n * u, n * h, s * c);
break;

case "YZY":
e.set(n * h, s * l, n * u, s * c);
break;

case "ZXZ":
e.set(n * u, n * h, s * l, s * c);
break;

case "XZX":
e.set(s * l, n * t, n * a, s * c);
break;

case "YXY":
e.set(n * a, s * l, n * t, s * c);
break;

case "ZYZ":
e.set(n * t, n * a, s * l, s * c);
break;

default:
console.warn("$3.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
}
}
};
Object.defineProperties(n.prototype, {
width: {
get: function() {
return this.x;
},
set: function(e) {
this.x = e;
}
},
height: {
get: function() {
return this.y;
},
set: function(e) {
this.y = e;
}
}
}), Object.assign(n.prototype, {
isVector2: !0,
set: function(e, t) {
return this.x = e, this.y = t, this;
},
setScalar: function(e) {
return this.y = this.x = e, this;
},
setX: function(e) {
return this.x = e, this;
},
setY: function(e) {
return this.y = e, this;
},
setComponent: function(e, t) {
switch (e) {
case 0:
this.x = t;
break;

case 1:
this.y = t;
break;

default:
throw Error("index is out of range: " + e);
}
return this;
},
getComponent: function(e) {
switch (e) {
case 0:
return this.x;

case 1:
return this.y;

default:
throw Error("index is out of range: " + e);
}
},
clone: function() {
return new this.constructor(this.x, this.y);
},
copy: function(e) {
return this.x = e.x, this.y = e.y, this;
},
add: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
},
addScalar: function(e) {
return this.x += e, this.y += e, this;
},
addVectors: function(e, t) {
return this.x = e.x + t.x, this.y = e.y + t.y, this;
},
addScaledVector: function(e, t) {
return this.x += e.x * t, this.y += e.y * t, this;
},
sub: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
},
subScalar: function(e) {
return this.x -= e, this.y -= e, this;
},
subVectors: function(e, t) {
return this.x = e.x - t.x, this.y = e.y - t.y, this;
},
multiply: function(e) {
return this.x *= e.x, this.y *= e.y, this;
},
multiplyScalar: function(e) {
return this.x *= e, this.y *= e, this;
},
divide: function(e) {
return this.x /= e.x, this.y /= e.y, this;
},
divideScalar: function(e) {
return this.multiplyScalar(1 / e);
},
applyMatrix3: function(e) {
var t = this.x, n = this.y;
return e = e.elements, this.x = e[0] * t + e[3] * n + e[6], this.y = e[1] * t + e[4] * n + e[7], 
this;
},
min: function(e) {
return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
},
max: function(e) {
return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
},
clamp: function(e, t) {
return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), 
this;
},
clampScalar: function(e, t) {
return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), 
this;
},
clampLength: function(e, t) {
var n = this.length();
return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
},
floor: function() {
return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
},
ceil: function() {
return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
},
round: function() {
return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
},
roundToZero: function() {
return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
this;
},
negate: function() {
return this.x = -this.x, this.y = -this.y, this;
},
dot: function(e) {
return this.x * e.x + this.y * e.y;
},
cross: function(e) {
return this.x * e.y - this.y * e.x;
},
lengthSq: function() {
return this.x * this.x + this.y * this.y;
},
length: function() {
return Math.sqrt(this.x * this.x + this.y * this.y);
},
manhattanLength: function() {
return Math.abs(this.x) + Math.abs(this.y);
},
normalize: function() {
return this.divideScalar(this.length() || 1);
},
angle: function() {
return Math.atan2(-this.y, -this.x) + Math.PI;
},
distanceTo: function(e) {
return Math.sqrt(this.distanceToSquared(e));
},
distanceToSquared: function(e) {
var t = this.x - e.x;
return t * t + (e = this.y - e.y) * e;
},
manhattanDistanceTo: function(e) {
return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
},
setLength: function(e) {
return this.normalize().multiplyScalar(e);
},
lerp: function(e, t) {
return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
},
lerpVectors: function(e, t, n) {
return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
},
equals: function(e) {
return e.x === this.x && e.y === this.y;
},
fromArray: function(e, t) {
return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, 
e;
},
fromBufferAttribute: function(e, t, n) {
return void 0 !== n && console.warn("$3.Vector2: offset has been removed from .fromBufferAttribute()."), 
this.x = e.getX(t), this.y = e.getY(t), this;
},
rotateAround: function(e, t) {
var n = Math.cos(t);
t = Math.sin(t);
var r = this.x - e.x, i = this.y - e.y;
return this.x = r * n - i * t + e.x, this.y = r * t + i * n + e.y, this;
},
random: function() {
return this.x = Math.random(), this.y = Math.random(), this;
}
}), Object.assign(r.prototype, {
isMatrix3: !0,
set: function(e, t, n, r, i, a, o, s, c) {
var l = this.elements;
return l[0] = e, l[1] = r, l[2] = o, l[3] = t, l[4] = i, l[5] = s, l[6] = n, l[7] = a, 
l[8] = c, this;
},
identity: function() {
return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
},
clone: function() {
return new this.constructor().fromArray(this.elements);
},
copy: function(e) {
var t = this.elements;
return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this;
},
extractBasis: function(e, t, n) {
return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), 
this;
},
setFromMatrix4: function(e) {
return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), 
this;
},
multiply: function(e) {
return this.multiplyMatrices(this, e);
},
premultiply: function(e) {
return this.multiplyMatrices(e, this);
},
multiplyMatrices: function(e, t) {
var n = e.elements, r = t.elements;
t = this.elements, e = n[0];
var i = n[3], a = n[6], o = n[1], s = n[4], c = n[7], l = n[2], u = n[5];
n = n[8];
var h = r[0], d = r[3], p = r[6], f = r[1], m = r[4], g = r[7], v = r[2], y = r[5];
return r = r[8], t[0] = e * h + i * f + a * v, t[3] = e * d + i * m + a * y, t[6] = e * p + i * g + a * r, 
t[1] = o * h + s * f + c * v, t[4] = o * d + s * m + c * y, t[7] = o * p + s * g + c * r, 
t[2] = l * h + u * f + n * v, t[5] = l * d + u * m + n * y, t[8] = l * p + u * g + n * r, 
this;
},
multiplyScalar: function(e) {
var t = this.elements;
return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, 
t[5] *= e, t[8] *= e, this;
},
determinant: function() {
var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], c = e[7];
return t * a * (e = e[8]) - t * o * c - n * i * e + n * o * s + r * i * c - r * a * s;
},
getInverse: function(e, t) {
void 0 !== t && console.warn("$3.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
var n = e.elements;
e = this.elements, t = n[0];
var r = n[1], i = n[2], a = n[3], o = n[4], s = n[5], c = n[6], l = n[7], u = (n = n[8]) * o - s * l, h = s * c - n * a, d = l * a - o * c, p = t * u + r * h + i * d;
return 0 === p ? this.set(0, 0, 0, 0, 0, 0, 0, 0, 0) : (p = 1 / p, e[0] = u * p, 
e[1] = (i * l - n * r) * p, e[2] = (s * r - i * o) * p, e[3] = h * p, e[4] = (n * t - i * c) * p, 
e[5] = (i * a - s * t) * p, e[6] = d * p, e[7] = (r * c - l * t) * p, e[8] = (o * t - r * a) * p, 
this);
},
transpose: function() {
var e = this.elements, t = e[1];
return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], 
e[7] = t, this;
},
getNormalMatrix: function(e) {
return this.setFromMatrix4(e).getInverse(this).transpose();
},
transposeIntoArray: function(e) {
var t = this.elements;
return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], 
e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
},
setUvTransform: function(e, t, n, r, i, a, o) {
var s = Math.cos(i);
i = Math.sin(i), this.set(n * s, n * i, -n * (s * a + i * o) + a + e, -r * i, r * s, -r * (-i * a + s * o) + o + t, 0, 0, 1);
},
scale: function(e, t) {
var n = this.elements;
return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
},
rotate: function(e) {
var t = Math.cos(e);
e = Math.sin(e);
var n = this.elements, r = n[0], i = n[3], a = n[6], o = n[1], s = n[4], c = n[7];
return n[0] = t * r + e * o, n[3] = t * i + e * s, n[6] = t * a + e * c, n[1] = -e * r + t * o, 
n[4] = -e * i + t * s, n[7] = -e * a + t * c, this;
},
translate: function(e, t) {
var n = this.elements;
return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], 
n[7] += t * n[8], this;
},
equals: function(e) {
var t = this.elements;
e = e.elements;
for (var n = 0; 9 > n; n++) if (t[n] !== e[n]) return !1;
return !0;
},
fromArray: function(e, t) {
void 0 === t && (t = 0);
for (var n = 0; 9 > n; n++) this.elements[n] = e[n + t];
return this;
},
toArray: function(e, t) {
void 0 === e && (e = []), void 0 === t && (t = 0);
var n = this.elements;
return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], 
e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
}
});
var pa, fa = {
getDataURL: function(e) {
if ("undefined" == typeof HTMLCanvasElement) return e.src;
if (!(e instanceof HTMLCanvasElement)) {
void 0 === pa && (pa = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), 
pa.width = e.width, pa.height = e.height;
var t = pa.getContext("2d");
e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), 
e = pa;
}
return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png");
}
}, ma = 0;
i.DEFAULT_IMAGE = void 0, i.DEFAULT_MAPPING = 300, i.prototype = Object.assign(Object.create(t.prototype), {
constructor: i,
isTexture: !0,
updateMatrix: function() {
this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), 
this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, 
this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, 
this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), 
this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, 
this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, 
this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, 
this.encoding = e.encoding, this;
},
toJSON: function(e) {
var t = void 0 === e || "string" == typeof e;
if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
var n = {
metadata: {
version: 4.5,
type: "Texture",
generator: "Texture.toJSON"
},
uuid: this.uuid,
name: this.name,
mapping: this.mapping,
repeat: [ this.repeat.x, this.repeat.y ],
offset: [ this.offset.x, this.offset.y ],
center: [ this.center.x, this.center.y ],
rotation: this.rotation,
wrap: [ this.wrapS, this.wrapT ],
format: this.format,
type: this.type,
encoding: this.encoding,
minFilter: this.minFilter,
magFilter: this.magFilter,
anisotropy: this.anisotropy,
flipY: this.flipY,
premultiplyAlpha: this.premultiplyAlpha,
unpackAlignment: this.unpackAlignment
};
if (void 0 !== this.image) {
var r = this.image;
if (void 0 === r.uuid && (r.uuid = da.generateUUID()), !t && void 0 === e.images[r.uuid]) {
if (Array.isArray(r)) for (var i = [], a = 0, o = r.length; a < o; a++) i.push(fa.getDataURL(r[a])); else i = fa.getDataURL(r);
e.images[r.uuid] = {
uuid: r.uuid,
url: i
};
}
n.image = r.uuid;
}
return t || (e.textures[this.uuid] = n), n;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
},
transformUv: function(e) {
if (300 !== this.mapping) return e;
if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
case 1e3:
e.x -= Math.floor(e.x);
break;

case 1001:
e.x = 0 > e.x ? 0 : 1;
break;

case 1002:
e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x);
}
if (0 > e.y || 1 < e.y) switch (this.wrapT) {
case 1e3:
e.y -= Math.floor(e.y);
break;

case 1001:
e.y = 0 > e.y ? 0 : 1;
break;

case 1002:
e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y);
}
return this.flipY && (e.y = 1 - e.y), e;
}
}), Object.defineProperty(i.prototype, "needsUpdate", {
set: function(e) {
!0 === e && this.version++;
}
}), Object.defineProperties(a.prototype, {
width: {
get: function() {
return this.z;
},
set: function(e) {
this.z = e;
}
},
height: {
get: function() {
return this.w;
},
set: function(e) {
this.w = e;
}
}
}), Object.assign(a.prototype, {
isVector4: !0,
set: function(e, t, n, r) {
return this.x = e, this.y = t, this.z = n, this.w = r, this;
},
setScalar: function(e) {
return this.w = this.z = this.y = this.x = e, this;
},
setX: function(e) {
return this.x = e, this;
},
setY: function(e) {
return this.y = e, this;
},
setZ: function(e) {
return this.z = e, this;
},
setW: function(e) {
return this.w = e, this;
},
setComponent: function(e, t) {
switch (e) {
case 0:
this.x = t;
break;

case 1:
this.y = t;
break;

case 2:
this.z = t;
break;

case 3:
this.w = t;
break;

default:
throw Error("index is out of range: " + e);
}
return this;
},
getComponent: function(e) {
switch (e) {
case 0:
return this.x;

case 1:
return this.y;

case 2:
return this.z;

case 3:
return this.w;

default:
throw Error("index is out of range: " + e);
}
},
clone: function() {
return new this.constructor(this.x, this.y, this.z, this.w);
},
copy: function(e) {
return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, 
this;
},
add: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, 
this);
},
addScalar: function(e) {
return this.x += e, this.y += e, this.z += e, this.w += e, this;
},
addVectors: function(e, t) {
return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, 
this;
},
addScaledVector: function(e, t) {
return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, 
this;
},
sub: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, 
this);
},
subScalar: function(e) {
return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
},
subVectors: function(e, t) {
return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, 
this;
},
multiplyScalar: function(e) {
return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
},
applyMatrix4: function(e) {
var t = this.x, n = this.y, r = this.z, i = this.w;
return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, 
this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, 
this;
},
divideScalar: function(e) {
return this.multiplyScalar(1 / e);
},
setAxisAngleFromQuaternion: function(e) {
this.w = 2 * Math.acos(e.w);
var t = Math.sqrt(1 - e.w * e.w);
return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, 
this.z = e.z / t), this;
},
setAxisAngleFromRotationMatrix: function(e) {
var t = (e = e.elements)[0], n = e[4], r = e[8], i = e[1], a = e[5], o = e[9], s = e[2], c = e[6], l = e[10];
return .01 > Math.abs(n - i) && .01 > Math.abs(r - s) && .01 > Math.abs(o - c) ? .1 > Math.abs(n + i) && .1 > Math.abs(r + s) && .1 > Math.abs(o + c) && .1 > Math.abs(t + a + l - 3) ? (this.set(1, 0, 0, 0), 
this) : (e = Math.PI, l = (l + 1) / 2, n = (n + i) / 4, r = (r + s) / 4, o = (o + c) / 4, 
(t = (t + 1) / 2) > (a = (a + 1) / 2) && t > l ? .01 > t ? (c = 0, n = s = .707106781) : (s = n / (c = Math.sqrt(t)), 
n = r / c) : a > l ? .01 > a ? (c = .707106781, s = 0, n = .707106781) : (c = n / (s = Math.sqrt(a)), 
n = o / s) : .01 > l ? (s = c = .707106781, n = 0) : (c = r / (n = Math.sqrt(l)), 
s = o / n), this.set(c, s, n, e), this) : (e = Math.sqrt((c - o) * (c - o) + (r - s) * (r - s) + (i - n) * (i - n)), 
.001 > Math.abs(e) && (e = 1), this.x = (c - o) / e, this.y = (r - s) / e, this.z = (i - n) / e, 
this.w = Math.acos((t + a + l - 1) / 2), this);
},
min: function(e) {
return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), 
this.w = Math.min(this.w, e.w), this;
},
max: function(e) {
return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), 
this.w = Math.max(this.w, e.w), this;
},
clamp: function(e, t) {
return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), 
this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), 
this;
},
clampScalar: function(e, t) {
return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), 
this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), 
this;
},
clampLength: function(e, t) {
var n = this.length();
return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
},
floor: function() {
return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
this.w = Math.floor(this.w), this;
},
ceil: function() {
return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
this.w = Math.ceil(this.w), this;
},
round: function() {
return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
this.w = Math.round(this.w), this;
},
roundToZero: function() {
return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), 
this;
},
negate: function() {
return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
},
dot: function(e) {
return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
},
lengthSq: function() {
return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
},
length: function() {
return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
},
manhattanLength: function() {
return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
},
normalize: function() {
return this.divideScalar(this.length() || 1);
},
setLength: function(e) {
return this.normalize().multiplyScalar(e);
},
lerp: function(e, t) {
return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, 
this.w += (e.w - this.w) * t, this;
},
lerpVectors: function(e, t, n) {
return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, 
this.w = e.w + (t.w - e.w) * n, this;
},
equals: function(e) {
return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
},
fromArray: function(e, t) {
return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], 
this.w = e[t + 3], this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, 
e[t + 2] = this.z, e[t + 3] = this.w, e;
},
fromBufferAttribute: function(e, t, n) {
return void 0 !== n && console.warn("$3.Vector4: offset has been removed from .fromBufferAttribute()."), 
this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), 
this;
},
random: function() {
return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), 
this;
}
}), o.prototype = Object.assign(Object.create(t.prototype), {
constructor: o,
isWebGLRenderTarget: !0,
setSize: function(e, t) {
this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, 
this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), 
this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, 
this.depthTexture = e.depthTexture, this;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
}
}), s.prototype = Object.assign(Object.create(o.prototype), {
constructor: s,
isWebGLMultisampleRenderTarget: !0,
copy: function(e) {
return o.prototype.copy.call(this, e), this.samples = e.samples, this;
}
}), Object.assign(c, {
slerp: function(e, t, n, r) {
return n.copy(e).slerp(t, r);
},
slerpFlat: function(e, t, n, r, i, a, o) {
var s = n[r + 0], c = n[r + 1], l = n[r + 2];
n = n[r + 3], r = i[a + 0];
var u = i[a + 1], h = i[a + 2];
if (n !== (i = i[a + 3]) || s !== r || c !== u || l !== h) {
a = 1 - o;
var d = s * r + c * u + l * h + n * i, p = 0 <= d ? 1 : -1, f = 1 - d * d;
f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), a = Math.sin(a * d) / f, 
o = Math.sin(o * d) / f), s = s * a + r * (p *= o), c = c * a + u * p, l = l * a + h * p, 
n = n * a + i * p, a === 1 - o && (s *= o = 1 / Math.sqrt(s * s + c * c + l * l + n * n), 
c *= o, l *= o, n *= o);
}
e[t] = s, e[t + 1] = c, e[t + 2] = l, e[t + 3] = n;
},
multiplyQuaternionsFlat: function(e, t, n, r, i, a) {
var o = n[r], s = n[r + 1], c = n[r + 2];
n = n[r + 3], r = i[a];
var l = i[a + 1], u = i[a + 2];
return i = i[a + 3], e[t] = o * i + n * r + s * u - c * l, e[t + 1] = s * i + n * l + c * r - o * u, 
e[t + 2] = c * i + n * u + o * l - s * r, e[t + 3] = n * i - o * r - s * l - c * u, 
e;
}
}), Object.defineProperties(c.prototype, {
x: {
get: function() {
return this._x;
},
set: function(e) {
this._x = e, this._onChangeCallback();
}
},
y: {
get: function() {
return this._y;
},
set: function(e) {
this._y = e, this._onChangeCallback();
}
},
z: {
get: function() {
return this._z;
},
set: function(e) {
this._z = e, this._onChangeCallback();
}
},
w: {
get: function() {
return this._w;
},
set: function(e) {
this._w = e, this._onChangeCallback();
}
}
}), Object.assign(c.prototype, {
isQuaternion: !0,
set: function(e, t, n, r) {
return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), 
this;
},
clone: function() {
return new this.constructor(this._x, this._y, this._z, this._w);
},
copy: function(e) {
return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), 
this;
},
setFromEuler: function(e, t) {
if (!e || !e.isEuler) throw Error("$3.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
var n = e._x, r = e._y, i = e._z;
e = e.order;
var a = Math.cos, o = Math.sin, s = a(n / 2), c = a(r / 2);
switch (a = a(i / 2), n = o(n / 2), r = o(r / 2), i = o(i / 2), e) {
case "XYZ":
this._x = n * c * a + s * r * i, this._y = s * r * a - n * c * i, this._z = s * c * i + n * r * a, 
this._w = s * c * a - n * r * i;
break;

case "YXZ":
this._x = n * c * a + s * r * i, this._y = s * r * a - n * c * i, this._z = s * c * i - n * r * a, 
this._w = s * c * a + n * r * i;
break;

case "ZXY":
this._x = n * c * a - s * r * i, this._y = s * r * a + n * c * i, this._z = s * c * i + n * r * a, 
this._w = s * c * a - n * r * i;
break;

case "ZYX":
this._x = n * c * a - s * r * i, this._y = s * r * a + n * c * i, this._z = s * c * i - n * r * a, 
this._w = s * c * a + n * r * i;
break;

case "YZX":
this._x = n * c * a + s * r * i, this._y = s * r * a + n * c * i, this._z = s * c * i - n * r * a, 
this._w = s * c * a - n * r * i;
break;

case "XZY":
this._x = n * c * a - s * r * i, this._y = s * r * a - n * c * i, this._z = s * c * i + n * r * a, 
this._w = s * c * a + n * r * i;
break;

default:
console.warn("$3.Quaternion: .setFromEuler() encountered an unknown order: " + e);
}
return !1 !== t && this._onChangeCallback(), this;
},
setFromAxisAngle: function(e, t) {
t /= 2;
var n = Math.sin(t);
return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(t), 
this._onChangeCallback(), this;
},
setFromRotationMatrix: function(e) {
var t = e.elements, n = t[0];
e = t[4];
var r = t[8], i = t[1], a = t[5], o = t[9], s = t[2], c = t[6], l = n + a + (t = t[10]);
return 0 < l ? (n = .5 / Math.sqrt(l + 1), this._w = .25 / n, this._x = (c - o) * n, 
this._y = (r - s) * n, this._z = (i - e) * n) : n > a && n > t ? (n = 2 * Math.sqrt(1 + n - a - t), 
this._w = (c - o) / n, this._x = .25 * n, this._y = (e + i) / n, this._z = (r + s) / n) : a > t ? (n = 2 * Math.sqrt(1 + a - n - t), 
this._w = (r - s) / n, this._x = (e + i) / n, this._y = .25 * n, this._z = (o + c) / n) : (n = 2 * Math.sqrt(1 + t - n - a), 
this._w = (i - e) / n, this._x = (r + s) / n, this._y = (o + c) / n, this._z = .25 * n), 
this._onChangeCallback(), this;
},
setFromUnitVectors: function(e, t) {
var n = e.dot(t) + 1;
return 1e-6 > n ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, 
this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, 
this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, 
this.normalize();
},
angleTo: function(e) {
return 2 * Math.acos(Math.abs(da.clamp(this.dot(e), -1, 1)));
},
rotateTowards: function(e, t) {
var n = this.angleTo(e);
return 0 === n ? this : (this.slerp(e, Math.min(1, t / n)), this);
},
inverse: function() {
return this.conjugate();
},
conjugate: function() {
return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
},
dot: function(e) {
return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
},
lengthSq: function() {
return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
},
length: function() {
return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
},
normalize: function() {
var e = this.length();
return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, 
this._y *= e, this._z *= e, this._w *= e), this._onChangeCallback(), this;
},
multiply: function(e, t) {
return void 0 !== t ? (console.warn("$3.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
},
premultiply: function(e) {
return this.multiplyQuaternions(e, this);
},
multiplyQuaternions: function(e, t) {
var n = e._x, r = e._y, i = e._z;
e = e._w;
var a = t._x, o = t._y, s = t._z;
return t = t._w, this._x = n * t + e * a + r * s - i * o, this._y = r * t + e * o + i * a - n * s, 
this._z = i * t + e * s + n * o - r * a, this._w = e * t - n * a - r * o - i * s, 
this._onChangeCallback(), this;
},
slerp: function(e, t) {
if (0 === t) return this;
if (1 === t) return this.copy(e);
var n = this._x, r = this._y, i = this._z, a = this._w, o = a * e._w + n * e._x + r * e._y + i * e._z;
if (0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, 
o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = n, this._y = r, this._z = i, 
this;
if ((e = 1 - o * o) <= Number.EPSILON) return o = 1 - t, this._w = o * a + t * this._w, 
this._x = o * n + t * this._x, this._y = o * r + t * this._y, this._z = o * i + t * this._z, 
this.normalize(), this._onChangeCallback(), this;
e = Math.sqrt(e);
var s = Math.atan2(e, o);
return o = Math.sin((1 - t) * s) / e, t = Math.sin(t * s) / e, this._w = a * o + this._w * t, 
this._x = n * o + this._x * t, this._y = r * o + this._y * t, this._z = i * o + this._z * t, 
this._onChangeCallback(), this;
},
equals: function(e) {
return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
},
fromArray: function(e, t) {
return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], 
this._w = e[t + 3], this._onChangeCallback(), this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, 
e[t + 2] = this._z, e[t + 3] = this._w, e;
},
fromBufferAttribute: function(e, t) {
return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), 
this;
},
_onChange: function(e) {
return this._onChangeCallback = e, this;
},
_onChangeCallback: function() {}
});
var ga = new l(), va = new c();
Object.assign(l.prototype, {
isVector3: !0,
set: function(e, t, n) {
return this.x = e, this.y = t, this.z = n, this;
},
setScalar: function(e) {
return this.z = this.y = this.x = e, this;
},
setX: function(e) {
return this.x = e, this;
},
setY: function(e) {
return this.y = e, this;
},
setZ: function(e) {
return this.z = e, this;
},
setComponent: function(e, t) {
switch (e) {
case 0:
this.x = t;
break;

case 1:
this.y = t;
break;

case 2:
this.z = t;
break;

default:
throw Error("index is out of range: " + e);
}
return this;
},
getComponent: function(e) {
switch (e) {
case 0:
return this.x;

case 1:
return this.y;

case 2:
return this.z;

default:
throw Error("index is out of range: " + e);
}
},
clone: function() {
return new this.constructor(this.x, this.y, this.z);
},
copy: function(e) {
return this.x = e.x, this.y = e.y, this.z = e.z, this;
},
add: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
},
addScalar: function(e) {
return this.x += e, this.y += e, this.z += e, this;
},
addVectors: function(e, t) {
return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
},
addScaledVector: function(e, t) {
return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
},
sub: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
},
subScalar: function(e) {
return this.x -= e, this.y -= e, this.z -= e, this;
},
subVectors: function(e, t) {
return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
},
multiply: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
},
multiplyScalar: function(e) {
return this.x *= e, this.y *= e, this.z *= e, this;
},
multiplyVectors: function(e, t) {
return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
},
applyEuler: function(e) {
return e && e.isEuler || console.error("$3.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), 
this.applyQuaternion(va.setFromEuler(e));
},
applyAxisAngle: function(e, t) {
return this.applyQuaternion(va.setFromAxisAngle(e, t));
},
applyMatrix3: function(e) {
var t = this.x, n = this.y, r = this.z;
return e = e.elements, this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, 
this.z = e[2] * t + e[5] * n + e[8] * r, this;
},
applyNormalMatrix: function(e) {
return this.applyMatrix3(e).normalize();
},
applyMatrix4: function(e) {
var t = this.x, n = this.y, r = this.z, i = 1 / ((e = e.elements)[3] * t + e[7] * n + e[11] * r + e[15]);
return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i, this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i, 
this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i, this;
},
applyQuaternion: function(e) {
var t = this.x, n = this.y, r = this.z, i = e.x, a = e.y, o = e.z, s = (e = e.w) * t + a * r - o * n, c = e * n + o * t - i * r, l = e * r + i * n - a * t;
return t = -i * t - a * n - o * r, this.x = s * e + t * -i + c * -o - l * -a, this.y = c * e + t * -a + l * -i - s * -o, 
this.z = l * e + t * -o + s * -a - c * -i, this;
},
project: function(e) {
return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
},
unproject: function(e) {
return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
},
transformDirection: function(e) {
var t = this.x, n = this.y, r = this.z;
return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, 
this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize();
},
divide: function(e) {
return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
},
divideScalar: function(e) {
return this.multiplyScalar(1 / e);
},
min: function(e) {
return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), 
this;
},
max: function(e) {
return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), 
this;
},
clamp: function(e, t) {
return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), 
this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
},
clampScalar: function(e, t) {
return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), 
this.z = Math.max(e, Math.min(t, this.z)), this;
},
clampLength: function(e, t) {
var n = this.length();
return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
},
floor: function() {
return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
this;
},
ceil: function() {
return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
this;
},
round: function() {
return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
this;
},
roundToZero: function() {
return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
},
negate: function() {
return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
},
dot: function(e) {
return this.x * e.x + this.y * e.y + this.z * e.z;
},
lengthSq: function() {
return this.x * this.x + this.y * this.y + this.z * this.z;
},
length: function() {
return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
},
manhattanLength: function() {
return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
},
normalize: function() {
return this.divideScalar(this.length() || 1);
},
setLength: function(e) {
return this.normalize().multiplyScalar(e);
},
lerp: function(e, t) {
return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, 
this;
},
lerpVectors: function(e, t, n) {
return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, 
this;
},
cross: function(e, t) {
return void 0 !== t ? (console.warn("$3.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
this.crossVectors(e, t)) : this.crossVectors(this, e);
},
crossVectors: function(e, t) {
var n = e.x, r = e.y;
e = e.z;
var i = t.x, a = t.y;
return t = t.z, this.x = r * t - e * a, this.y = e * i - n * t, this.z = n * a - r * i, 
this;
},
projectOnVector: function(e) {
var t = e.lengthSq();
return 0 === t ? this.set(0, 0, 0) : (t = e.dot(this) / t, this.copy(e).multiplyScalar(t));
},
projectOnPlane: function(e) {
return ga.copy(this).projectOnVector(e), this.sub(ga);
},
reflect: function(e) {
return this.sub(ga.copy(e).multiplyScalar(2 * this.dot(e)));
},
angleTo: function(e) {
var t = Math.sqrt(this.lengthSq() * e.lengthSq());
return 0 === t ? Math.PI / 2 : (e = this.dot(e) / t, Math.acos(da.clamp(e, -1, 1)));
},
distanceTo: function(e) {
return Math.sqrt(this.distanceToSquared(e));
},
distanceToSquared: function(e) {
var t = this.x - e.x, n = this.y - e.y;
return t * t + n * n + (e = this.z - e.z) * e;
},
manhattanDistanceTo: function(e) {
return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
},
setFromSpherical: function(e) {
return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
},
setFromSphericalCoords: function(e, t, n) {
var r = Math.sin(t) * e;
return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), 
this;
},
setFromCylindrical: function(e) {
return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
},
setFromCylindricalCoords: function(e, t, n) {
return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
},
setFromMatrixPosition: function(e) {
return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this;
},
setFromMatrixScale: function(e) {
var t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length();
return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = n, this.z = e, 
this;
},
setFromMatrixColumn: function(e, t) {
return this.fromArray(e.elements, 4 * t);
},
setFromMatrix3Column: function(e, t) {
return this.fromArray(e.elements, 3 * t);
},
equals: function(e) {
return e.x === this.x && e.y === this.y && e.z === this.z;
},
fromArray: function(e, t) {
return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], 
this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, 
e[t + 2] = this.z, e;
},
fromBufferAttribute: function(e, t, n) {
return void 0 !== n && console.warn("$3.Vector3: offset has been removed from .fromBufferAttribute()."), 
this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
},
random: function() {
return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
}
});
var ya = new l(), $a = new u(), ba = new l(0, 0, 0), xa = new l(1, 1, 1), wa = new l(), _a = new l(), Ma = new l();
Object.assign(u.prototype, {
isMatrix4: !0,
set: function(e, t, n, r, i, a, o, s, c, l, u, h, d, p, f, m) {
var g = this.elements;
return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = a, g[9] = o, g[13] = s, 
g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, 
this;
},
identity: function() {
return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
},
clone: function() {
return new u().fromArray(this.elements);
},
copy: function(e) {
var t = this.elements;
return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], 
t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this;
},
copyPosition: function(e) {
var t = this.elements;
return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this;
},
extractBasis: function(e, t, n) {
return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), 
this;
},
makeBasis: function(e, t, n) {
return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), 
this;
},
extractRotation: function(e) {
var t = this.elements, n = e.elements, r = 1 / ya.setFromMatrixColumn(e, 0).length(), i = 1 / ya.setFromMatrixColumn(e, 1).length();
return e = 1 / ya.setFromMatrixColumn(e, 2).length(), t[0] = n[0] * r, t[1] = n[1] * r, 
t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, 
t[8] = n[8] * e, t[9] = n[9] * e, t[10] = n[10] * e, t[11] = 0, t[12] = 0, t[13] = 0, 
t[14] = 0, t[15] = 1, this;
},
makeRotationFromEuler: function(e) {
e && e.isEuler || console.error("$3.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
var t = this.elements, n = e.x, r = e.y, i = e.z, a = Math.cos(n);
n = Math.sin(n);
var o = Math.cos(r);
r = Math.sin(r);
var s = Math.cos(i);
if (i = Math.sin(i), "XYZ" === e.order) {
e = a * s;
var c = a * i, l = n * s, u = n * i;
t[0] = o * s, t[4] = -o * i, t[8] = r, t[1] = c + l * r, t[5] = e - u * r, t[9] = -n * o, 
t[2] = u - e * r, t[6] = l + c * r, t[10] = a * o;
} else "YXZ" === e.order ? (e = o * s, c = o * i, l = r * s, u = r * i, t[0] = e + u * n, 
t[4] = l * n - c, t[8] = a * r, t[1] = a * i, t[5] = a * s, t[9] = -n, t[2] = c * n - l, 
t[6] = u + e * n, t[10] = a * o) : "ZXY" === e.order ? (e = o * s, c = o * i, l = r * s, 
u = r * i, t[0] = e - u * n, t[4] = -a * i, t[8] = l + c * n, t[1] = c + l * n, 
t[5] = a * s, t[9] = u - e * n, t[2] = -a * r, t[6] = n, t[10] = a * o) : "ZYX" === e.order ? (e = a * s, 
c = a * i, l = n * s, u = n * i, t[0] = o * s, t[4] = l * r - c, t[8] = e * r + u, 
t[1] = o * i, t[5] = u * r + e, t[9] = c * r - l, t[2] = -r, t[6] = n * o, t[10] = a * o) : "YZX" === e.order ? (e = a * o, 
c = a * r, l = n * o, u = n * r, t[0] = o * s, t[4] = u - e * i, t[8] = l * i + c, 
t[1] = i, t[5] = a * s, t[9] = -n * s, t[2] = -r * s, t[6] = c * i + l, t[10] = e - u * i) : "XZY" === e.order && (e = a * o, 
c = a * r, l = n * o, u = n * r, t[0] = o * s, t[4] = -i, t[8] = r * s, t[1] = e * i + u, 
t[5] = a * s, t[9] = c * i - l, t[2] = l * i - c, t[6] = n * s, t[10] = u * i + e);
return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
this;
},
makeRotationFromQuaternion: function(e) {
return this.compose(ba, e, xa);
},
lookAt: function(e, t, n) {
var r = this.elements;
return Ma.subVectors(e, t), 0 === Ma.lengthSq() && (Ma.z = 1), Ma.normalize(), wa.crossVectors(n, Ma), 
0 === wa.lengthSq() && (1 === Math.abs(n.z) ? Ma.x += 1e-4 : Ma.z += 1e-4, Ma.normalize(), 
wa.crossVectors(n, Ma)), wa.normalize(), _a.crossVectors(Ma, wa), r[0] = wa.x, r[4] = _a.x, 
r[8] = Ma.x, r[1] = wa.y, r[5] = _a.y, r[9] = Ma.y, r[2] = wa.z, r[6] = _a.z, r[10] = Ma.z, 
this;
},
multiply: function(e, t) {
return void 0 !== t ? (console.warn("$3.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
},
premultiply: function(e) {
return this.multiplyMatrices(e, this);
},
multiplyMatrices: function(e, t) {
var n = e.elements, r = t.elements;
t = this.elements, e = n[0];
var i = n[4], a = n[8], o = n[12], s = n[1], c = n[5], l = n[9], u = n[13], h = n[2], d = n[6], p = n[10], f = n[14], m = n[3], g = n[7], v = n[11];
n = n[15];
var y = r[0], $ = r[4], b = r[8], x = r[12], w = r[1], _ = r[5], M = r[9], S = r[13], A = r[2], T = r[6], L = r[10], C = r[14], E = r[3], P = r[7], k = r[11];
return r = r[15], t[0] = e * y + i * w + a * A + o * E, t[4] = e * $ + i * _ + a * T + o * P, 
t[8] = e * b + i * M + a * L + o * k, t[12] = e * x + i * S + a * C + o * r, t[1] = s * y + c * w + l * A + u * E, 
t[5] = s * $ + c * _ + l * T + u * P, t[9] = s * b + c * M + l * L + u * k, t[13] = s * x + c * S + l * C + u * r, 
t[2] = h * y + d * w + p * A + f * E, t[6] = h * $ + d * _ + p * T + f * P, t[10] = h * b + d * M + p * L + f * k, 
t[14] = h * x + d * S + p * C + f * r, t[3] = m * y + g * w + v * A + n * E, t[7] = m * $ + g * _ + v * T + n * P, 
t[11] = m * b + g * M + v * L + n * k, t[15] = m * x + g * S + v * C + n * r, this;
},
multiplyScalar: function(e) {
var t = this.elements;
return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, 
t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, 
t[11] *= e, t[15] *= e, this;
},
determinant: function() {
var e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], a = e[1], o = e[5], s = e[9], c = e[13], l = e[2], u = e[6], h = e[10], d = e[14];
return e[3] * (+i * s * u - r * c * u - i * o * h + n * c * h + r * o * d - n * s * d) + e[7] * (+t * s * d - t * c * h + i * a * h - r * a * d + r * c * l - i * s * l) + e[11] * (+t * c * u - t * o * d - i * a * u + n * a * d + i * o * l - n * c * l) + e[15] * (-r * o * l - t * s * u + t * o * h + r * a * u - n * a * h + n * s * l);
},
transpose: function() {
var e = this.elements, t = e[1];
return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], 
e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, 
t = e[11], e[11] = e[14], e[14] = t, this;
},
setPosition: function(e, t, n) {
var r = this.elements;
return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, 
r[14] = n), this;
},
getInverse: function(e, t) {
void 0 !== t && console.warn("$3.Matrix4: .getInverse() can no longer be configured to throw on degenerate."), 
t = this.elements;
var n = e.elements;
e = n[0];
var r = n[1], i = n[2], a = n[3], o = n[4], s = n[5], c = n[6], l = n[7], u = n[8], h = n[9], d = n[10], p = n[11], f = n[12], m = n[13], g = n[14], v = h * g * l - m * d * l + m * c * p - s * g * p - h * c * (n = n[15]) + s * d * n, y = f * d * l - u * g * l - f * c * p + o * g * p + u * c * n - o * d * n, $ = u * m * l - f * h * l + f * s * p - o * m * p - u * s * n + o * h * n, b = f * h * c - u * m * c - f * s * d + o * m * d + u * s * g - o * h * g, x = e * v + r * y + i * $ + a * b;
return 0 === x ? this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) : (x = 1 / x, 
t[0] = v * x, t[1] = (m * d * a - h * g * a - m * i * p + r * g * p + h * i * n - r * d * n) * x, 
t[2] = (s * g * a - m * c * a + m * i * l - r * g * l - s * i * n + r * c * n) * x, 
t[3] = (h * c * a - s * d * a - h * i * l + r * d * l + s * i * p - r * c * p) * x, 
t[4] = y * x, t[5] = (u * g * a - f * d * a + f * i * p - e * g * p - u * i * n + e * d * n) * x, 
t[6] = (f * c * a - o * g * a - f * i * l + e * g * l + o * i * n - e * c * n) * x, 
t[7] = (o * d * a - u * c * a + u * i * l - e * d * l - o * i * p + e * c * p) * x, 
t[8] = $ * x, t[9] = (f * h * a - u * m * a - f * r * p + e * m * p + u * r * n - e * h * n) * x, 
t[10] = (o * m * a - f * s * a + f * r * l - e * m * l - o * r * n + e * s * n) * x, 
t[11] = (u * s * a - o * h * a - u * r * l + e * h * l + o * r * p - e * s * p) * x, 
t[12] = b * x, t[13] = (u * m * i - f * h * i + f * r * d - e * m * d - u * r * g + e * h * g) * x, 
t[14] = (f * s * i - o * m * i - f * r * c + e * m * c + o * r * g - e * s * g) * x, 
t[15] = (o * h * i - u * s * i + u * r * c - e * h * c - o * r * d + e * s * d) * x, 
this);
},
scale: function(e) {
var t = this.elements, n = e.x, r = e.y;
return e = e.z, t[0] *= n, t[4] *= r, t[8] *= e, t[1] *= n, t[5] *= r, t[9] *= e, 
t[2] *= n, t[6] *= r, t[10] *= e, t[3] *= n, t[7] *= r, t[11] *= e, this;
},
getMaxScaleOnAxis: function() {
var e = this.elements;
return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]));
},
makeTranslation: function(e, t, n) {
return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
},
makeRotationX: function(e) {
var t = Math.cos(e);
return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), 
this;
},
makeRotationY: function(e) {
var t = Math.cos(e);
return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), 
this;
},
makeRotationZ: function(e) {
var t = Math.cos(e);
return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
this;
},
makeRotationAxis: function(e, t) {
var n = Math.cos(t);
t = Math.sin(t);
var r = 1 - n, i = e.x, a = e.y;
e = e.z;
var o = r * i, s = r * a;
return this.set(o * i + n, o * a - t * e, o * e + t * a, 0, o * a + t * e, s * a + n, s * e - t * i, 0, o * e - t * a, s * e + t * i, r * e * e + n, 0, 0, 0, 0, 1), 
this;
},
makeScale: function(e, t, n) {
return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
},
makeShear: function(e, t, n) {
return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
},
compose: function(e, t, n) {
var r = this.elements, i = t._x, a = t._y, o = t._z, s = t._w, c = i + i, l = a + a, u = o + o;
t = i * c;
var h = i * l;
i *= u;
var d = a * l;
a *= u, o *= u, c *= s, l *= s, s *= u, u = n.x;
var p = n.y;
return n = n.z, r[0] = (1 - (d + o)) * u, r[1] = (h + s) * u, r[2] = (i - l) * u, 
r[3] = 0, r[4] = (h - s) * p, r[5] = (1 - (t + o)) * p, r[6] = (a + c) * p, r[7] = 0, 
r[8] = (i + l) * n, r[9] = (a - c) * n, r[10] = (1 - (t + d)) * n, r[11] = 0, r[12] = e.x, 
r[13] = e.y, r[14] = e.z, r[15] = 1, this;
},
decompose: function(e, t, n) {
var r = this.elements, i = ya.set(r[0], r[1], r[2]).length(), a = ya.set(r[4], r[5], r[6]).length(), o = ya.set(r[8], r[9], r[10]).length();
0 > this.determinant() && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], $a.copy(this), 
e = 1 / i, r = 1 / a;
var s = 1 / o;
return $a.elements[0] *= e, $a.elements[1] *= e, $a.elements[2] *= e, $a.elements[4] *= r, 
$a.elements[5] *= r, $a.elements[6] *= r, $a.elements[8] *= s, $a.elements[9] *= s, 
$a.elements[10] *= s, t.setFromRotationMatrix($a), n.x = i, n.y = a, n.z = o, this;
},
makePerspective: function(e, t, n, r, i, a) {
void 0 === a && console.warn("$3.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
var o = this.elements;
return o[0] = 2 * i / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, 
o[5] = 2 * i / (n - r), o[9] = (n + r) / (n - r), o[13] = 0, o[2] = 0, o[6] = 0, 
o[10] = -(a + i) / (a - i), o[14] = -2 * a * i / (a - i), o[3] = 0, o[7] = 0, o[11] = -1, 
o[15] = 0, this;
},
makeOrthographic: function(e, t, n, r, i, a) {
var o = this.elements, s = 1 / (t - e), c = 1 / (n - r), l = 1 / (a - i);
return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -(t + e) * s, o[1] = 0, o[5] = 2 * c, 
o[9] = 0, o[13] = -(n + r) * c, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -(a + i) * l, 
o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
},
equals: function(e) {
var t = this.elements;
e = e.elements;
for (var n = 0; 16 > n; n++) if (t[n] !== e[n]) return !1;
return !0;
},
fromArray: function(e, t) {
void 0 === t && (t = 0);
for (var n = 0; 16 > n; n++) this.elements[n] = e[n + t];
return this;
},
toArray: function(e, t) {
void 0 === e && (e = []), void 0 === t && (t = 0);
var n = this.elements;
return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], 
e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], 
e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], 
e[t + 15] = n[15], e;
}
});
var Sa = new u(), Aa = new c();
h.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), h.DefaultOrder = "XYZ", 
Object.defineProperties(h.prototype, {
x: {
get: function() {
return this._x;
},
set: function(e) {
this._x = e, this._onChangeCallback();
}
},
y: {
get: function() {
return this._y;
},
set: function(e) {
this._y = e, this._onChangeCallback();
}
},
z: {
get: function() {
return this._z;
},
set: function(e) {
this._z = e, this._onChangeCallback();
}
},
order: {
get: function() {
return this._order;
},
set: function(e) {
this._order = e, this._onChangeCallback();
}
}
}), Object.assign(h.prototype, {
isEuler: !0,
set: function(e, t, n, r) {
return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), 
this;
},
clone: function() {
return new this.constructor(this._x, this._y, this._z, this._order);
},
copy: function(e) {
return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), 
this;
},
setFromRotationMatrix: function(e, t, n) {
var r = da.clamp, i = e.elements;
e = i[0];
var a = i[4], o = i[8], s = i[1], c = i[5], l = i[9], u = i[2], h = i[6];
switch (i = i[10], t = t || this._order) {
case "XYZ":
this._y = Math.asin(r(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-l, i), 
this._z = Math.atan2(-a, e)) : (this._x = Math.atan2(h, c), this._z = 0);
break;

case "YXZ":
this._x = Math.asin(-r(l, -1, 1)), .9999999 > Math.abs(l) ? (this._y = Math.atan2(o, i), 
this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-u, e), this._z = 0);
break;

case "ZXY":
this._x = Math.asin(r(h, -1, 1)), .9999999 > Math.abs(h) ? (this._y = Math.atan2(-u, i), 
this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(s, e));
break;

case "ZYX":
this._y = Math.asin(-r(u, -1, 1)), .9999999 > Math.abs(u) ? (this._x = Math.atan2(h, i), 
this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-a, c));
break;

case "YZX":
this._z = Math.asin(r(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-l, c), 
this._y = Math.atan2(-u, e)) : (this._x = 0, this._y = Math.atan2(o, i));
break;

case "XZY":
this._z = Math.asin(-r(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(h, c), 
this._y = Math.atan2(o, e)) : (this._x = Math.atan2(-l, i), this._y = 0);
break;

default:
console.warn("$3.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
}
return this._order = t, !1 !== n && this._onChangeCallback(), this;
},
setFromQuaternion: function(e, t, n) {
return Sa.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Sa, t, n);
},
setFromVector3: function(e, t) {
return this.set(e.x, e.y, e.z, t || this._order);
},
reorder: function(e) {
return Aa.setFromEuler(this), this.setFromQuaternion(Aa, e);
},
equals: function(e) {
return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
},
fromArray: function(e) {
return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), 
this._onChangeCallback(), this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, 
e[t + 2] = this._z, e[t + 3] = this._order, e;
},
toVector3: function(e) {
return e ? e.set(this._x, this._y, this._z) : new l(this._x, this._y, this._z);
},
_onChange: function(e) {
return this._onChangeCallback = e, this;
},
_onChangeCallback: function() {}
}), Object.assign(d.prototype, {
set: function(e) {
this.mask = 1 << e | 0;
},
enable: function(e) {
this.mask = this.mask | 1 << e | 0;
},
enableAll: function() {
this.mask = -1;
},
toggle: function(e) {
this.mask ^= 1 << e | 0;
},
disable: function(e) {
this.mask &= ~(1 << e | 0);
},
disableAll: function() {
this.mask = 0;
},
test: function(e) {
return 0 != (this.mask & e.mask);
}
});
var Ta = 0, La = new l(), Ca = new c(), Ea = new u(), Pa = new l(), ka = new l(), Oa = new l(), Da = new c(), Na = new l(1, 0, 0), Ia = new l(0, 1, 0), Ra = new l(0, 0, 1), ja = {
type: "added"
}, Ua = {
type: "removed"
};
p.DefaultUp = new l(0, 1, 0), p.DefaultMatrixAutoUpdate = !0, p.prototype = Object.assign(Object.create(t.prototype), {
constructor: p,
isObject3D: !0,
onBeforeRender: function() {},
onAfterRender: function() {},
applyMatrix4: function(e) {
this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
},
applyQuaternion: function(e) {
return this.quaternion.premultiply(e), this;
},
setRotationFromAxisAngle: function(e, t) {
this.quaternion.setFromAxisAngle(e, t);
},
setRotationFromEuler: function(e) {
this.quaternion.setFromEuler(e, !0);
},
setRotationFromMatrix: function(e) {
this.quaternion.setFromRotationMatrix(e);
},
setRotationFromQuaternion: function(e) {
this.quaternion.copy(e);
},
rotateOnAxis: function(e, t) {
return Ca.setFromAxisAngle(e, t), this.quaternion.multiply(Ca), this;
},
rotateOnWorldAxis: function(e, t) {
return Ca.setFromAxisAngle(e, t), this.quaternion.premultiply(Ca), this;
},
rotateX: function(e) {
return this.rotateOnAxis(Na, e);
},
rotateY: function(e) {
return this.rotateOnAxis(Ia, e);
},
rotateZ: function(e) {
return this.rotateOnAxis(Ra, e);
},
translateOnAxis: function(e, t) {
return La.copy(e).applyQuaternion(this.quaternion), this.position.add(La.multiplyScalar(t)), 
this;
},
translateX: function(e) {
return this.translateOnAxis(Na, e);
},
translateY: function(e) {
return this.translateOnAxis(Ia, e);
},
translateZ: function(e) {
return this.translateOnAxis(Ra, e);
},
localToWorld: function(e) {
return e.applyMatrix4(this.matrixWorld);
},
worldToLocal: function(e) {
return e.applyMatrix4(Ea.getInverse(this.matrixWorld));
},
lookAt: function(e, t, n) {
e.isVector3 ? Pa.copy(e) : Pa.set(e, t, n), e = this.parent, this.updateWorldMatrix(!0, !1), 
ka.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ea.lookAt(ka, Pa, this.up) : Ea.lookAt(Pa, ka, this.up), 
this.quaternion.setFromRotationMatrix(Ea), e && (Ea.extractRotation(e.matrixWorld), 
Ca.setFromRotationMatrix(Ea), this.quaternion.premultiply(Ca.inverse()));
},
add: function(e) {
if (1 < arguments.length) {
for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
return this;
}
return e === this ? (console.error("$3.Object3D.add: object can't be added as a child of itself.", e), 
this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, 
this.children.push(e), e.dispatchEvent(ja)) : console.error("$3.Object3D.add: object not an instance of $3.Object3D.", e), 
this);
},
remove: function(e) {
if (1 < arguments.length) {
for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
return this;
}
return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, this.children.splice(t, 1), 
e.dispatchEvent(Ua)), this;
},
attach: function(e) {
return this.updateWorldMatrix(!0, !1), Ea.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), 
Ea.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ea), e.updateWorldMatrix(!1, !1), 
this.add(e), this;
},
getObjectById: function(e) {
return this.getObjectByProperty("id", e);
},
getObjectByName: function(e) {
return this.getObjectByProperty("name", e);
},
getObjectByProperty: function(e, t) {
if (this[e] === t) return this;
for (var n = 0, r = this.children.length; n < r; n++) {
var i = this.children[n].getObjectByProperty(e, t);
if (void 0 !== i) return i;
}
},
getWorldPosition: function(e) {
return void 0 === e && (console.warn("$3.Object3D: .getWorldPosition() target is now required"), 
e = new l()), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld);
},
getWorldQuaternion: function(e) {
return void 0 === e && (console.warn("$3.Object3D: .getWorldQuaternion() target is now required"), 
e = new c()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ka, e, Oa), 
e;
},
getWorldScale: function(e) {
return void 0 === e && (console.warn("$3.Object3D: .getWorldScale() target is now required"), 
e = new l()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ka, Da, e), 
e;
},
getWorldDirection: function(e) {
void 0 === e && (console.warn("$3.Object3D: .getWorldDirection() target is now required"), 
e = new l()), this.updateMatrixWorld(!0);
var t = this.matrixWorld.elements;
return e.set(t[8], t[9], t[10]).normalize();
},
raycast: function() {},
traverse: function(e) {
e(this);
for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e);
},
traverseVisible: function(e) {
if (!1 !== this.visible) {
e(this);
for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
}
},
traverseAncestors: function(e) {
var t = this.parent;
null !== t && (e(t), t.traverseAncestors(e));
},
updateMatrix: function() {
this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
},
updateMatrixWorld: function(e) {
this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
this.matrixWorldNeedsUpdate = !1, e = !0);
for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
},
updateWorldMatrix: function(e, t) {
var n = this.parent;
if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), 
null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
!0 === t) for (t = 0, n = (e = this.children).length; t < n; t++) e[t].updateWorldMatrix(!1, !0);
},
toJSON: function(e) {
function t(t, n) {
return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
}
function n(e) {
var t, n = [];
for (t in e) {
var r = e[t];
delete r.metadata, n.push(r);
}
return n;
}
var r = void 0 === e || "string" == typeof e, i = {};
r && (e = {
geometries: {},
materials: {},
textures: {},
images: {},
shapes: {}
}, i.metadata = {
version: 4.5,
type: "Object",
generator: "Object3D.toJSON"
});
var a = {};
if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), 
!0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), 
!1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 
0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), 
a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), 
this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON()), 
this.isMesh || this.isLine || this.isPoints) {
a.geometry = t(e.geometries, this.geometry);
var o = this.geometry.parameters;
if (void 0 !== o && void 0 !== o.shapes) if (o = o.shapes, Array.isArray(o)) for (var s = 0, c = o.length; s < c; s++) t(e.shapes, o[s]); else t(e.shapes, o);
}
if (void 0 !== this.material) if (Array.isArray(this.material)) {
for (o = [], s = 0, c = this.material.length; s < c; s++) o.push(t(e.materials, this.material[s]));
a.material = o;
} else a.material = t(e.materials, this.material);
if (0 < this.children.length) for (a.children = [], o = 0; o < this.children.length; o++) a.children.push(this.children[o].toJSON(e).object);
if (r) {
r = n(e.geometries), o = n(e.materials), s = n(e.textures), c = n(e.images);
var l = n(e.shapes);
0 < r.length && (i.geometries = r), 0 < o.length && (i.materials = o), 0 < s.length && (i.textures = s), 
0 < c.length && (i.images = c), 0 < l.length && (i.shapes = l);
}
return i.object = a, i;
},
clone: function(e) {
return new this.constructor().copy(this, e);
},
copy: function(e, t) {
if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), 
this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), 
this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, 
this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, 
this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, 
this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), 
!0 === t) for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
return this;
}
}), f.prototype = Object.assign(Object.create(p.prototype), {
constructor: f,
isScene: !0,
copy: function(e, t) {
return p.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), 
null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), 
null !== e.overrideMtrl && (this.overrideMtrl = e.overrideMtrl.clone()), this.autoUpdate = e.autoUpdate, 
this.matrixAutoUpdate = e.matrixAutoUpdate, this;
},
toJSON: function(e) {
var t = p.prototype.toJSON.call(this, e);
return null !== this.background && (t.object.background = this.background.toJSON(e)), 
null !== this.environment && (t.object.environment = this.environment.toJSON(e)), 
null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
}
});
var Ba = [ new l(), new l(), new l(), new l(), new l(), new l(), new l(), new l() ], za = new l(), Fa = new m(), Ga = new l(), Va = new l(), Wa = new l(), qa = new l(), Ha = new l(), Xa = new l(), Ya = new l(), Ja = new l(), Za = new l(), Ka = new l();
Object.assign(m.prototype, {
isBox3: !0,
set: function(e, t) {
return this.min.copy(e), this.max.copy(t), this;
},
setFromArray: function(e) {
for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
var l = e[s], u = e[s + 1], h = e[s + 2];
l < t && (t = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > a && (a = u), 
h > o && (o = h);
}
return this.min.set(t, n, r), this.max.set(i, a, o), this;
},
setFromBufferAttribute: function(e) {
for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.count; s < c; s++) {
var l = e.getX(s), u = e.getY(s), h = e.getZ(s);
l < t && (t = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > a && (a = u), 
h > o && (o = h);
}
return this.min.set(t, n, r), this.max.set(i, a, o), this;
},
setFromPoints: function(e) {
this.makeEmpty();
for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
return this;
},
setFromCenterAndSize: function(e, t) {
return t = za.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), 
this;
},
setFromObject: function(e) {
return this.makeEmpty(), this.expandByObject(e);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.min.copy(e.min), this.max.copy(e.max), this;
},
makeEmpty: function() {
return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, 
this;
},
isEmpty: function() {
return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
},
getCenter: function(e) {
return void 0 === e && (console.warn("$3.Box3: .getCenter() target is now required"), 
e = new l()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
},
getSize: function(e) {
return void 0 === e && (console.warn("$3.Box3: .getSize() target is now required"), 
e = new l()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
},
expandByPoint: function(e) {
return this.min.min(e), this.max.max(e), this;
},
expandByVector: function(e) {
return this.min.sub(e), this.max.add(e), this;
},
expandByScalar: function(e) {
return this.min.addScalar(-e), this.max.addScalar(e), this;
},
expandByObject: function(e) {
e.updateWorldMatrix(!1, !1);
var t = e.geometry;
void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Fa.copy(t.boundingBox), 
Fa.applyMatrix4(e.matrixWorld), this.union(Fa)), t = 0;
for (var n = (e = e.children).length; t < n; t++) this.expandByObject(e[t]);
return this;
},
containsPoint: function(e) {
return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
},
containsBox: function(e) {
return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
},
getParameter: function(e, t) {
return void 0 === t && (console.warn("$3.Box3: .getParameter() target is now required"), 
t = new l()), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
},
intersectsBox: function(e) {
return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
},
intersectsSphere: function(e) {
return this.clampPoint(e.center, za), za.distanceToSquared(e.center) <= e.radius * e.radius;
},
intersectsPlane: function(e) {
if (0 < e.normal.x) var t = e.normal.x * this.min.x, n = e.normal.x * this.max.x; else t = e.normal.x * this.max.x, 
n = e.normal.x * this.min.x;
return 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, 
n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, 
n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
},
intersectsTriangle: function(e) {
return !this.isEmpty() && (this.getCenter(Ya), Ja.subVectors(this.max, Ya), Ga.subVectors(e.a, Ya), 
Va.subVectors(e.b, Ya), Wa.subVectors(e.c, Ya), qa.subVectors(Va, Ga), Ha.subVectors(Wa, Va), 
Xa.subVectors(Ga, Wa), !!g(e = [ 0, -qa.z, qa.y, 0, -Ha.z, Ha.y, 0, -Xa.z, Xa.y, qa.z, 0, -qa.x, Ha.z, 0, -Ha.x, Xa.z, 0, -Xa.x, -qa.y, qa.x, 0, -Ha.y, Ha.x, 0, -Xa.y, Xa.x, 0 ], Ga, Va, Wa, Ja) && (!!g(e = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], Ga, Va, Wa, Ja) && (Za.crossVectors(qa, Ha), 
g(e = [ Za.x, Za.y, Za.z ], Ga, Va, Wa, Ja))));
},
clampPoint: function(e, t) {
return void 0 === t && (console.warn("$3.Box3: .clampPoint() target is now required"), 
t = new l()), t.copy(e).clamp(this.min, this.max);
},
distanceToPoint: function(e) {
return za.copy(e).clamp(this.min, this.max).sub(e).length();
},
getBoundingSphere: function(e) {
return void 0 === e && console.error("$3.Box3: .getBoundingSphere() target is now required"), 
this.getCenter(e.center), e.radius = .5 * this.getSize(za).length(), e;
},
intersect: function(e) {
return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), 
this;
},
union: function(e) {
return this.min.min(e.min), this.max.max(e.max), this;
},
applyMatrix4: function(e) {
return this.isEmpty() ? this : (Ba[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), 
Ba[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ba[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), 
Ba[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ba[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), 
Ba[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ba[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), 
Ba[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ba), 
this);
},
translate: function(e) {
return this.min.add(e), this.max.add(e), this;
},
equals: function(e) {
return e.min.equals(this.min) && e.max.equals(this.max);
}
});
var Qa = new m();
Object.assign(v.prototype, {
set: function(e, t) {
return this.center.copy(e), this.radius = t, this;
},
setFromPoints: function(e, t) {
var n = this.center;
void 0 !== t ? n.copy(t) : Qa.setFromPoints(e).getCenter(n);
for (var r = t = 0, i = e.length; r < i; r++) t = Math.max(t, n.distanceToSquared(e[r]));
return this.radius = Math.sqrt(t), this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.center.copy(e.center), this.radius = e.radius, this;
},
isEmpty: function() {
return 0 > this.radius;
},
makeEmpty: function() {
return this.center.set(0, 0, 0), this.radius = -1, this;
},
containsPoint: function(e) {
return e.distanceToSquared(this.center) <= this.radius * this.radius;
},
distanceToPoint: function(e) {
return e.distanceTo(this.center) - this.radius;
},
intersectsSphere: function(e) {
var t = this.radius + e.radius;
return e.center.distanceToSquared(this.center) <= t * t;
},
intersectsBox: function(e) {
return e.intersectsSphere(this);
},
intersectsPlane: function(e) {
return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
},
clampPoint: function(e, t) {
var n = this.center.distanceToSquared(e);
return void 0 === t && (console.warn("$3.Sphere: .clampPoint() target is now required"), 
t = new l()), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), 
t.multiplyScalar(this.radius).add(this.center)), t;
},
getBoundingBox: function(e) {
return void 0 === e && (console.warn("$3.Sphere: .getBoundingBox() target is now required"), 
e = new m()), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), 
e.expandByScalar(this.radius), e);
},
applyMatrix4: function(e) {
return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this;
},
translate: function(e) {
return this.center.add(e), this;
},
equals: function(e) {
return e.center.equals(this.center) && e.radius === this.radius;
}
});
var eo = new l(), to = new l(), no = new l(), ro = new l(), io = new l(), ao = new l(), oo = new l();
Object.assign(y.prototype, {
set: function(e, t) {
return this.origin.copy(e), this.direction.copy(t), this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
},
at: function(e, t) {
return void 0 === t && (console.warn("$3.Ray: .at() target is now required"), t = new l()), 
t.copy(this.direction).multiplyScalar(e).add(this.origin);
},
lookAt: function(e) {
return this.direction.copy(e).sub(this.origin).normalize(), this;
},
recast: function(e) {
return this.origin.copy(this.at(e, eo)), this;
},
closestPointToPoint: function(e, t) {
return void 0 === t && (console.warn("$3.Ray: .closestPointToPoint() target is now required"), 
t = new l()), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin);
},
distanceToPoint: function(e) {
return Math.sqrt(this.distanceSqToPoint(e));
},
distanceSqToPoint: function(e) {
var t = eo.subVectors(e, this.origin).dot(this.direction);
return 0 > t ? this.origin.distanceToSquared(e) : (eo.copy(this.direction).multiplyScalar(t).add(this.origin), 
eo.distanceToSquared(e));
},
distanceSqToSegment: function(e, t, n, r) {
to.copy(e).add(t).multiplyScalar(.5), no.copy(t).sub(e).normalize(), ro.copy(this.origin).sub(to);
var i = .5 * e.distanceTo(t), a = -this.direction.dot(no), o = ro.dot(this.direction), s = -ro.dot(no), c = ro.lengthSq(), l = Math.abs(1 - a * a);
if (0 < l) {
t = a * o - s;
var u = i * l;
0 <= (e = a * s - o) ? t >= -u ? t <= u ? a = (e *= i = 1 / l) * (e + a * (t *= i) + 2 * o) + t * (a * e + t + 2 * s) + c : (t = i, 
a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c) : (t = -i, a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c) : t <= -u ? a = -(e = Math.max(0, -(-a * i + o))) * e + (t = 0 < e ? -i : Math.min(Math.max(-i, -s), i)) * (t + 2 * s) + c : t <= u ? (e = 0, 
a = (t = Math.min(Math.max(-i, -s), i)) * (t + 2 * s) + c) : a = -(e = Math.max(0, -(a * i + o))) * e + (t = 0 < e ? i : Math.min(Math.max(-i, -s), i)) * (t + 2 * s) + c;
} else t = 0 < a ? -i : i, a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c;
return n && n.copy(this.direction).multiplyScalar(e).add(this.origin), r && r.copy(no).multiplyScalar(t).add(to), 
a;
},
intersectSphere: function(e, t) {
eo.subVectors(e.center, this.origin);
var n = eo.dot(this.direction), r = eo.dot(eo) - n * n;
return r > (e = e.radius * e.radius) ? null : (r = n - (e = Math.sqrt(e - r)), n += e, 
0 > r && 0 > n ? null : 0 > r ? this.at(n, t) : this.at(r, t));
},
intersectsSphere: function(e) {
return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
},
distanceToPlane: function(e) {
var t = e.normal.dot(this.direction);
return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null;
},
intersectPlane: function(e, t) {
return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t);
},
intersectsPlane: function(e) {
var t = e.distanceToPoint(this.origin);
return 0 === t || 0 > e.normal.dot(this.direction) * t;
},
intersectBox: function(e, t) {
var n = 1 / this.direction.x, r = 1 / this.direction.y, i = 1 / this.direction.z, a = this.origin;
if (0 <= n) {
var o = (e.min.x - a.x) * n;
n *= e.max.x - a.x;
} else o = (e.max.x - a.x) * n, n *= e.min.x - a.x;
if (0 <= r) {
var s = (e.min.y - a.y) * r;
r *= e.max.y - a.y;
} else s = (e.max.y - a.y) * r, r *= e.min.y - a.y;
return o > r || s > n ? null : ((s > o || o != o) && (o = s), (r < n || n != n) && (n = r), 
0 <= i ? (s = (e.min.z - a.z) * i, e = (e.max.z - a.z) * i) : (s = (e.max.z - a.z) * i, 
e = (e.min.z - a.z) * i), o > e || s > n ? null : ((s > o || o != o) && (o = s), 
(e < n || n != n) && (n = e), 0 > n ? null : this.at(0 <= o ? o : n, t)));
},
intersectsBox: function(e) {
return null !== this.intersectBox(e, eo);
},
intersectTriangle: function(e, t, n, r, i) {
if (io.subVectors(t, e), ao.subVectors(n, e), oo.crossVectors(io, ao), 0 < (t = this.direction.dot(oo))) {
if (r) return null;
r = 1;
} else {
if (!(0 > t)) return null;
r = -1, t = -t;
}
return ro.subVectors(this.origin, e), 0 > (e = r * this.direction.dot(ao.crossVectors(ro, ao))) ? null : 0 > (n = r * this.direction.dot(io.cross(ro))) || e + n > t ? null : 0 > (e = -r * ro.dot(oo)) ? null : this.at(e / t, i);
},
applyMatrix4: function(e) {
return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
},
equals: function(e) {
return e.origin.equals(this.origin) && e.direction.equals(this.direction);
}
});
var so = new l(), co = new l(), lo = new r();
Object.assign($.prototype, {
isPlane: !0,
set: function(e, t) {
return this.normal.copy(e), this.constant = t, this;
},
setComponents: function(e, t, n, r) {
return this.normal.set(e, t, n), this.constant = r, this;
},
setFromNormalAndCoplanarPoint: function(e, t) {
return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
},
setFromCoplanarPoints: function(e, t, n) {
return t = so.subVectors(n, t).cross(co.subVectors(e, t)).normalize(), this.setFromNormalAndCoplanarPoint(t, e), 
this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.normal.copy(e.normal), this.constant = e.constant, this;
},
normalize: function() {
var e = 1 / this.normal.length();
return this.normal.multiplyScalar(e), this.constant *= e, this;
},
negate: function() {
return this.constant *= -1, this.normal.negate(), this;
},
distanceToPoint: function(e) {
return this.normal.dot(e) + this.constant;
},
distanceToSphere: function(e) {
return this.distanceToPoint(e.center) - e.radius;
},
projectPoint: function(e, t) {
return void 0 === t && (console.warn("$3.Plane: .projectPoint() target is now required"), 
t = new l()), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
},
intersectLine: function(e, t) {
void 0 === t && (console.warn("$3.Plane: .intersectLine() target is now required"), 
t = new l());
var n = e.delta(so), r = this.normal.dot(n);
if (0 === r) {
if (0 === this.distanceToPoint(e.start)) return t.copy(e.start);
} else if (!(0 > (r = -(e.start.dot(this.normal) + this.constant) / r) || 1 < r)) return t.copy(n).multiplyScalar(r).add(e.start);
},
intersectsLine: function(e) {
var t = this.distanceToPoint(e.start);
return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t;
},
intersectsBox: function(e) {
return e.intersectsPlane(this);
},
intersectsSphere: function(e) {
return e.intersectsPlane(this);
},
coplanarPoint: function(e) {
return void 0 === e && (console.warn("$3.Plane: .coplanarPoint() target is now required"), 
e = new l()), e.copy(this.normal).multiplyScalar(-this.constant);
},
applyMatrix4: function(e, t) {
return t = t || lo.getNormalMatrix(e), e = this.coplanarPoint(so).applyMatrix4(e), 
t = this.normal.applyMatrix3(t).normalize(), this.constant = -e.dot(t), this;
},
translate: function(e) {
return this.constant -= e.dot(this.normal), this;
},
equals: function(e) {
return e.normal.equals(this.normal) && e.constant === this.constant;
}
});
var uo = new l(), ho = new l(), po = new l(), fo = new l(), mo = new l(), go = new l(), vo = new l(), yo = new l(), $o = new l(), bo = new l();
Object.assign(b, {
getNormal: function(e, t, n, r) {
return void 0 === r && (console.warn("$3.Triangle: .getNormal() target is now required"), 
r = new l()), r.subVectors(n, t), uo.subVectors(e, t), r.cross(uo), 0 < (e = r.lengthSq()) ? r.multiplyScalar(1 / Math.sqrt(e)) : r.set(0, 0, 0);
},
getBarycoord: function(e, t, n, r, i) {
uo.subVectors(r, t), ho.subVectors(n, t), po.subVectors(e, t), e = uo.dot(uo), t = uo.dot(ho), 
n = uo.dot(po);
var a = ho.dot(ho);
r = ho.dot(po);
var o = e * a - t * t;
return void 0 === i && (console.warn("$3.Triangle: .getBarycoord() target is now required"), 
i = new l()), 0 === o ? i.set(-2, -1, -1) : (a = (a * n - t * r) * (o = 1 / o), 
e = (e * r - t * n) * o, i.set(1 - a - e, e, a));
},
containsPoint: function(e, t, n, r) {
return b.getBarycoord(e, t, n, r, fo), 0 <= fo.x && 0 <= fo.y && 1 >= fo.x + fo.y;
},
getUV: function(e, t, n, r, i, a, o, s) {
return this.getBarycoord(e, t, n, r, fo), s.set(0, 0), s.addScaledVector(i, fo.x), 
s.addScaledVector(a, fo.y), s.addScaledVector(o, fo.z), s;
},
isFrontFacing: function(e, t, n, r) {
return uo.subVectors(n, t), ho.subVectors(e, t), 0 > uo.cross(ho).dot(r);
}
}), Object.assign(b.prototype, {
set: function(e, t, n) {
return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
},
setFromPointsAndIndices: function(e, t, n, r) {
return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
},
getArea: function() {
return uo.subVectors(this.c, this.b), ho.subVectors(this.a, this.b), .5 * uo.cross(ho).length();
},
getMidpoint: function(e) {
return void 0 === e && (console.warn("$3.Triangle: .getMidpoint() target is now required"), 
e = new l()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
},
getNormal: function(e) {
return b.getNormal(this.a, this.b, this.c, e);
},
getPlane: function(e) {
return void 0 === e && (console.warn("$3.Triangle: .getPlane() target is now required"), 
e = new $()), e.setFromCoplanarPoints(this.a, this.b, this.c);
},
getBarycoord: function(e, t) {
return b.getBarycoord(e, this.a, this.b, this.c, t);
},
getUV: function(e, t, n, r, i) {
return b.getUV(e, this.a, this.b, this.c, t, n, r, i);
},
containsPoint: function(e) {
return b.containsPoint(e, this.a, this.b, this.c);
},
isFrontFacing: function(e) {
return b.isFrontFacing(this.a, this.b, this.c, e);
},
intersectsBox: function(e) {
return e.intersectsTriangle(this);
},
closestPointToPoint: function(e, t) {
void 0 === t && (console.warn("$3.Triangle: .closestPointToPoint() target is now required"), 
t = new l());
var n = this.a, r = this.b, i = this.c;
mo.subVectors(r, n), go.subVectors(i, n), yo.subVectors(e, n);
var a = mo.dot(yo), o = go.dot(yo);
if (0 >= a && 0 >= o) return t.copy(n);
$o.subVectors(e, r);
var s = mo.dot($o), c = go.dot($o);
if (0 <= s && c <= s) return t.copy(r);
var u = a * c - s * o;
if (0 >= u && 0 <= a && 0 >= s) return r = a / (a - s), t.copy(n).addScaledVector(mo, r);
bo.subVectors(e, i), e = mo.dot(bo);
var h = go.dot(bo);
return 0 <= h && e <= h ? t.copy(i) : 0 >= (a = e * o - a * h) && 0 <= o && 0 >= h ? (u = o / (o - h), 
t.copy(n).addScaledVector(go, u)) : 0 >= (o = s * h - e * c) && 0 <= c - s && 0 <= e - h ? (vo.subVectors(i, r), 
u = (c - s) / (c - s + (e - h)), t.copy(r).addScaledVector(vo, u)) : (r = a * (i = 1 / (o + a + u)), 
u *= i, t.copy(n).addScaledVector(mo, r).addScaledVector(go, u));
},
equals: function(e) {
return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
}
});
var xo = {
aliceblue: 15792383,
antiquewhite: 16444375,
aqua: 65535,
aquamarine: 8388564,
azure: 15794175,
beige: 16119260,
bisque: 16770244,
black: 0,
blanchedalmond: 16772045,
blue: 255,
blueviolet: 9055202,
brown: 10824234,
burlywood: 14596231,
cadetblue: 6266528,
chartreuse: 8388352,
chocolate: 13789470,
coral: 16744272,
cornflowerblue: 6591981,
cornsilk: 16775388,
crimson: 14423100,
cyan: 65535,
darkblue: 139,
darkcyan: 35723,
darkgoldenrod: 12092939,
darkgray: 11119017,
darkgreen: 25600,
darkgrey: 11119017,
darkkhaki: 12433259,
darkmagenta: 9109643,
darkolivegreen: 5597999,
darkorange: 16747520,
darkorchid: 10040012,
darkred: 9109504,
darksalmon: 15308410,
darkseagreen: 9419919,
darkslateblue: 4734347,
darkslategray: 3100495,
darkslategrey: 3100495,
darkturquoise: 52945,
darkviolet: 9699539,
deeppink: 16716947,
deepskyblue: 49151,
dimgray: 6908265,
dimgrey: 6908265,
dodgerblue: 2003199,
firebrick: 11674146,
floralwhite: 16775920,
forestgreen: 2263842,
fuchsia: 16711935,
gainsboro: 14474460,
ghostwhite: 16316671,
gold: 16766720,
goldenrod: 14329120,
gray: 8421504,
green: 32768,
greenyellow: 11403055,
grey: 8421504,
honeydew: 15794160,
hotpink: 16738740,
indianred: 13458524,
indigo: 4915330,
ivory: 16777200,
khaki: 15787660,
lavender: 15132410,
lavenderblush: 16773365,
lawngreen: 8190976,
lemonchiffon: 16775885,
lightblue: 11393254,
lightcoral: 15761536,
lightcyan: 14745599,
lightgoldenrodyellow: 16448210,
lightgray: 13882323,
lightgreen: 9498256,
lightgrey: 13882323,
lightpink: 16758465,
lightsalmon: 16752762,
lightseagreen: 2142890,
lightskyblue: 8900346,
lightslategray: 7833753,
lightslategrey: 7833753,
lightsteelblue: 11584734,
lightyellow: 16777184,
lime: 65280,
limegreen: 3329330,
linen: 16445670,
magenta: 16711935,
maroon: 8388608,
mediumaquamarine: 6737322,
mediumblue: 205,
mediumorchid: 12211667,
mediumpurple: 9662683,
mediumseagreen: 3978097,
mediumslateblue: 8087790,
mediumspringgreen: 64154,
mediumturquoise: 4772300,
mediumvioletred: 13047173,
midnightblue: 1644912,
mintcream: 16121850,
mistyrose: 16770273,
moccasin: 16770229,
navajowhite: 16768685,
navy: 128,
oldlace: 16643558,
olive: 8421376,
olivedrab: 7048739,
orange: 16753920,
orangered: 16729344,
orchid: 14315734,
palegoldenrod: 15657130,
palegreen: 10025880,
paleturquoise: 11529966,
palevioletred: 14381203,
papayawhip: 16773077,
peachpuff: 16767673,
peru: 13468991,
pink: 16761035,
plum: 14524637,
powderblue: 11591910,
purple: 8388736,
rebeccapurple: 6697881,
red: 16711680,
rosybrown: 12357519,
royalblue: 4286945,
saddlebrown: 9127187,
salmon: 16416882,
sandybrown: 16032864,
seagreen: 3050327,
seashell: 16774638,
sienna: 10506797,
silver: 12632256,
skyblue: 8900331,
slateblue: 6970061,
slategray: 7372944,
slategrey: 7372944,
snow: 16775930,
springgreen: 65407,
steelblue: 4620980,
tan: 13808780,
teal: 32896,
thistle: 14204888,
tomato: 16737095,
turquoise: 4251856,
violet: 15631086,
wheat: 16113331,
white: 16777215,
whitesmoke: 16119285,
yellow: 16776960,
yellowgreen: 10145074
}, wo = {
h: 0,
s: 0,
l: 0
}, _o = {
h: 0,
s: 0,
l: 0
};
Object.assign(x.prototype, {
isColor: !0,
r: 1,
g: 1,
b: 1,
set: function(e) {
return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), 
this;
},
setScalar: function(e) {
return this.b = this.g = this.r = e, this;
},
setHex: function(e) {
return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, 
this.b = (255 & e) / 255, this;
},
setRGB: function(e, t, n) {
return this.r = e, this.g = t, this.b = n, this;
},
setHSL: function(e, t, n) {
return e = da.euclideanModulo(e, 1), t = da.clamp(t, 0, 1), n = da.clamp(n, 0, 1), 
0 === t ? this.r = this.g = this.b = n : (n = 2 * n - (t = .5 >= n ? n * (1 + t) : n + t - n * t), 
this.r = w(n, t, e + 1 / 3), this.g = w(n, t, e), this.b = w(n, t, e - 1 / 3)), 
this;
},
setStyle: function(e) {
function t(t) {
void 0 !== t && 1 > parseFloat(t) && console.warn("$3.Color: Alpha component of " + e + " will be ignored.");
}
var n;
if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
var r = n[2];
switch (n[1]) {
case "rgb":
case "rgba":
if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, 
this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, 
t(n[5]), this;
if (n = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, 
this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, 
t(n[5]), this;
break;

case "hsl":
case "hsla":
if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
r = parseFloat(n[1]) / 360;
var i = parseInt(n[2], 10) / 100, a = parseInt(n[3], 10) / 100;
return t(n[5]), this.setHSL(r, i, a);
}
}
} else if (n = /^#([A-Fa-f0-9]+)$/.exec(e)) {
if (3 === (r = (n = n[1]).length)) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, 
this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, 
this;
if (6 === r) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, 
this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, this;
}
return e && 0 < e.length ? this.setColorName(e) : this;
},
setColorName: function(e) {
var t = xo[e];
return void 0 !== t ? this.setHex(t) : console.warn("$3.Color: Unknown color " + e), 
this;
},
clone: function() {
return new this.constructor(this.r, this.g, this.b);
},
copy: function(e) {
return this.r = e.r, this.g = e.g, this.b = e.b, this;
},
copyGammaToLinear: function(e, t) {
return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), 
this.b = Math.pow(e.b, t), this;
},
copyLinearToGamma: function(e, t) {
return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), 
this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this;
},
convertGammaToLinear: function(e) {
return this.copyGammaToLinear(this, e), this;
},
convertLinearToGamma: function(e) {
return this.copyLinearToGamma(this, e), this;
},
copySRGBToLinear: function(e) {
return this.r = _(e.r), this.g = _(e.g), this.b = _(e.b), this;
},
copyLinearToSRGB: function(e) {
return this.r = M(e.r), this.g = M(e.g), this.b = M(e.b), this;
},
convertSRGBToLinear: function() {
return this.copySRGBToLinear(this), this;
},
convertLinearToSRGB: function() {
return this.copyLinearToSRGB(this), this;
},
getHex: function() {
return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
},
getHexString: function() {
return ("000000" + this.getHex().toString(16)).slice(-6);
},
getHSL: function(e) {
void 0 === e && (console.warn("$3.Color: .getHSL() target is now required"), e = {
h: 0,
s: 0,
l: 0
});
var t, n = this.r, r = this.g, i = this.b, a = Math.max(n, r, i), o = Math.min(n, r, i), s = (o + a) / 2;
if (o === a) o = t = 0; else {
var c = a - o;
switch (o = .5 >= s ? c / (a + o) : c / (2 - a - o), a) {
case n:
t = (r - i) / c + (r < i ? 6 : 0);
break;

case r:
t = (i - n) / c + 2;
break;

case i:
t = (n - r) / c + 4;
}
t /= 6;
}
return e.h = t, e.s = o, e.l = s, e;
},
getStyle: function() {
return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
},
offsetHSL: function(e, t, n) {
return this.getHSL(wo), wo.h += e, wo.s += t, wo.l += n, this.setHSL(wo.h, wo.s, wo.l), 
this;
},
add: function(e) {
return this.r += e.r, this.g += e.g, this.b += e.b, this;
},
addColors: function(e, t) {
return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
},
addScalar: function(e) {
return this.r += e, this.g += e, this.b += e, this;
},
sub: function(e) {
return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), 
this;
},
multiply: function(e) {
return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
},
multiplyScalar: function(e) {
return this.r *= e, this.g *= e, this.b *= e, this;
},
lerp: function(e, t) {
return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, 
this;
},
lerpHSL: function(e, t) {
this.getHSL(wo), e.getHSL(_o), e = da.lerp(wo.h, _o.h, t);
var n = da.lerp(wo.s, _o.s, t);
return t = da.lerp(wo.l, _o.l, t), this.setHSL(e, n, t), this;
},
equals: function(e) {
return e.r === this.r && e.g === this.g && e.b === this.b;
},
fromArray: function(e, t) {
return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], 
this;
},
toArray: function(e, t) {
return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, 
e[t + 2] = this.b, e;
},
toJSON: function() {
return this.getHex();
}
}), x.NAMES = xo, Object.assign(S.prototype, {
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), 
this.materialIndex = e.materialIndex;
for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
return this;
}
});
var Mo = 0;
A.prototype = Object.assign(Object.create(t.prototype), {
constructor: A,
isMtrl: !0,
onBeforeCompile: function() {},
setValues: function(e) {
if (void 0 !== e) for (var t in e) {
var n = e[t];
if (void 0 === n) console.warn("$3.Mtrl: '" + t + "' parameter is undefined."); else if ("shading" === t) console.warn("$3." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
this.flatShading = 1 === n; else {
var r = this[t];
void 0 === r ? console.warn("$3." + this.type + ": '" + t + "' is not a property of this material.") : r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n;
}
}
},
toJSON: function(e) {
function t(e) {
var t, n = [];
for (t in e) {
var r = e[t];
delete r.metadata, n.push(r);
}
return n;
}
var n = void 0 === e || "string" == typeof e;
n && (e = {
textures: {},
images: {}
});
var r = {
metadata: {
version: 4.5,
type: "Mtrl",
generator: "Mtrl.toJSON"
}
};
return r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), 
this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), 
void 0 !== this.metalness && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), 
this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), 
this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), 
this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), 
void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), 
void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), 
this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), 
this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), 
this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, 
r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), 
this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), 
this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), 
this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid), 
this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), 
this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, 
r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, 
r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), 
this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, 
r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), 
this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), 
this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), 
this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), 
this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), 
this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, 
r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, void 0 !== this.combine && (r.combine = this.combine), 
void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)), 
this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), 
void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), 
1 !== this.blending && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), 
0 !== this.side && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), 
1 > this.opacity && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), 
r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, 
r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, 
r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, 
r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, 
this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 
0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 
0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), 
this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), 
void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), 
!0 === this.dithering && (r.dithering = !0), 0 < this.alphaTest && (r.alphaTest = this.alphaTest), 
!0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), 
!0 === this.wireframe && (r.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (r.wireframeLinewidth = this.wireframeLinewidth), 
"round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), 
"round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), 
!0 === this.morphTargets && (r.morphTargets = !0), !0 === this.morphNormals && (r.morphNormals = !0), 
!0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), 
!1 === this.toneMapped && (r.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), 
n && (n = t(e.textures), e = t(e.images), 0 < n.length && (r.textures = n), 0 < e.length && (r.images = e)), 
r;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, 
this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, 
this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, 
this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, 
this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, 
this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, 
this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, 
this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
var t = e.clippingPlanes, n = null;
if (null !== t) {
var r = t.length;
n = Array(r);
for (var i = 0; i !== r; ++i) n[i] = t[i].clone();
}
return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, 
this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, 
this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, 
this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, 
this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, 
this.userData = JSON.parse(JSON.stringify(e.userData)), this;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
}
}), Object.defineProperty(A.prototype, "needsUpdate", {
set: function(e) {
!0 === e && this.version++;
}
}), T.prototype = Object.create(A.prototype), T.prototype.constructor = T, T.prototype.isMeshBasicMtrl = !0, 
T.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, 
this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, 
this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, 
this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, 
this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, 
this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, 
this.skinning = e.skinning, this.morphTargets = e.morphTargets, this;
};
var So = new l();
Object.defineProperty(L.prototype, "needsUpdate", {
set: function(e) {
!0 === e && this.version++;
}
}), Object.assign(L.prototype, {
isBufferAttribute: !0,
onUploadCallback: function() {},
setUsage: function(e) {
return this.usage = e, this;
},
copy: function(e) {
return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, 
this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
},
copyAt: function(e, t, n) {
e *= this.itemSize, n *= t.itemSize;
for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
return this;
},
copyArray: function(e) {
return this.array.set(e), this;
},
copyColorsArray: function(e) {
for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
var a = e[r];
void 0 === a && (console.warn("$3.BufferAttribute.copyColorsArray(): color is undefined", r), 
a = new x()), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b;
}
return this;
},
copyVector2sArray: function(e) {
for (var t = this.array, r = 0, i = 0, a = e.length; i < a; i++) {
var o = e[i];
void 0 === o && (console.warn("$3.BufferAttribute.copyVector2sArray(): vector is undefined", i), 
o = new n()), t[r++] = o.x, t[r++] = o.y;
}
return this;
},
copyVector3sArray: function(e) {
for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
var a = e[r];
void 0 === a && (console.warn("$3.BufferAttribute.copyVector3sArray(): vector is undefined", r), 
a = new l()), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z;
}
return this;
},
copyVector4sArray: function(e) {
for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
var o = e[r];
void 0 === o && (console.warn("$3.BufferAttribute.copyVector4sArray(): vector is undefined", r), 
o = new a()), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w;
}
return this;
},
applyMatrix3: function(e) {
for (var t = 0, n = this.count; t < n; t++) So.x = this.getX(t), So.y = this.getY(t), 
So.z = this.getZ(t), So.applyMatrix3(e), this.setXYZ(t, So.x, So.y, So.z);
return this;
},
applyMatrix4: function(e) {
for (var t = 0, n = this.count; t < n; t++) So.x = this.getX(t), So.y = this.getY(t), 
So.z = this.getZ(t), So.applyMatrix4(e), this.setXYZ(t, So.x, So.y, So.z);
return this;
},
applyNormalMatrix: function(e) {
for (var t = 0, n = this.count; t < n; t++) So.x = this.getX(t), So.y = this.getY(t), 
So.z = this.getZ(t), So.applyNormalMatrix(e), this.setXYZ(t, So.x, So.y, So.z);
return this;
},
transformDirection: function(e) {
for (var t = 0, n = this.count; t < n; t++) So.x = this.getX(t), So.y = this.getY(t), 
So.z = this.getZ(t), So.transformDirection(e), this.setXYZ(t, So.x, So.y, So.z);
return this;
},
set: function(e, t) {
return void 0 === t && (t = 0), this.array.set(e, t), this;
},
getX: function(e) {
return this.array[e * this.itemSize];
},
setX: function(e, t) {
return this.array[e * this.itemSize] = t, this;
},
getY: function(e) {
return this.array[e * this.itemSize + 1];
},
setY: function(e, t) {
return this.array[e * this.itemSize + 1] = t, this;
},
getZ: function(e) {
return this.array[e * this.itemSize + 2];
},
setZ: function(e, t) {
return this.array[e * this.itemSize + 2] = t, this;
},
getW: function(e) {
return this.array[e * this.itemSize + 3];
},
setW: function(e, t) {
return this.array[e * this.itemSize + 3] = t, this;
},
setXY: function(e, t, n) {
return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this;
},
setXYZ: function(e, t, n, r) {
return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, 
this;
},
setXYZW: function(e, t, n, r, i) {
return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, 
this.array[e + 3] = i, this;
},
onUpload: function(e) {
return this.onUploadCallback = e, this;
},
clone: function() {
return new this.constructor(this.array, this.itemSize).copy(this);
},
toJSON: function() {
return {
itemSize: this.itemSize,
type: this.array.constructor.name,
array: Array.prototype.slice.call(this.array),
normalized: this.normalized
};
}
}), C.prototype = Object.create(L.prototype), C.prototype.constructor = C, E.prototype = Object.create(L.prototype), 
E.prototype.constructor = E, P.prototype = Object.create(L.prototype), P.prototype.constructor = P, 
k.prototype = Object.create(L.prototype), k.prototype.constructor = k, O.prototype = Object.create(L.prototype), 
O.prototype.constructor = O, D.prototype = Object.create(L.prototype), D.prototype.constructor = D, 
N.prototype = Object.create(L.prototype), N.prototype.constructor = N, I.prototype = Object.create(L.prototype), 
I.prototype.constructor = I, R.prototype = Object.create(L.prototype), R.prototype.constructor = R, 
Object.assign(j.prototype, {
computeGroups: function(e) {
var t = [], n = void 0, r = e.faces;
for (e = 0; e < r.length; e++) {
var i = r[e];
if (i.materialIndex !== n) {
n = i.materialIndex, void 0 !== a && (a.count = 3 * e - a.start, t.push(a));
var a = {
start: 3 * e,
materialIndex: n
};
}
}
void 0 !== a && (a.count = 3 * e - a.start, t.push(a)), this.groups = t;
},
fromGmtr: function(e) {
var t = e.faces, r = e.vertices, i = e.faceVertexUvs, a = i[0] && 0 < i[0].length, o = i[1] && 0 < i[1].length, s = e.morphTargets, c = s.length;
if (0 < c) {
for (var l = [], u = 0; u < c; u++) l[u] = {
name: s[u].name,
data: []
};
this.morphTargets.position = l;
}
var h = (u = e.morphNormals).length;
if (0 < h) {
for (var d = [], p = 0; p < h; p++) d[p] = {
name: u[p].name,
data: []
};
this.morphTargets.normal = d;
}
p = e.skinIndices;
var f = e.skinWeights, m = p.length === r.length, g = f.length === r.length;
0 < r.length && 0 === t.length && console.error("$3.DirectGmtr: Faceless geometries are not supported.");
for (var v = 0; v < t.length; v++) {
var y = t[v];
this.vertices.push(r[y.a], r[y.b], r[y.c]);
var $ = y.vertexNormals;
for (3 === $.length ? this.normals.push($[0], $[1], $[2]) : ($ = y.normal, this.normals.push($, $, $)), 
3 === ($ = y.vertexColors).length ? this.colors.push($[0], $[1], $[2]) : ($ = y.color, 
this.colors.push($, $, $)), !0 === a && (void 0 !== ($ = i[0][v]) ? this.uvs.push($[0], $[1], $[2]) : (console.warn("$3.DirectGmtr.fromGmtr(): Undefined vertexUv ", v), 
this.uvs.push(new n(), new n(), new n()))), !0 === o && (void 0 !== ($ = i[1][v]) ? this.uvs2.push($[0], $[1], $[2]) : (console.warn("$3.DirectGmtr.fromGmtr(): Undefined vertexUv2 ", v), 
this.uvs2.push(new n(), new n(), new n()))), $ = 0; $ < c; $++) {
var b = s[$].vertices;
l[$].data.push(b[y.a], b[y.b], b[y.c]);
}
for ($ = 0; $ < h; $++) b = u[$].vertexNormals[v], d[$].data.push(b.a, b.b, b.c);
m && this.skinIndices.push(p[y.a], p[y.b], p[y.c]), g && this.skinWeights.push(f[y.a], f[y.b], f[y.c]);
}
return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, 
this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, 
this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), 
null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this;
}
});
var Ao = 1, To = new u(), Lo = new p(), Co = new l(), Eo = new m(), Po = new m(), ko = new l();
B.prototype = Object.assign(Object.create(t.prototype), {
constructor: B,
isBufferGmtr: !0,
getIndex: function() {
return this.index;
},
setIndex: function(e) {
Array.isArray(e) ? this.index = new (65535 < U(e) ? N : O)(e, 1) : this.index = e;
},
getAttribute: function(e) {
return this.attributes[e];
},
setAttribute: function(e, t) {
return this.attributes[e] = t, this;
},
deleteAttribute: function(e) {
return delete this.attributes[e], this;
},
addGroup: function(e, t, n) {
this.groups.push({
start: e,
count: t,
materialIndex: void 0 !== n ? n : 0
});
},
clearGroups: function() {
this.groups = [];
},
setDrawRange: function(e, t) {
this.drawRange.start = e, this.drawRange.count = t;
},
applyMatrix4: function(e) {
var t = this.attributes.position;
if (void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0), void 0 !== (t = this.attributes.normal)) {
var n = new r().getNormalMatrix(e);
t.applyNormalMatrix(n), t.needsUpdate = !0;
}
return void 0 !== (t = this.attributes.tangent) && (t.transformDirection(e), t.needsUpdate = !0), 
null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
this;
},
rotateX: function(e) {
return To.makeRotationX(e), this.applyMatrix4(To), this;
},
rotateY: function(e) {
return To.makeRotationY(e), this.applyMatrix4(To), this;
},
rotateZ: function(e) {
return To.makeRotationZ(e), this.applyMatrix4(To), this;
},
translate: function(e, t, n) {
return To.makeTranslation(e, t, n), this.applyMatrix4(To), this;
},
scale: function(e, t, n) {
return To.makeScale(e, t, n), this.applyMatrix4(To), this;
},
lookAt: function(e) {
return Lo.lookAt(e), Lo.updateMatrix(), this.applyMatrix4(Lo.matrix), this;
},
center: function() {
return this.computeBoundingBox(), this.boundingBox.getCenter(Co).negate(), this.translate(Co.x, Co.y, Co.z), 
this;
},
setFromObject: function(e) {
var t = e.geometry;
if (e.isPoints || e.isLine) {
e = new I(3 * t.vertices.length, 3);
var n = new I(3 * t.colors.length, 3);
this.setAttribute("position", e.copyVector3sArray(t.vertices)), this.setAttribute("color", n.copyColorsArray(t.colors)), 
t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new I(t.lineDistances.length, 1), 
this.setAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), 
null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone());
} else e.isMesh && t && t.isGmtr && this.fromGmtr(t);
return this;
},
setFromPoints: function(e) {
for (var t = [], n = 0, r = e.length; n < r; n++) {
var i = e[n];
t.push(i.x, i.y, i.z || 0);
}
return this.setAttribute("position", new I(t, 3)), this;
},
updateFromObject: function(e) {
var t = e.geometry;
if (e.isMesh) {
var n = t.__directGmtr;
if (!0 === t.elementsNeedUpdate && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGmtr(t);
n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, 
n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, 
t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, 
t.groupsNeedUpdate = !1, t = n;
}
return !0 === t.verticesNeedUpdate && (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(t.vertices), 
n.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(t.normals), 
n.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(t.colors), 
n.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(t.uvs), 
n.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(t.lineDistances), 
n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), 
this.groups = t.groups, t.groupsNeedUpdate = !1), this;
},
fromGmtr: function(e) {
return e.__directGmtr = new j().fromGmtr(e), this.fromDirectGmtr(e.__directGmtr);
},
fromDirectGmtr: function(e) {
var t = new Float32Array(3 * e.vertices.length);
for (var n in this.setAttribute("position", new L(t, 3).copyVector3sArray(e.vertices)), 
0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.setAttribute("normal", new L(t, 3).copyVector3sArray(e.normals))), 
0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.setAttribute("color", new L(t, 3).copyColorsArray(e.colors))), 
0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.setAttribute("uv", new L(t, 2).copyVector2sArray(e.uvs))), 
0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.setAttribute("uv2", new L(t, 2).copyVector2sArray(e.uvs2))), 
this.groups = e.groups, e.morphTargets) {
t = [];
for (var r = e.morphTargets[n], i = 0, a = r.length; i < a; i++) {
var o = r[i], s = new I(3 * o.data.length, 3);
s.name = o.name, t.push(s.copyVector3sArray(o.data));
}
this.morphAttributes[n] = t;
}
return 0 < e.skinIndices.length && (n = new I(4 * e.skinIndices.length, 4), this.setAttribute("skinIndex", n.copyVector4sArray(e.skinIndices))), 
0 < e.skinWeights.length && (n = new I(4 * e.skinWeights.length, 4), this.setAttribute("skinWeight", n.copyVector4sArray(e.skinWeights))), 
null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), 
this;
},
computeBoundingBox: function() {
null === this.boundingBox && (this.boundingBox = new m());
var e = this.attributes.position, t = this.morphAttributes.position;
if (void 0 !== e) {
if (this.boundingBox.setFromBufferAttribute(e), t) {
e = 0;
for (var n = t.length; e < n; e++) Eo.setFromBufferAttribute(t[e]), this.morphTargetsRelative ? (ko.addVectors(this.boundingBox.min, Eo.min), 
this.boundingBox.expandByPoint(ko), ko.addVectors(this.boundingBox.max, Eo.max), 
this.boundingBox.expandByPoint(ko)) : (this.boundingBox.expandByPoint(Eo.min), this.boundingBox.expandByPoint(Eo.max));
}
} else this.boundingBox.makeEmpty();
(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('$3.BufferGmtr.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
},
computeBoundingSphere: function() {
null === this.boundingSphere && (this.boundingSphere = new v());
var e = this.attributes.position, t = this.morphAttributes.position;
if (e) {
var n = this.boundingSphere.center;
if (Eo.setFromBufferAttribute(e), t) for (var r = 0, i = t.length; r < i; r++) Po.setFromBufferAttribute(t[r]), 
this.morphTargetsRelative ? (ko.addVectors(Eo.min, Po.min), Eo.expandByPoint(ko), 
ko.addVectors(Eo.max, Po.max), Eo.expandByPoint(ko)) : (Eo.expandByPoint(Po.min), 
Eo.expandByPoint(Po.max));
Eo.getCenter(n), i = r = 0;
for (var a = e.count; i < a; i++) ko.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(ko));
if (t) for (i = 0, a = t.length; i < a; i++) for (var o = t[i], s = this.morphTargetsRelative, c = 0, l = o.count; c < l; c++) ko.fromBufferAttribute(o, c), 
s && (Co.fromBufferAttribute(e, c), ko.add(Co)), r = Math.max(r, n.distanceToSquared(ko));
this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('$3.BufferGmtr.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
}
},
computeFaceNormals: function() {},
computeVertexNormals: function() {
var e = this.index, t = this.attributes;
if (t.position) {
var n = t.position.array;
if (void 0 === t.normal) this.setAttribute("normal", new L(new Float32Array(n.length), 3)); else for (var r = t.normal.array, i = 0, a = r.length; i < a; i++) r[i] = 0;
r = t.normal.array, i = new l(), a = new l();
var o = new l(), s = new l(), c = new l();
if (e) {
var u = e.array, h = 0;
for (e = e.count; h < e; h += 3) {
var d = 3 * u[h + 0], p = 3 * u[h + 1], f = 3 * u[h + 2];
i.fromArray(n, d), a.fromArray(n, p), o.fromArray(n, f), s.subVectors(o, a), c.subVectors(i, a), 
s.cross(c), r[d] += s.x, r[d + 1] += s.y, r[d + 2] += s.z, r[p] += s.x, r[p + 1] += s.y, 
r[p + 2] += s.z, r[f] += s.x, r[f + 1] += s.y, r[f + 2] += s.z;
}
} else for (u = 0, h = n.length; u < h; u += 9) i.fromArray(n, u), a.fromArray(n, u + 3), 
o.fromArray(n, u + 6), s.subVectors(o, a), c.subVectors(i, a), s.cross(c), r[u] = s.x, 
r[u + 1] = s.y, r[u + 2] = s.z, r[u + 3] = s.x, r[u + 4] = s.y, r[u + 5] = s.z, 
r[u + 6] = s.x, r[u + 7] = s.y, r[u + 8] = s.z;
this.normalizeNormals(), t.normal.needsUpdate = !0;
}
},
merge: function(e, t) {
if (e && e.isBufferGmtr) {
void 0 === t && (t = 0, console.warn("$3.BufferGmtr.merge(): Overwriting original geometry, starting at offset=0. Use BufferGmtrUtils.mergeBufferGeometries() for lossless merge."));
var n, r = this.attributes;
for (n in r) if (void 0 !== e.attributes[n]) {
var i = r[n].array, a = e.attributes[n], o = a.array, s = a.itemSize * t;
a = Math.min(o.length, i.length - s);
for (var c = 0; c < a; c++, s++) i[s] = o[c];
}
return this;
}
console.error("$3.BufferGmtr.merge(): geometry not an instance of $3.BufferGmtr.", e);
},
normalizeNormals: function() {
for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) ko.x = e.getX(t), 
ko.y = e.getY(t), ko.z = e.getZ(t), ko.normalize(), e.setXYZ(t, ko.x, ko.y, ko.z);
},
toNonIndexed: function() {
function e(e, t) {
var n = e.array, r = e.itemSize;
e = e.normalized;
for (var i, a = new n.constructor(t.length * r), o = 0, s = 0, c = t.length; s < c; s++) {
i = t[s] * r;
for (var l = 0; l < r; l++) a[o++] = n[i++];
}
return new L(a, r, e);
}
if (null === this.index) return console.warn("$3.BufferGmtr.toNonIndexed(): Gmtr is already non-indexed."), 
this;
var t = new B(), n = this.index.array, r = this.attributes;
for (o in r) {
var i = e(r[o], n);
t.setAttribute(o, i);
}
for (var a in r = this.morphAttributes) {
for (var o = [], s = 0, c = (i = r[a]).length; s < c; s++) {
var l = e(i[s], n);
o.push(l);
}
t.morphAttributes[a] = o;
}
for (t.morphTargetsRelative = this.morphTargetsRelative, a = 0, r = (n = this.groups).length; a < r; a++) o = n[a], 
t.addGroup(o.start, o.count, o.materialIndex);
return t;
},
toJSON: function() {
var e = {
metadata: {
version: 4.5,
type: "BufferGmtr",
generator: "BufferGmtr.toJSON"
}
};
if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 
0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
var t = this.parameters;
for (n in t) void 0 !== t[n] && (e[n] = t[n]);
return e;
}
e.data = {
attributes: {}
};
var n = this.index;
for (var r in null !== n && (e.data.index = {
type: n.array.constructor.name,
array: Array.prototype.slice.call(n.array)
}), n = this.attributes) {
var i = n[r], a = i.toJSON(e.data);
"" !== i.name && (a.name = i.name), e.data.attributes[r] = a;
}
for (t in r = {}, n = !1, this.morphAttributes) {
a = [];
for (var o = 0, s = (i = this.morphAttributes[t]).length; o < s; o++) {
var c = i[o], l = c.toJSON(e.data);
"" !== c.name && (l.name = c.name), a.push(l);
}
0 < a.length && (r[t] = a, n = !0);
}
return n && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative), 
0 < (t = this.groups).length && (e.data.groups = JSON.parse(JSON.stringify(t))), 
null !== (t = this.boundingSphere) && (e.data.boundingSphere = {
center: t.center.toArray(),
radius: t.radius
}), e;
},
clone: function() {
return new B().copy(this);
},
copy: function(e) {
this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
this.boundingSphere = this.boundingBox = null;
var t = {};
this.name = e.name;
var n = e.index;
for (var r in null !== n && this.setIndex(n.clone(t)), n = e.attributes) this.setAttribute(r, n[r].clone(t));
for (var i in r = e.morphAttributes) {
n = [];
for (var a = r[i], o = 0, s = a.length; o < s; o++) n.push(a[o].clone(t));
this.morphAttributes[i] = n;
}
for (this.morphTargetsRelative = e.morphTargetsRelative, i = 0, r = (t = e.groups).length; i < r; i++) n = t[i], 
this.addGroup(n.start, n.count, n.materialIndex);
return null !== (t = e.boundingBox) && (this.boundingBox = t.clone()), null !== (t = e.boundingSphere) && (this.boundingSphere = t.clone()), 
this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, 
this.userData = e.userData, this;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
}
});
var Oo = new u(), Do = new y(), No = new v(), Io = new l(), Ro = new l(), jo = new l(), Uo = new l(), Bo = new l(), zo = new l(), Fo = new l(), Go = new l(), Vo = new l(), Wo = new n(), qo = new n(), Ho = new n(), Xo = new l(), Yo = new l();
z.prototype = Object.assign(Object.create(p.prototype), {
constructor: z,
isMesh: !0,
copy: function(e) {
return p.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), 
void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), 
this.material = e.material, this.geometry = e.geometry, this;
},
updateMorphTargets: function() {
var e = this.geometry;
if (e.isBufferGmtr) {
e = e.morphAttributes;
var t = Object.keys(e);
if (0 < t.length && void 0 !== (e = e[t[0]])) {
this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0;
for (var n = e.length; t < n; t++) {
var r = e[t].name || String(t);
this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = t;
}
}
} else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("$3.Mesh.updateMorphTargets() no longer supports $3.Gmtr. Use $3.BufferGmtr instead.");
},
raycast: function(e, t) {
var r = this.geometry, i = this.material, a = this.matrixWorld;
if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), No.copy(r.boundingSphere), 
No.applyMatrix4(a), !1 !== e.ray.intersectsSphere(No) && (Oo.getInverse(a), Do.copy(e.ray).applyMatrix4(Oo), 
null === r.boundingBox || !1 !== Do.intersectsBox(r.boundingBox)))) if (r.isBufferGmtr) {
var o = r.index, s = r.attributes.position;
a = r.morphAttributes.position;
var c = r.morphTargetsRelative, l = r.attributes.uv, u = r.attributes.uv2, h = r.groups, d = r.drawRange;
if (null !== o) if (Array.isArray(i)) for (var p = 0, f = h.length; p < f; p++) for (var m = h[p], g = i[m.materialIndex], v = Math.max(m.start, d.start), y = Math.min(m.start + m.count, d.start + d.count); v < y; v += 3) {
r = o.getX(v);
var $ = o.getX(v + 1), x = o.getX(v + 2);
(r = G(this, g, e, Do, s, a, c, l, u, r, $, x)) && (r.faceIndex = Math.floor(v / 3), 
r.face.materialIndex = m.materialIndex, t.push(r));
} else for (h = Math.max(0, d.start), d = Math.min(o.count, d.start + d.count); h < d; h += 3) r = o.getX(h), 
p = o.getX(h + 1), f = o.getX(h + 2), (r = G(this, i, e, Do, s, a, c, l, u, r, p, f)) && (r.faceIndex = Math.floor(h / 3), 
t.push(r)); else if (void 0 !== s) if (Array.isArray(i)) for (o = 0, p = h.length; o < p; o++) for (m = i[(f = h[o]).materialIndex], 
g = Math.max(f.start, d.start), v = Math.min(f.start + f.count, d.start + d.count); g < v; g += 3) (r = G(this, m, e, Do, s, a, c, l, u, g, g + 1, g + 2)) && (r.faceIndex = Math.floor(g / 3), 
r.face.materialIndex = f.materialIndex, t.push(r)); else for (h = Math.max(0, d.start), 
d = Math.min(s.count, d.start + d.count); h < d; h += 3) (r = G(this, i, e, Do, s, a, c, l, u, h, h + 1, h + 2)) && (r.faceIndex = Math.floor(h / 3), 
t.push(r));
} else if (r.isGmtr) for (a = Array.isArray(i), c = r.vertices, l = r.faces, 0 < (r = r.faceVertexUvs[0]).length && (s = r), 
u = 0, d = l.length; u < d; u++) h = l[u], void 0 !== (r = a ? i[h.materialIndex] : i) && (o = c[h.a], 
p = c[h.b], f = c[h.c], r = F(this, r, e, Do, o, p, f, Xo)) && (s && s[u] && (m = s[u], 
Wo.copy(m[0]), qo.copy(m[1]), Ho.copy(m[2]), r.uv = b.getUV(Xo, o, p, f, Wo, qo, Ho, new n())), 
r.face = h, r.faceIndex = u, t.push(r));
}
});
var Jo = 0, Zo = new u(), Ko = new p(), Qo = new l();
V.prototype = Object.assign(Object.create(t.prototype), {
constructor: V,
isGmtr: !0,
applyMatrix4: function(e) {
for (var t = new r().getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) this.vertices[n].applyMatrix4(e);
for (e = 0, n = this.faces.length; e < n; e++) {
(i = this.faces[e]).normal.applyMatrix3(t).normalize();
for (var a = 0, o = i.vertexNormals.length; a < o; a++) i.vertexNormals[a].applyMatrix3(t).normalize();
}
return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
},
rotateX: function(e) {
return Zo.makeRotationX(e), this.applyMatrix4(Zo), this;
},
rotateY: function(e) {
return Zo.makeRotationY(e), this.applyMatrix4(Zo), this;
},
rotateZ: function(e) {
return Zo.makeRotationZ(e), this.applyMatrix4(Zo), this;
},
translate: function(e, t, n) {
return Zo.makeTranslation(e, t, n), this.applyMatrix4(Zo), this;
},
scale: function(e, t, n) {
return Zo.makeScale(e, t, n), this.applyMatrix4(Zo), this;
},
lookAt: function(e) {
return Ko.lookAt(e), Ko.updateMatrix(), this.applyMatrix4(Ko.matrix), this;
},
fromBufferGmtr: function(e) {
function t(e, t, i, a) {
var o = void 0 === c ? [] : [ r.colors[e].clone(), r.colors[t].clone(), r.colors[i].clone() ];
a = new S(e, t, i, void 0 === s ? [] : [ new l().fromArray(s, 3 * e), new l().fromArray(s, 3 * t), new l().fromArray(s, 3 * i) ], o, a), 
r.faces.push(a), void 0 !== u && r.faceVertexUvs[0].push([ new n().fromArray(u, 2 * e), new n().fromArray(u, 2 * t), new n().fromArray(u, 2 * i) ]), 
void 0 !== h && r.faceVertexUvs[1].push([ new n().fromArray(h, 2 * e), new n().fromArray(h, 2 * t), new n().fromArray(h, 2 * i) ]);
}
var r = this, i = null !== e.index ? e.index.array : void 0, a = e.attributes;
if (void 0 === a.position) return console.error("$3.Gmtr.fromBufferGmtr(): Position attribute required for conversion."), 
this;
var o = a.position.array, s = void 0 !== a.normal ? a.normal.array : void 0, c = void 0 !== a.color ? a.color.array : void 0, u = void 0 !== a.uv ? a.uv.array : void 0, h = void 0 !== a.uv2 ? a.uv2.array : void 0;
for (void 0 !== h && (this.faceVertexUvs[1] = []), a = 0; a < o.length; a += 3) r.vertices.push(new l().fromArray(o, a)), 
void 0 !== c && r.colors.push(new x().fromArray(c, a));
if (0 < (a = e.groups).length) for (o = 0; o < a.length; o++) {
var d = a[o], p = d.start, f = p;
for (p += d.count; f < p; f += 3) void 0 !== i ? t(i[f], i[f + 1], i[f + 2], d.materialIndex) : t(f, f + 1, f + 2, d.materialIndex);
} else if (void 0 !== i) for (a = 0; a < i.length; a += 3) t(i[a], i[a + 1], i[a + 2]); else for (i = 0; i < o.length / 3; i += 3) t(i, i + 1, i + 2);
return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), 
null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this;
},
center: function() {
return this.computeBoundingBox(), this.boundingBox.getCenter(Qo).negate(), this.translate(Qo.x, Qo.y, Qo.z), 
this;
},
normalize: function() {
this.computeBoundingSphere();
var e = this.boundingSphere.center, t = this.boundingSphere.radius;
t = 0 === t ? 1 : 1 / t;
var n = new u();
return n.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), 
this.applyMatrix4(n), this;
},
computeFaceNormals: function() {
for (var e = new l(), t = new l(), n = 0, r = this.faces.length; n < r; n++) {
var i = this.faces[n], a = this.vertices[i.a], o = this.vertices[i.b];
e.subVectors(this.vertices[i.c], o), t.subVectors(a, o), e.cross(t), e.normalize(), 
i.normal.copy(e);
}
},
computeVertexNormals: function(e) {
void 0 === e && (e = !0);
for (var t = Array(this.vertices.length), n = 0, r = this.vertices.length; n < r; n++) t[n] = new l();
if (e) {
e = new l(), n = new l(), r = 0;
for (var i = this.faces.length; r < i; r++) {
var a = this.faces[r], o = this.vertices[a.a], s = this.vertices[a.b];
e.subVectors(this.vertices[a.c], s), n.subVectors(o, s), e.cross(n), t[a.a].add(e), 
t[a.b].add(e), t[a.c].add(e);
}
} else for (this.computeFaceNormals(), e = 0, n = this.faces.length; e < n; e++) t[(r = this.faces[e]).a].add(r.normal), 
t[r.b].add(r.normal), t[r.c].add(r.normal);
for (e = 0, n = this.vertices.length; e < n; e++) t[e].normalize();
for (e = 0, n = this.faces.length; e < n; e++) 3 === (i = (r = this.faces[e]).vertexNormals).length ? (i[0].copy(t[r.a]), 
i[1].copy(t[r.b]), i[2].copy(t[r.c])) : (i[0] = t[r.a].clone(), i[1] = t[r.b].clone(), 
i[2] = t[r.c].clone());
0 < this.faces.length && (this.normalsNeedUpdate = !0);
},
computeFlatVertexNormals: function() {
this.computeFaceNormals();
for (var e = 0, t = this.faces.length; e < t; e++) {
var n = this.faces[e], r = n.vertexNormals;
3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), 
r[1] = n.normal.clone(), r[2] = n.normal.clone());
}
0 < this.faces.length && (this.normalsNeedUpdate = !0);
},
computeMorphNormals: function() {
for (var e = 0, t = this.faces.length; e < t; e++) {
var n = this.faces[e];
n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), 
n.__originalVertexNormals || (n.__originalVertexNormals = []);
for (var r = 0, i = n.vertexNormals.length; r < i; r++) n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone();
}
for ((e = new V()).faces = this.faces, t = 0, n = this.morphTargets.length; t < n; t++) {
if (!this.morphNormals[t]) {
this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [], 
r = this.morphNormals[t].faceNormals, i = this.morphNormals[t].vertexNormals;
for (var a = 0, o = this.faces.length; a < o; a++) {
var s = new l(), c = {
a: new l(),
b: new l(),
c: new l()
};
r.push(s), i.push(c);
}
}
for (r = this.morphNormals[t], e.vertices = this.morphTargets[t].vertices, e.computeFaceNormals(), 
e.computeVertexNormals(), i = 0, a = this.faces.length; i < a; i++) o = this.faces[i], 
s = r.vertexNormals[i], r.faceNormals[i].copy(o.normal), s.a.copy(o.vertexNormals[0]), 
s.b.copy(o.vertexNormals[1]), s.c.copy(o.vertexNormals[2]);
}
for (e = 0, t = this.faces.length; e < t; e++) (n = this.faces[e]).normal = n.__originalFaceNormal, 
n.vertexNormals = n.__originalVertexNormals;
},
computeBoundingBox: function() {
null === this.boundingBox && (this.boundingBox = new m()), this.boundingBox.setFromPoints(this.vertices);
},
computeBoundingSphere: function() {
null === this.boundingSphere && (this.boundingSphere = new v()), this.boundingSphere.setFromPoints(this.vertices);
},
merge: function(e, t, n) {
if (e && e.isGmtr) {
var i, a = this.vertices.length, o = this.vertices, s = e.vertices, c = this.faces, l = e.faces, u = this.colors, h = e.colors;
void 0 === n && (n = 0), void 0 !== t && (i = new r().getNormalMatrix(t));
for (var d = 0, p = s.length; d < p; d++) {
var f = s[d].clone();
void 0 !== t && f.applyMatrix4(t), o.push(f);
}
for (t = 0, o = h.length; t < o; t++) u.push(h[t].clone());
for (u = 0, h = l.length; u < h; u++) {
p = (t = l[u]).vertexNormals, s = t.vertexColors, (o = new S(t.a + a, t.b + a, t.c + a)).normal.copy(t.normal), 
void 0 !== i && o.normal.applyMatrix3(i).normalize(), f = 0;
for (var m = p.length; f < m; f++) d = p[f].clone(), void 0 !== i && d.applyMatrix3(i).normalize(), 
o.vertexNormals.push(d);
for (o.color.copy(t.color), p = 0, f = s.length; p < f; p++) d = s[p], o.vertexColors.push(d.clone());
o.materialIndex = t.materialIndex + n, c.push(o);
}
for (n = 0, i = e.faceVertexUvs.length; n < i; n++) for (a = e.faceVertexUvs[n], 
void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []), c = 0, l = a.length; c < l; c++) {
for (h = [], t = 0, o = (u = a[c]).length; t < o; t++) h.push(u[t].clone());
this.faceVertexUvs[n].push(h);
}
} else console.error("$3.Gmtr.merge(): geometry not an instance of $3.Gmtr.", e);
},
mergeMesh: function(e) {
e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("$3.Gmtr.mergeMesh(): mesh not an instance of $3.Mesh.", e);
},
mergeVertices: function() {
for (var e = {}, t = [], n = [], r = Math.pow(10, 4), i = 0, a = this.vertices.length; i < a; i++) {
var o = this.vertices[i];
void 0 === e[o = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r)] ? (e[o] = i, 
t.push(this.vertices[i]), n[i] = t.length - 1) : n[i] = n[e[o]];
}
for (e = [], r = 0, i = this.faces.length; r < i; r++) for ((a = this.faces[r]).a = n[a.a], 
a.b = n[a.b], a.c = n[a.c], a = [ a.a, a.b, a.c ], o = 0; 3 > o; o++) if (a[o] === a[(o + 1) % 3]) {
e.push(r);
break;
}
for (n = e.length - 1; 0 <= n; n--) for (r = e[n], this.faces.splice(r, 1), i = 0, 
a = this.faceVertexUvs.length; i < a; i++) this.faceVertexUvs[i].splice(r, 1);
return n = this.vertices.length - t.length, this.vertices = t, n;
},
setFromPoints: function(e) {
this.vertices = [];
for (var t = 0, n = e.length; t < n; t++) {
var r = e[t];
this.vertices.push(new l(r.x, r.y, r.z || 0));
}
return this;
},
sortFacesByMtrlIndex: function() {
for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
e.sort(function(e, t) {
return e.materialIndex - t.materialIndex;
}), n = this.faceVertexUvs[0];
var r, i, a = this.faceVertexUvs[1];
n && n.length === t && (r = []), a && a.length === t && (i = []);
for (var o = 0; o < t; o++) {
var s = e[o]._id;
r && r.push(n[s]), i && i.push(a[s]);
}
r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i);
},
toJSON: function() {
function e(e, t, n) {
return n ? e | 1 << t : e & ~(1 << t);
}
function t(e) {
var t = e.x.toString() + e.y.toString() + e.z.toString();
return void 0 !== l[t] ? l[t] : (l[t] = c.length / 3, c.push(e.x, e.y, e.z), l[t]);
}
function n(e) {
var t = e.r.toString() + e.g.toString() + e.b.toString();
return void 0 !== h[t] ? h[t] : (h[t] = u.length, u.push(e.getHex()), h[t]);
}
function r(e) {
var t = e.x.toString() + e.y.toString();
return void 0 !== p[t] ? p[t] : (p[t] = d.length / 2, d.push(e.x, e.y), p[t]);
}
var i = {
metadata: {
version: 4.5,
type: "Gmtr",
generator: "Gmtr.toJSON"
}
};
if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), 
void 0 !== this.parameters) {
var a, o = this.parameters;
for (a in o) void 0 !== o[a] && (i[a] = o[a]);
return i;
}
for (o = [], a = 0; a < this.vertices.length; a++) {
var s = this.vertices[a];
o.push(s.x, s.y, s.z);
}
a = [];
var c = [], l = {}, u = [], h = {}, d = [], p = {};
for (s = 0; s < this.faces.length; s++) {
var f = this.faces[s], m = void 0 !== this.faceVertexUvs[0][s], g = 0 < f.normal.length(), v = 0 < f.vertexNormals.length, y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b, $ = 0 < f.vertexColors.length, b = 0;
b = e(b = e(b = e(b = e(b = e(b = e(b = e(b = e(b, 0, 0), 1, !0), 2, !1), 3, m), 4, g), 5, v), 6, y), 7, $), 
a.push(b), a.push(f.a, f.b, f.c), a.push(f.materialIndex), m && (m = this.faceVertexUvs[0][s], 
a.push(r(m[0]), r(m[1]), r(m[2]))), g && a.push(t(f.normal)), v && (g = f.vertexNormals, 
a.push(t(g[0]), t(g[1]), t(g[2]))), y && a.push(n(f.color)), $ && (f = f.vertexColors, 
a.push(n(f[0]), n(f[1]), n(f[2])));
}
return i.data = {}, i.data.vertices = o, i.data.normals = c, 0 < u.length && (i.data.colors = u), 
0 < d.length && (i.data.uvs = [ d ]), i.data.faces = a, i;
},
clone: function() {
return new V().copy(this);
},
copy: function(e) {
this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], 
this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
for (var t = e.vertices, n = 0, r = t.length; n < r; n++) this.vertices.push(t[n].clone());
for (n = 0, r = (t = e.colors).length; n < r; n++) this.colors.push(t[n].clone());
for (n = 0, r = (t = e.faces).length; n < r; n++) this.faces.push(t[n].clone());
for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
r = e.faceVertexUvs[t], void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
for (var i = 0, a = r.length; i < a; i++) {
for (var o = r[i], s = [], c = 0, l = o.length; c < l; c++) s.push(o[c].clone());
this.faceVertexUvs[t].push(s);
}
}
for (n = 0, r = (t = e.morphTargets).length; n < r; n++) {
if ((i = {}).name = t[n].name, void 0 !== t[n].vertices) for (i.vertices = [], a = 0, 
o = t[n].vertices.length; a < o; a++) i.vertices.push(t[n].vertices[a].clone());
if (void 0 !== t[n].normals) for (i.normals = [], a = 0, o = t[n].normals.length; a < o; a++) i.normals.push(t[n].normals[a].clone());
this.morphTargets.push(i);
}
for (n = 0, r = (t = e.morphNormals).length; n < r; n++) {
if (i = {}, void 0 !== t[n].vertexNormals) for (i.vertexNormals = [], a = 0, o = t[n].vertexNormals.length; a < o; a++) s = t[n].vertexNormals[a], 
(c = {}).a = s.a.clone(), c.b = s.b.clone(), c.c = s.c.clone(), i.vertexNormals.push(c);
if (void 0 !== t[n].faceNormals) for (i.faceNormals = [], a = 0, o = t[n].faceNormals.length; a < o; a++) i.faceNormals.push(t[n].faceNormals[a].clone());
this.morphNormals.push(i);
}
for (n = 0, r = (t = e.skinWeights).length; n < r; n++) this.skinWeights.push(t[n].clone());
for (n = 0, r = (t = e.skinIndices).length; n < r; n++) this.skinIndices.push(t[n].clone());
for (n = 0, r = (t = e.lineDistances).length; n < r; n++) this.lineDistances.push(t[n]);
return null !== (t = e.boundingBox) && (this.boundingBox = t.clone()), null !== (t = e.boundingSphere) && (this.boundingSphere = t.clone()), 
this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, 
this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, 
this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, 
this.groupsNeedUpdate = e.groupsNeedUpdate, this;
},
dispose: function() {
this.dispatchEvent({
type: "dispose"
});
}
});
var es = function(e) {
function t(t, n, r, i, a, o) {
e.call(this), this.type = "BoxGmtr", this.parameters = {
width: t,
height: n,
depth: r,
widthSegments: i,
heightSegments: a,
depthSegments: o
}, this.fromBufferGmtr(new ts(t, n, r, i, a, o)), this.mergeVertices();
}
return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
}(V), ts = function(e) {
function t(t, n, r, i, a, o) {
function s(e, t, n, r, i, a, o, s, g, v, y) {
var $ = a / g, b = o / v, x = a / 2, w = o / 2, _ = s / 2;
o = g + 1;
for (var M = v + 1, S = a = 0, A = new l(), T = 0; T < M; T++) for (var L = T * b - w, C = 0; C < o; C++) A[e] = (C * $ - x) * r, 
A[t] = L * i, A[n] = _, h.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = 0 < s ? 1 : -1, 
d.push(A.x, A.y, A.z), p.push(C / g), p.push(1 - T / v), a += 1;
for (e = 0; e < v; e++) for (t = 0; t < g; t++) n = f + t + o * (e + 1), r = f + (t + 1) + o * (e + 1), 
i = f + (t + 1) + o * e, u.push(f + t + o * e, n, i), u.push(n, r, i), S += 6;
c.addGroup(m, S, y), m += S, f += a;
}
e.call(this), this.type = "BoxBufferGmtr", this.parameters = {
width: t,
height: n,
depth: r,
widthSegments: i,
heightSegments: a,
depthSegments: o
};
var c = this;
t = t || 1, n = n || 1, r = r || 1, i = Math.floor(i) || 1, a = Math.floor(a) || 1, 
o = Math.floor(o) || 1;
var u = [], h = [], d = [], p = [], f = 0, m = 0;
s("z", "y", "x", -1, -1, r, n, t, o, a, 0), s("z", "y", "x", 1, -1, r, n, -t, o, a, 1), 
s("x", "z", "y", 1, 1, t, r, n, i, o, 2), s("x", "z", "y", 1, -1, t, r, -n, i, o, 3), 
s("x", "y", "z", 1, -1, t, n, r, i, a, 4), s("x", "y", "z", -1, -1, t, n, -r, i, a, 5), 
this.setIndex(u), this.setAttribute("position", new I(h, 3)), this.setAttribute("normal", new I(d, 3)), 
this.setAttribute("uv", new I(p, 2));
}
return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
}(B), ns = {
clone: W,
merge: q
};
H.prototype = Object.create(A.prototype), H.prototype.constructor = H, H.prototype.isShaderMtrl = !0, 
H.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, 
this.uniforms = W(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, 
this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, 
this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, 
this.extensions = Object.assign({}, e.extensions), this;
}, H.prototype.toJSON = function(e) {
var t = A.prototype.toJSON.call(this, e);
for (var n in t.uniforms = {}, this.uniforms) {
var r = this.uniforms[n].value;
t.uniforms[n] = r && r.isTexture ? {
type: "t",
value: r.toJSON(e).uuid
} : r && r.isColor ? {
type: "c",
value: r.getHex()
} : r && r.isVector2 ? {
type: "v2",
value: r.toArray()
} : r && r.isVector3 ? {
type: "v3",
value: r.toArray()
} : r && r.isVector4 ? {
type: "v4",
value: r.toArray()
} : r && r.isMatrix3 ? {
type: "m3",
value: r.toArray()
} : r && r.isMatrix4 ? {
type: "m4",
value: r.toArray()
} : {
value: r
};
}
for (var i in 0 < Object.keys(this.defines).length && (t.defines = this.defines), 
t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, 
this.extensions) !0 === this.extensions[i] && (e[i] = !0);
return 0 < Object.keys(e).length && (t.extensions = e), t;
}, X.prototype = Object.assign(Object.create(p.prototype), {
constructor: X,
isCamera: !0,
copy: function(e, t) {
return p.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), 
this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), 
this;
},
getWorldDirection: function(e) {
void 0 === e && (console.warn("$3.Camera: .getWorldDirection() target is now required"), 
e = new l()), this.updateMatrixWorld(!0);
var t = this.matrixWorld.elements;
return e.set(-t[8], -t[9], -t[10]).normalize();
},
updateMatrixWorld: function(e) {
p.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
},
updateWorldMatrix: function(e, t) {
p.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
},
clone: function() {
return new this.constructor().copy(this);
}
}), Y.prototype = Object.assign(Object.create(X.prototype), {
constructor: Y,
isPerspectiveCamera: !0,
copy: function(e, t) {
return X.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, 
this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, 
this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, 
this.filmOffset = e.filmOffset, this;
},
setFocalLength: function(e) {
e = .5 * this.getFilmHeight() / e, this.fov = 2 * da.RAD2DEG * Math.atan(e), this.updateProjectionMatrix();
},
getFocalLength: function() {
var e = Math.tan(.5 * da.DEG2RAD * this.fov);
return .5 * this.getFilmHeight() / e;
},
getEffectiveFOV: function() {
return 2 * da.RAD2DEG * Math.atan(Math.tan(.5 * da.DEG2RAD * this.fov) / this.zoom);
},
getFilmWidth: function() {
return this.filmGauge * Math.min(this.aspect, 1);
},
getFilmHeight: function() {
return this.filmGauge / Math.max(this.aspect, 1);
},
setViewOffset: function(e, t, n, r, i, a) {
this.aspect = e / t, null === this.view && (this.view = {
enabled: !0,
fullWidth: 1,
fullHeight: 1,
offsetX: 0,
offsetY: 0,
width: 1,
height: 1
}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, 
this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
},
clearViewOffset: function() {
null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
},
updateProjectionMatrix: function() {
var e = this.near, t = e * Math.tan(.5 * da.DEG2RAD * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, i = -.5 * r, a = this.view;
if (null !== this.view && this.view.enabled) {
var o = a.fullWidth, s = a.fullHeight;
i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s;
}
0 !== (a = this.filmOffset) && (i += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), 
this.projectionMatrixInverse.getInverse(this.projectionMatrix);
},
toJSON: function(e) {
return (e = p.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, 
e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, 
e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), 
e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
}
}), J.prototype = Object.create(p.prototype), J.prototype.constructor = J, Z.prototype = Object.create(o.prototype), 
Z.prototype.constructor = Z, Z.prototype.isWebGLCubeRenderTarget = !0, Z.prototype.fromEquirectangularTexture = function(e, t) {
this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
var n = new f(), r = new H({
type: "CubemapFromEquirect",
uniforms: W({
tEquirect: {
value: null
}
}),
vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
side: 1,
blending: 0
});
return r.uniforms.tEquirect.value = t, t = new z(new ts(5, 5, 5), r), n.add(t), 
new J(1, 10, this).update(e, n), t.geometry.dispose(), t.material.dispose(), this;
}, K.prototype = Object.create(i.prototype), K.prototype.constructor = K, K.prototype.isDataTexture = !0;
var rs = new v(), is = new l();
Object.assign(Q.prototype, {
set: function(e, t, n, r, i, a) {
var o = this.planes;
return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), 
this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
for (var t = this.planes, n = 0; 6 > n; n++) t[n].copy(e.planes[n]);
return this;
},
setFromProjectionMatrix: function(e) {
var t = this.planes, n = e.elements;
e = n[0];
var r = n[1], i = n[2], a = n[3], o = n[4], s = n[5], c = n[6], l = n[7], u = n[8], h = n[9], d = n[10], p = n[11], f = n[12], m = n[13], g = n[14];
return n = n[15], t[0].setComponents(a - e, l - o, p - u, n - f).normalize(), t[1].setComponents(a + e, l + o, p + u, n + f).normalize(), 
t[2].setComponents(a + r, l + s, p + h, n + m).normalize(), t[3].setComponents(a - r, l - s, p - h, n - m).normalize(), 
t[4].setComponents(a - i, l - c, p - d, n - g).normalize(), t[5].setComponents(a + i, l + c, p + d, n + g).normalize(), 
this;
},
intersectsObject: function(e) {
var t = e.geometry;
return null === t.boundingSphere && t.computeBoundingSphere(), rs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), 
this.intersectsSphere(rs);
},
intersectsSprite: function(e) {
return rs.center.set(0, 0, 0), rs.radius = .7071067811865476, rs.applyMatrix4(e.matrixWorld), 
this.intersectsSphere(rs);
},
intersectsSphere: function(e) {
var t = this.planes, n = e.center;
e = -e.radius;
for (var r = 0; 6 > r; r++) if (t[r].distanceToPoint(n) < e) return !1;
return !0;
},
intersectsBox: function(e) {
for (var t = this.planes, n = 0; 6 > n; n++) {
var r = t[n];
if (is.x = 0 < r.normal.x ? e.max.x : e.min.x, is.y = 0 < r.normal.y ? e.max.y : e.min.y, 
is.z = 0 < r.normal.z ? e.max.z : e.min.z, 0 > r.distanceToPoint(is)) return !1;
}
return !0;
},
containsPoint: function(e) {
for (var t = this.planes, n = 0; 6 > n; n++) if (0 > t[n].distanceToPoint(e)) return !1;
return !0;
}
});
var as = {
common: {
diffuse: {
value: new x(15658734)
},
opacity: {
value: 1
},
map: {
value: null
},
uvTransform: {
value: new r()
},
uv2Transform: {
value: new r()
},
alphaMap: {
value: null
}
},
specularmap: {
specularMap: {
value: null
}
},
envmap: {
envMap: {
value: null
},
flipEnvMap: {
value: -1
},
reflectivity: {
value: 1
},
refractionRatio: {
value: .98
},
maxMipLevel: {
value: 0
}
},
aomap: {
aoMap: {
value: null
},
aoMapIntensity: {
value: 1
}
},
lightmap: {
lightMap: {
value: null
},
lightMapIntensity: {
value: 1
}
},
emissivemap: {
emissiveMap: {
value: null
}
},
bumpmap: {
bumpMap: {
value: null
},
bumpScale: {
value: 1
}
},
normalmap: {
normalMap: {
value: null
},
normalScale: {
value: new n(1, 1)
}
},
displacementmap: {
displacementMap: {
value: null
},
displacementScale: {
value: 1
},
displacementBias: {
value: 0
}
},
roughnessmap: {
roughnessMap: {
value: null
}
},
metalnessmap: {
metalnessMap: {
value: null
}
},
gradientmap: {
gradientMap: {
value: null
}
},
fog: {
fogDensity: {
value: 25e-5
},
fogNear: {
value: 1
},
fogFar: {
value: 2e3
},
fogColor: {
value: new x(16777215)
}
},
lights: {
ambientLightColor: {
value: []
},
lightProbe: {
value: []
},
directionalLights: {
value: [],
properties: {
direction: {},
color: {}
}
},
directionalLightShadows: {
value: [],
properties: {
shadowBias: {},
shadowRadius: {},
shadowMapSize: {}
}
},
directionalShadowMap: {
value: []
},
directionalShadowMatrix: {
value: []
},
spotLights: {
value: [],
properties: {
color: {},
position: {},
direction: {},
distance: {},
coneCos: {},
penumbraCos: {},
decay: {}
}
},
spotLightShadows: {
value: [],
properties: {
shadowBias: {},
shadowRadius: {},
shadowMapSize: {}
}
},
spotShadowMap: {
value: []
},
spotShadowMatrix: {
value: []
},
pointLights: {
value: [],
properties: {
color: {},
position: {},
decay: {},
distance: {}
}
},
pointLightShadows: {
value: [],
properties: {
shadowBias: {},
shadowRadius: {},
shadowMapSize: {},
shadowCameraNear: {},
shadowCameraFar: {}
}
},
pointShadowMap: {
value: []
},
pointShadowMatrix: {
value: []
},
hemisphereLights: {
value: [],
properties: {
direction: {},
skyColor: {},
groundColor: {}
}
},
rectAreaLights: {
value: [],
properties: {
color: {},
position: {},
width: {},
height: {}
}
}
},
points: {
diffuse: {
value: new x(15658734)
},
opacity: {
value: 1
},
size: {
value: 1
},
scale: {
value: 1
},
map: {
value: null
},
alphaMap: {
value: null
},
uvTransform: {
value: new r()
}
},
sprite: {
diffuse: {
value: new x(15658734)
},
opacity: {
value: 1
},
center: {
value: new n(.5, .5)
},
rotation: {
value: 0
},
map: {
value: null
},
alphaMap: {
value: null
},
uvTransform: {
value: new r()
}
}
};
ne.prototype = Object.create(V.prototype), ne.prototype.constructor = ne, re.prototype = Object.create(B.prototype), 
re.prototype.constructor = re;
var os = {
alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
begin_vertex: "vec3 transformed = vec3( position );",
beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGmtr;\nbackGmtr.position = geometry.position;\nbackGmtr.normal = -geometry.normal;\nbackGmtr.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGmtr );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGmtr );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
lights_toon_fragment: "ToonMtrl material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMtrl {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMtrl material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMtrl material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Mtrl_LightProbeLOD( material )\t(0)",
lights_phong_fragment: "BlinnPhongMtrl material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMtrl {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMtrl material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMtrl material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Mtrl_LightProbeLOD( material )\t(0)",
lights_physical_fragment: "PhysicalMtrl material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
lights_physical_pars_fragment: "struct PhysicalMtrl {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMtrl material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMtrl material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMtrl material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMtrl material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
}, ss = {
basic: {
uniforms: q([ as.common, as.specularmap, as.envmap, as.aomap, as.lightmap, as.fog ]),
vertexShader: os.meshbasic_vert,
fragmentShader: os.meshbasic_frag
},
lambert: {
uniforms: q([ as.common, as.specularmap, as.envmap, as.aomap, as.lightmap, as.emissivemap, as.fog, as.lights, {
emissive: {
value: new x(0)
}
} ]),
vertexShader: os.meshlambert_vert,
fragmentShader: os.meshlambert_frag
},
phong: {
uniforms: q([ as.common, as.specularmap, as.envmap, as.aomap, as.lightmap, as.emissivemap, as.bumpmap, as.normalmap, as.displacementmap, as.fog, as.lights, {
emissive: {
value: new x(0)
},
specular: {
value: new x(1118481)
},
shininess: {
value: 30
}
} ]),
vertexShader: os.meshphong_vert,
fragmentShader: os.meshphong_frag
},
standard: {
uniforms: q([ as.common, as.envmap, as.aomap, as.lightmap, as.emissivemap, as.bumpmap, as.normalmap, as.displacementmap, as.roughnessmap, as.metalnessmap, as.fog, as.lights, {
emissive: {
value: new x(0)
},
roughness: {
value: 1
},
metalness: {
value: 0
},
envMapIntensity: {
value: 1
}
} ]),
vertexShader: os.meshphysical_vert,
fragmentShader: os.meshphysical_frag
},
toon: {
uniforms: q([ as.common, as.specularmap, as.aomap, as.lightmap, as.emissivemap, as.bumpmap, as.normalmap, as.displacementmap, as.gradientmap, as.fog, as.lights, {
emissive: {
value: new x(0)
},
specular: {
value: new x(1118481)
},
shininess: {
value: 30
}
} ]),
vertexShader: os.meshtoon_vert,
fragmentShader: os.meshtoon_frag
},
matcap: {
uniforms: q([ as.common, as.bumpmap, as.normalmap, as.displacementmap, as.fog, {
matcap: {
value: null
}
} ]),
vertexShader: os.meshmatcap_vert,
fragmentShader: os.meshmatcap_frag
},
points: {
uniforms: q([ as.points, as.fog ]),
vertexShader: os.points_vert,
fragmentShader: os.points_frag
},
dashed: {
uniforms: q([ as.common, as.fog, {
scale: {
value: 1
},
dashSize: {
value: 1
},
totalSize: {
value: 2
}
} ]),
vertexShader: os.linedashed_vert,
fragmentShader: os.linedashed_frag
},
depth: {
uniforms: q([ as.common, as.displacementmap ]),
vertexShader: os.depth_vert,
fragmentShader: os.depth_frag
},
normal: {
uniforms: q([ as.common, as.bumpmap, as.normalmap, as.displacementmap, {
opacity: {
value: 1
}
} ]),
vertexShader: os.normal_vert,
fragmentShader: os.normal_frag
},
sprite: {
uniforms: q([ as.sprite, as.fog ]),
vertexShader: os.sprite_vert,
fragmentShader: os.sprite_frag
},
background: {
uniforms: {
uvTransform: {
value: new r()
},
t2D: {
value: null
}
},
vertexShader: os.background_vert,
fragmentShader: os.background_frag
},
cube: {
uniforms: q([ as.envmap, {
opacity: {
value: 1
}
} ]),
vertexShader: os.cube_vert,
fragmentShader: os.cube_frag
},
equirect: {
uniforms: {
tEquirect: {
value: null
}
},
vertexShader: os.equirect_vert,
fragmentShader: os.equirect_frag
},
distanceRGBA: {
uniforms: q([ as.common, as.displacementmap, {
referencePosition: {
value: new l()
},
nearDistance: {
value: 1
},
farDistance: {
value: 1e3
}
} ]),
vertexShader: os.distanceRGBA_vert,
fragmentShader: os.distanceRGBA_frag
},
shadow: {
uniforms: q([ as.lights, as.fog, {
color: {
value: new x(0)
},
opacity: {
value: 1
}
} ]),
vertexShader: os.shadow_vert,
fragmentShader: os.shadow_frag
}
};
ss.physical = {
uniforms: q([ ss.standard.uniforms, {
clearcoat: {
value: 0
},
clearcoatMap: {
value: null
},
clearcoatRoughness: {
value: 0
},
clearcoatRoughnessMap: {
value: null
},
clearcoatNormalScale: {
value: new n(1, 1)
},
clearcoatNormalMap: {
value: null
},
sheen: {
value: new x(0)
},
transparency: {
value: 0
}
} ]),
vertexShader: os.meshphysical_vert,
fragmentShader: os.meshphysical_frag
}, ce.prototype = Object.create(i.prototype), ce.prototype.constructor = ce, ce.prototype.isCubeTexture = !0, 
Object.defineProperty(ce.prototype, "images", {
get: function() {
return this.image;
},
set: function(e) {
this.image = e;
}
}), le.prototype = Object.create(i.prototype), le.prototype.constructor = le, le.prototype.isDataTexture2DArray = !0, 
ue.prototype = Object.create(i.prototype), ue.prototype.constructor = ue, ue.prototype.isDataTexture3D = !0;
var cs = new i(), ls = new le(), us = new ue(), hs = new ce(), ds = [], ps = [], fs = new Float32Array(16), ms = new Float32Array(9), gs = new Float32Array(4);
We.prototype.updateCache = function(e) {
var t = this.cache;
e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), 
pe(t, e);
}, qe.prototype.setValue = function(e, t, n) {
for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
var o = r[i];
o.setValue(e, t[o.id], n);
}
};
var vs = /([\w\d_]+)(\])?(\[|\.)?/g;
He.prototype.setValue = function(e, t, n, r) {
void 0 !== (t = this.map[t]) && t.setValue(e, n, r);
}, He.prototype.setOptional = function(e, t, n) {
void 0 !== (t = t[n]) && this.setValue(e, n, t);
}, He.upload = function(e, t, n, r) {
for (var i = 0, a = t.length; i !== a; ++i) {
var o = t[i], s = n[o.id];
!1 !== s.needsUpdate && o.setValue(e, s.value, r);
}
}, He.seqWithValue = function(e, t) {
for (var n = [], r = 0, i = e.length; r !== i; ++r) {
var a = e[r];
a.id in t && n.push(a);
}
return n;
};
var ys = 0, $s = /^[ \t]*#include +<([\w\d./]+)>/gm, bs = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, xs = /#pragma unroll_loop_start[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g, ws = 0;
dt.prototype = Object.create(A.prototype), dt.prototype.constructor = dt, dt.prototype.isMeshDepthMtrl = !0, 
dt.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, 
this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, 
this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, 
this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, 
this;
}, pt.prototype = Object.create(A.prototype), pt.prototype.constructor = pt, pt.prototype.isMeshDistanceMtrl = !0, 
pt.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), 
this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, 
this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, 
this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, 
this.displacementBias = e.displacementBias, this;
}, gt.prototype = Object.assign(Object.create(Y.prototype), {
constructor: gt,
isArrayCamera: !0
}), vt.prototype = Object.assign(Object.create(p.prototype), {
constructor: vt,
isGroup: !0
}), Object.assign(yt.prototype, {
constructor: yt,
getTargetRaySpace: function() {
return null === this._targetRay && (this._targetRay = new vt(), this._targetRay.matrixAutoUpdate = !1, 
this._targetRay.visible = !1), this._targetRay;
},
getGripSpace: function() {
return null === this._grip && (this._grip = new vt(), this._grip.matrixAutoUpdate = !1, 
this._grip.visible = !1), this._grip;
},
dispatchEvent: function(e) {
return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), 
this;
},
disconnect: function(e) {
return this.dispatchEvent({
type: "disconnected",
data: e
}), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), 
this;
},
update: function(e, t, n) {
var r = null, i = null, a = this._targetRay, o = this._grip;
return e && (null !== a && (null !== (r = t.getPose(e.targetRaySpace, n)) && (a.matrix.fromArray(r.transform.matrix), 
a.matrix.decompose(a.position, a.rotation, a.scale))), null !== o && e.gripSpace && (null !== (i = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(i.transform.matrix), 
o.matrix.decompose(o.position, o.rotation, o.scale)))), null !== a && (a.visible = null !== r), 
null !== o && (o.visible = null !== i), this;
}
}), Object.assign($t.prototype, t.prototype), Object.assign(xt.prototype, {
isFogExp2: !0,
clone: function() {
return new xt(this.color, this.density);
},
toJSON: function() {
return {
type: "FogExp2",
color: this.color.getHex(),
density: this.density
};
}
}), Object.assign(wt.prototype, {
isFog: !0,
clone: function() {
return new wt(this.color, this.near, this.far);
},
toJSON: function() {
return {
type: "Fog",
color: this.color.getHex(),
near: this.near,
far: this.far
};
}
}), Object.defineProperty(_t.prototype, "needsUpdate", {
set: function(e) {
!0 === e && this.version++;
}
}), Object.assign(_t.prototype, {
isInterleavedBuffer: !0,
onUploadCallback: function() {},
setUsage: function(e) {
return this.usage = e, this;
},
copy: function(e) {
return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, 
this.usage = e.usage, this;
},
copyAt: function(e, t, n) {
e *= this.stride, n *= t.stride;
for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
return this;
},
set: function(e, t) {
return void 0 === t && (t = 0), this.array.set(e, t), this;
},
clone: function(e) {
return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = da.generateUUID()), 
void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer), 
(e = new _t(e = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), this.stride)).setUsage(this.usage), 
e;
},
onUpload: function(e) {
return this.onUploadCallback = e, this;
},
toJSON: function(e) {
return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = da.generateUUID()), 
void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), 
{
uuid: this.uuid,
buffer: this.array.buffer._uuid,
type: this.array.constructor.name,
stride: this.stride
};
}
});
var _s = new l();
Object.defineProperties(Mt.prototype, {
count: {
get: function() {
return this.data.count;
}
},
array: {
get: function() {
return this.data.array;
}
}
}), Object.assign(Mt.prototype, {
isInterleavedBufferAttribute: !0,
applyMatrix4: function(e) {
for (var t = 0, n = this.data.count; t < n; t++) _s.x = this.getX(t), _s.y = this.getY(t), 
_s.z = this.getZ(t), _s.applyMatrix4(e), this.setXYZ(t, _s.x, _s.y, _s.z);
return this;
},
setX: function(e, t) {
return this.data.array[e * this.data.stride + this.offset] = t, this;
},
setY: function(e, t) {
return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
},
setZ: function(e, t) {
return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
},
setW: function(e, t) {
return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
},
getX: function(e) {
return this.data.array[e * this.data.stride + this.offset];
},
getY: function(e) {
return this.data.array[e * this.data.stride + this.offset + 1];
},
getZ: function(e) {
return this.data.array[e * this.data.stride + this.offset + 2];
},
getW: function(e) {
return this.data.array[e * this.data.stride + this.offset + 3];
},
setXY: function(e, t, n) {
return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, 
this;
},
setXYZ: function(e, t, n, r) {
return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, 
this.data.array[e + 2] = r, this;
},
setXYZW: function(e, t, n, r, i) {
return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, 
this.data.array[e + 2] = r, this.data.array[e + 3] = i, this;
},
clone: function(e) {
if (void 0 === e) {
console.log("$3.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."), 
e = [];
for (var t = 0; t < this.count; t++) for (var n = t * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
return new L(new this.array.constructor(e), this.itemSize, this.normalized);
}
return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), 
new Mt(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
},
toJSON: function(e) {
if (void 0 === e) {
console.log("$3.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."), 
e = [];
for (var t = 0; t < this.count; t++) for (var n = t * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
return {
itemSize: this.itemSize,
type: this.array.constructor.name,
array: e,
normalized: this.normalized
};
}
return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), 
{
isInterleavedBufferAttribute: !0,
itemSize: this.itemSize,
data: this.data.uuid,
offset: this.offset,
normalized: this.normalized
};
}
}), St.prototype = Object.create(A.prototype), St.prototype.constructor = St, St.prototype.isSpriteMtrl = !0, 
St.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, 
this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, 
this;
};
var Ms, Ss = new l(), As = new l(), Ts = new l(), Ls = new n(), Cs = new n(), Es = new u(), Ps = new l(), ks = new l(), Os = new l(), Ds = new n(), Ns = new n(), Is = new n();
At.prototype = Object.assign(Object.create(p.prototype), {
constructor: At,
isSprite: !0,
raycast: function(e, t) {
null === e.camera && console.error('$3.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), 
As.setFromMatrixScale(this.matrixWorld), Es.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), 
Ts.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && As.multiplyScalar(-Ts.z);
var r = this.material.rotation;
if (0 !== r) var i = Math.cos(r), a = Math.sin(r);
r = this.center, Tt(Ps.set(-.5, -.5, 0), Ts, r, As, a, i), Tt(ks.set(.5, -.5, 0), Ts, r, As, a, i), 
Tt(Os.set(.5, .5, 0), Ts, r, As, a, i), Ds.set(0, 0), Ns.set(1, 0), Is.set(1, 1);
var o = e.ray.intersectTriangle(Ps, ks, Os, !1, Ss);
null === o && (Tt(ks.set(-.5, .5, 0), Ts, r, As, a, i), Ns.set(0, 1), null === (o = e.ray.intersectTriangle(Ps, Os, ks, !1, Ss))) || (a = e.ray.origin.distanceTo(Ss)) < e.near || a > e.far || t.push({
distance: a,
point: Ss.clone(),
uv: b.getUV(Ss, Ps, ks, Os, Ds, Ns, Is, new n()),
face: null,
object: this
});
},
copy: function(e) {
return p.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), 
this.material = e.material, this;
}
});
var Rs, js, Us, Bs, zs, Fs = new l(), Gs = new l();
Lt.prototype = Object.assign(Object.create(p.prototype), {
constructor: Lt,
isLOD: !0,
copy: function(e) {
p.prototype.copy.call(this, e, !1);
for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
var i = t[n];
this.addLevel(i.object.clone(), i.distance);
}
return this.autoUpdate = e.autoUpdate, this;
},
addLevel: function(e, t) {
void 0 === t && (t = 0), t = Math.abs(t);
var n, r = this.levels;
for (n = 0; n < r.length && !(t < r[n].distance); n++) ;
return r.splice(n, 0, {
distance: t,
object: e
}), this.add(e), this;
},
getCurrentLevel: function() {
return this._currentLevel;
},
getObjectForDistance: function(e) {
var t = this.levels;
if (0 < t.length) {
var n, r = 1;
for (n = t.length; r < n && !(e < t[r].distance); r++) ;
return t[r - 1].object;
}
return null;
},
raycast: function(e, t) {
if (0 < this.levels.length) {
Fs.setFromMatrixPosition(this.matrixWorld);
var n = e.ray.origin.distanceTo(Fs);
this.getObjectForDistance(n).raycast(e, t);
}
},
update: function(e) {
var t = this.levels;
if (1 < t.length) {
var n;
Fs.setFromMatrixPosition(e.matrixWorld), Gs.setFromMatrixPosition(this.matrixWorld), 
e = Fs.distanceTo(Gs) / e.zoom, t[0].object.visible = !0;
var r = 1;
for (n = t.length; r < n && e >= t[r].distance; r++) t[r - 1].object.visible = !1, 
t[r].object.visible = !0;
for (this._currentLevel = r - 1; r < n; r++) t[r].object.visible = !1;
}
},
toJSON: function(e) {
e = p.prototype.toJSON.call(this, e), !1 === this.autoUpdate && (e.object.autoUpdate = !1), 
e.object.levels = [];
for (var t = this.levels, n = 0, r = t.length; n < r; n++) {
var i = t[n];
e.object.levels.push({
object: i.object.uuid,
distance: i.distance
});
}
return e;
}
}), Ct.prototype = Object.assign(Object.create(z.prototype), {
constructor: Ct,
isSkinnedMesh: !0,
copy: function(e) {
return z.prototype.copy.call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), 
this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
},
bind: function(e, t) {
this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), 
t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t);
},
pose: function() {
this.skeleton.pose();
},
normalizeSkinWeights: function() {
for (var e = new a(), t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
var i = 1 / e.manhattanLength();
1 / 0 !== i ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
}
},
updateMatrixWorld: function(e) {
z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("$3.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
},
boneTransform: (Rs = new l(), js = new a(), Us = new a(), Bs = new l(), zs = new u(), 
function(e, t) {
var n = this.skeleton, r = this.geometry;
for (js.fromBufferAttribute(r.attributes.skinIndex, e), Us.fromBufferAttribute(r.attributes.skinWeight, e), 
Rs.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), 
t.set(0, 0, 0), e = 0; 4 > e; e++) if (0 !== (r = Us.getComponent(e))) {
var i = js.getComponent(e);
zs.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(Bs.copy(Rs).applyMatrix4(zs), r);
}
return t.applyMatrix4(this.bindMatrixInverse);
})
});
var Vs = new u(), Ws = new u();
Object.assign(Et.prototype, {
calculateInverses: function() {
this.boneInverses = [];
for (var e = 0, t = this.bones.length; e < t; e++) {
var n = new u();
this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n);
}
},
pose: function() {
for (var e = 0, t = this.bones.length; e < t; e++) {
var n = this.bones[e];
n && n.matrixWorld.getInverse(this.boneInverses[e]);
}
for (e = 0, t = this.bones.length; e < t; e++) (n = this.bones[e]) && (n.parent && n.parent.isBone ? (n.matrix.getInverse(n.parent.matrixWorld), 
n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
},
update: function() {
for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) Vs.multiplyMatrices(e[i] ? e[i].matrixWorld : Ws, t[i]), 
Vs.toArray(n, 16 * i);
void 0 !== r && (r.needsUpdate = !0);
},
clone: function() {
return new Et(this.bones, this.boneInverses);
},
getBoneByName: function(e) {
for (var t = 0, n = this.bones.length; t < n; t++) {
var r = this.bones[t];
if (r.name === e) return r;
}
},
dispose: function() {
this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
}
}), Pt.prototype = Object.assign(Object.create(p.prototype), {
constructor: Pt,
isBone: !0
});
var qs = new u(), Hs = new u(), Xs = [], Ys = new z();
kt.prototype = Object.assign(Object.create(z.prototype), {
constructor: kt,
isInstancedMesh: !0,
copy: function(e) {
return z.prototype.copy.call(this, e), this.instanceMatrix.copy(e.instanceMatrix), 
this.count = e.count, this;
},
getMatrixAt: function(e, t) {
t.fromArray(this.instanceMatrix.array, 16 * e);
},
raycast: function(e, t) {
var n = this.matrixWorld, r = this.count;
if (Ys.geometry = this.geometry, Ys.material = this.material, void 0 !== Ys.material) for (var i = 0; i < r; i++) {
this.getMatrixAt(i, qs), Hs.multiplyMatrices(n, qs), Ys.matrixWorld = Hs, Ys.raycast(e, Xs);
for (var a = 0, o = Xs.length; a < o; a++) {
var s = Xs[a];
s.instanceId = i, s.object = this, t.push(s);
}
Xs.length = 0;
}
},
setMatrixAt: function(e, t) {
t.toArray(this.instanceMatrix.array, 16 * e);
},
updateMorphTargets: function() {}
}), Ot.prototype = Object.create(A.prototype), Ot.prototype.constructor = Ot, Ot.prototype.isLineBasicMtrl = !0, 
Ot.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, 
this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, 
this;
};
var Js = new l(), Zs = new l(), Ks = new u(), Qs = new y(), ec = new v();
Dt.prototype = Object.assign(Object.create(p.prototype), {
constructor: Dt,
isLine: !0,
copy: function(e) {
return p.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, 
this;
},
computeLineDistances: function() {
var e = this.geometry;
if (e.isBufferGmtr) if (null === e.index) {
for (var t = e.attributes.position, n = [ 0 ], r = 1, i = t.count; r < i; r++) Js.fromBufferAttribute(t, r - 1), 
Zs.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += Js.distanceTo(Zs);
e.setAttribute("lineDistance", new I(n, 1));
} else console.warn("$3.Line.computeLineDistances(): Computation only possible with non-indexed BufferGmtr."); else if (e.isGmtr) for (t = e.vertices, 
(e = e.lineDistances)[0] = 0, n = 1, r = t.length; n < r; n++) e[n] = e[n - 1], 
e[n] += t[n - 1].distanceTo(t[n]);
return this;
},
raycast: function(e, t) {
var n = this.geometry, r = this.matrixWorld, i = e.params.Line.threshold;
if (null === n.boundingSphere && n.computeBoundingSphere(), ec.copy(n.boundingSphere), 
ec.applyMatrix4(r), ec.radius += i, !1 !== e.ray.intersectsSphere(ec)) {
Ks.getInverse(r), Qs.copy(e.ray).applyMatrix4(Ks), r = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), 
r *= r;
var a = new l(), o = new l();
i = new l();
var s = new l(), c = this && this.isLineSegments ? 2 : 1;
if (n.isBufferGmtr) {
var u = n.index;
if (n = n.attributes.position.array, null !== u) for (var h = 0, d = (u = u.array).length - 1; h < d; h += c) {
var p = u[h + 1];
a.fromArray(n, 3 * u[h]), o.fromArray(n, 3 * p), Qs.distanceSqToSegment(a, o, s, i) > r || (s.applyMatrix4(this.matrixWorld), 
(p = e.ray.origin.distanceTo(s)) < e.near || p > e.far || t.push({
distance: p,
point: i.clone().applyMatrix4(this.matrixWorld),
index: h,
face: null,
faceIndex: null,
object: this
}));
} else for (u = 0, h = n.length / 3 - 1; u < h; u += c) a.fromArray(n, 3 * u), o.fromArray(n, 3 * u + 3), 
Qs.distanceSqToSegment(a, o, s, i) > r || (s.applyMatrix4(this.matrixWorld), (d = e.ray.origin.distanceTo(s)) < e.near || d > e.far || t.push({
distance: d,
point: i.clone().applyMatrix4(this.matrixWorld),
index: u,
face: null,
faceIndex: null,
object: this
}));
} else if (n.isGmtr) for (o = (a = n.vertices).length, n = 0; n < o - 1; n += c) Qs.distanceSqToSegment(a[n], a[n + 1], s, i) > r || (s.applyMatrix4(this.matrixWorld), 
(u = e.ray.origin.distanceTo(s)) < e.near || u > e.far || t.push({
distance: u,
point: i.clone().applyMatrix4(this.matrixWorld),
index: n,
face: null,
faceIndex: null,
object: this
}));
}
},
updateMorphTargets: function() {
var e = this.geometry;
if (e.isBufferGmtr) {
e = e.morphAttributes;
var t = Object.keys(e);
if (0 < t.length && void 0 !== (e = e[t[0]])) {
this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0;
for (var n = e.length; t < n; t++) {
var r = e[t].name || String(t);
this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = t;
}
}
} else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("$3.Line.updateMorphTargets() does not support $3.Gmtr. Use $3.BufferGmtr instead.");
}
});
var tc = new l(), nc = new l();
Nt.prototype = Object.assign(Object.create(Dt.prototype), {
constructor: Nt,
isLineSegments: !0,
computeLineDistances: function() {
var e = this.geometry;
if (e.isBufferGmtr) if (null === e.index) {
for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) tc.fromBufferAttribute(t, r), 
nc.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + tc.distanceTo(nc);
e.setAttribute("lineDistance", new I(n, 1));
} else console.warn("$3.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGmtr."); else if (e.isGmtr) for (t = e.vertices, 
e = e.lineDistances, n = 0, r = t.length; n < r; n += 2) tc.copy(t[n]), nc.copy(t[n + 1]), 
e[n] = 0 === n ? 0 : e[n - 1], e[n + 1] = e[n] + tc.distanceTo(nc);
return this;
}
}), It.prototype = Object.assign(Object.create(Dt.prototype), {
constructor: It,
isLineLoop: !0
}), Rt.prototype = Object.create(A.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isPointsMtrl = !0, 
Rt.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, 
this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, 
this.morphTargets = e.morphTargets, this;
};
var rc = new u(), ic = new y(), ac = new v(), oc = new l();
jt.prototype = Object.assign(Object.create(p.prototype), {
constructor: jt,
isPoints: !0,
copy: function(e) {
return p.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, 
this;
},
raycast: function(e, t) {
var n = this.geometry, r = this.matrixWorld, i = e.params.Points.threshold;
if (null === n.boundingSphere && n.computeBoundingSphere(), ac.copy(n.boundingSphere), 
ac.applyMatrix4(r), ac.radius += i, !1 !== e.ray.intersectsSphere(ac)) if (rc.getInverse(r), 
ic.copy(e.ray).applyMatrix4(rc), i /= (this.scale.x + this.scale.y + this.scale.z) / 3, 
i *= i, n.isBufferGmtr) {
var a = n.index;
if (n = n.attributes.position.array, null !== a) for (var o = 0, s = (a = a.array).length; o < s; o++) {
var c = a[o];
oc.fromArray(n, 3 * c), Ut(oc, c, i, r, e, t, this);
} else for (a = 0, o = n.length / 3; a < o; a++) oc.fromArray(n, 3 * a), Ut(oc, a, i, r, e, t, this);
} else for (a = 0, o = (n = n.vertices).length; a < o; a++) Ut(n[a], a, i, r, e, t, this);
},
updateMorphTargets: function() {
var e = this.geometry;
if (e.isBufferGmtr) {
e = e.morphAttributes;
var t = Object.keys(e);
if (0 < t.length && void 0 !== (e = e[t[0]])) {
this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0;
for (var n = e.length; t < n; t++) {
var r = e[t].name || String(t);
this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = t;
}
}
} else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("$3.Points.updateMorphTargets() does not support $3.Gmtr. Use $3.BufferGmtr instead.");
}
}), Bt.prototype = Object.assign(Object.create(i.prototype), {
constructor: Bt,
isVideoTexture: !0,
update: function() {
var e = this.image;
e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
}
}), zt.prototype = Object.create(i.prototype), zt.prototype.constructor = zt, zt.prototype.isCompressedTexture = !0, 
Ft.prototype = Object.create(i.prototype), Ft.prototype.constructor = Ft, Ft.prototype.isCanvasTexture = !0, 
Gt.prototype = Object.create(i.prototype), Gt.prototype.constructor = Gt, Gt.prototype.isDepthTexture = !0, 
Vt.prototype = Object.create(B.prototype), Vt.prototype.constructor = Vt, Wt.prototype = Object.create(V.prototype), 
Wt.prototype.constructor = Wt, qt.prototype = Object.create(B.prototype), qt.prototype.constructor = qt, 
Ht.prototype = Object.create(V.prototype), Ht.prototype.constructor = Ht, Xt.prototype = Object.create(B.prototype), 
Xt.prototype.constructor = Xt, Yt.prototype = Object.create(V.prototype), Yt.prototype.constructor = Yt, 
Jt.prototype = Object.create(Xt.prototype), Jt.prototype.constructor = Jt, Zt.prototype = Object.create(V.prototype), 
Zt.prototype.constructor = Zt, Kt.prototype = Object.create(Xt.prototype), Kt.prototype.constructor = Kt, 
Qt.prototype = Object.create(V.prototype), Qt.prototype.constructor = Qt, en.prototype = Object.create(Xt.prototype), 
en.prototype.constructor = en, tn.prototype = Object.create(V.prototype), tn.prototype.constructor = tn, 
nn.prototype = Object.create(Xt.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(V.prototype), 
rn.prototype.constructor = rn, an.prototype = Object.create(B.prototype), an.prototype.constructor = an, 
an.prototype.toJSON = function() {
var e = B.prototype.toJSON.call(this);
return e.path = this.parameters.path.toJSON(), e;
}, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, sn.prototype = Object.create(B.prototype), 
sn.prototype.constructor = sn, cn.prototype = Object.create(V.prototype), cn.prototype.constructor = cn, 
ln.prototype = Object.create(B.prototype), ln.prototype.constructor = ln;
var sc = function(e, t, n) {
n = n || 2;
var r, i = t && t.length, a = i ? t[0] * n : e.length, o = un(e, 0, a, n, !0), s = [];
if (!o || o.next === o.prev) return s;
if (i) {
var c, l = n;
i = [];
var u = 0;
for (c = t.length; u < c; u++) {
var h = t[u] * l;
(h = un(e, h, u < c - 1 ? t[u + 1] * l : e.length, l, !1)) === h.next && (h.steiner = !0), 
i.push(gn(h));
}
for (i.sort(pn), u = 0; u < i.length; u++) (t = fn(l = i[u], t = o)) && (l = Mn(t, l), 
hn(t, t.next), hn(l, l.next)), o = hn(o, o.next);
}
if (e.length > 80 * n) {
var d = r = e[0], p = i = e[1];
for (l = n; l < a; l += n) (u = e[l]) < d && (d = u), (t = e[l + 1]) < p && (p = t), 
u > r && (r = u), t > i && (i = t);
r = 0 !== (r = Math.max(r - d, i - p)) ? 1 / r : 0;
}
return function e(t, n, r, i, a, o, s) {
if (t) {
if (!s && o) {
var c = t, l = c;
do {
null === l.z && (l.z = mn(l.x, l.y, i, a, o)), l.prevZ = l.prev, l = l.nextZ = l.next;
} while (l !== c);
l.prevZ.nextZ = null, l.prevZ = null, c = l;
var u, h, d, p, f = 1;
do {
l = c;
var m = c = null;
for (h = 0; l; ) {
h++;
var g = l;
for (u = d = 0; u < f && (d++, g = g.nextZ); u++) ;
for (p = f; 0 < d || 0 < p && g; ) 0 !== d && (0 === p || !g || l.z <= g.z) ? (u = l, 
l = l.nextZ, d--) : (u = g, g = g.nextZ, p--), m ? m.nextZ = u : c = u, u.prevZ = m, 
m = u;
l = g;
}
m.nextZ = null, f *= 2;
} while (1 < h);
}
for (c = t; t.prev !== t.next; ) {
if (l = t.prev, g = t.next, o) m = dn(t, i, a, o); else e: if (m = t, h = m.prev, 
d = m, f = m.next, 0 <= yn(h, d, f)) m = !1; else {
for (u = m.next.next; u !== m.prev; ) {
if (vn(h.x, h.y, d.x, d.y, f.x, f.y, u.x, u.y) && 0 <= yn(u.prev, u, u.next)) {
m = !1;
break e;
}
u = u.next;
}
m = !0;
}
if (m) n.push(l.i / r), n.push(t.i / r), n.push(g.i / r), An(t), c = t = g.next; else if ((t = g) === c) {
if (s) {
if (1 === s) {
s = n, c = r, l = t = hn(t);
do {
!$n(g = l.prev, m = l.next.next) && bn(g, l, l.next, m) && _n(g, m) && _n(m, g) && (s.push(g.i / c), 
s.push(l.i / c), s.push(m.i / c), An(l), An(l.next), l = t = m), l = l.next;
} while (l !== t);
e(t = hn(l), n, r, i, a, o, 2);
} else if (2 === s) e: {
s = t;
do {
for (c = s.next.next; c !== s.prev; ) {
if (l = s.i !== c.i) {
if (g = c, m = (l = s).next.i !== g.i && l.prev.i !== g.i) {
t: {
m = l;
do {
if (m.i !== l.i && m.next.i !== l.i && m.i !== g.i && m.next.i !== g.i && bn(m, m.next, l, g)) {
m = !0;
break t;
}
m = m.next;
} while (m !== l);
m = !1;
}
m = !m;
}
if (m) {
if (m = _n(l, g) && _n(g, l)) {
m = l, h = !1, d = (l.x + g.x) / 2, f = (l.y + g.y) / 2;
do {
m.y > f != m.next.y > f && m.next.y !== m.y && d < (m.next.x - m.x) * (f - m.y) / (m.next.y - m.y) + m.x && (h = !h), 
m = m.next;
} while (m !== l);
m = h;
}
m = m && (yn(l.prev, l, g.prev) || yn(l, g.prev, g)) || $n(l, g) && 0 < yn(l.prev, l, l.next) && 0 < yn(g.prev, g, g.next);
}
l = m;
}
if (l) {
t = Mn(s, c), s = hn(s, s.next), t = hn(t, t.next), e(s, n, r, i, a, o), e(t, n, r, i, a, o);
break e;
}
c = c.next;
}
s = s.next;
} while (s !== t);
}
} else e(hn(t), n, r, i, a, o, 1);
break;
}
}
}
}(o, s, n, d, p, r), s;
}, cc = {
area: function(e) {
for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
return .5 * n;
},
isClockWise: function(e) {
return 0 > cc.area(e);
},
triangulateShape: function(e, t) {
var n = [], r = [], i = [];
Ln(e), Cn(n, e), e = e.length, t.forEach(Ln);
for (var a = 0; a < t.length; a++) r.push(e), e += t[a].length, Cn(n, t[a]);
for (t = sc(n, r), n = 0; n < t.length; n += 3) i.push(t.slice(n, n + 3));
return i;
}
};
En.prototype = Object.create(V.prototype), En.prototype.constructor = En, En.prototype.toJSON = function() {
var e = V.prototype.toJSON.call(this);
return kn(this.parameters.shapes, this.parameters.options, e);
}, Pn.prototype = Object.create(B.prototype), Pn.prototype.constructor = Pn, Pn.prototype.toJSON = function() {
var e = B.prototype.toJSON.call(this);
return kn(this.parameters.shapes, this.parameters.options, e);
};
var lc = {
generateTopUV: function(e, t, r, i, a) {
e = t[3 * i], i = t[3 * i + 1];
var o = t[3 * a];
return a = t[3 * a + 1], [ new n(t[3 * r], t[3 * r + 1]), new n(e, i), new n(o, a) ];
},
generateSideWallUV: function(e, t, r, i, a, o) {
e = t[3 * r];
var s = t[3 * r + 1];
r = t[3 * r + 2];
var c = t[3 * i], l = t[3 * i + 1];
i = t[3 * i + 2];
var u = t[3 * a], h = t[3 * a + 1];
a = t[3 * a + 2];
var d = t[3 * o], p = t[3 * o + 1];
return t = t[3 * o + 2], .01 > Math.abs(s - l) ? [ new n(e, 1 - r), new n(c, 1 - i), new n(u, 1 - a), new n(d, 1 - t) ] : [ new n(s, 1 - r), new n(l, 1 - i), new n(h, 1 - a), new n(p, 1 - t) ];
}
};
On.prototype = Object.create(V.prototype), On.prototype.constructor = On, Dn.prototype = Object.create(Pn.prototype), 
Dn.prototype.constructor = Dn, Nn.prototype = Object.create(V.prototype), Nn.prototype.constructor = Nn, 
In.prototype = Object.create(B.prototype), In.prototype.constructor = In, Rn.prototype = Object.create(V.prototype), 
Rn.prototype.constructor = Rn, jn.prototype = Object.create(B.prototype), jn.prototype.constructor = jn, 
Un.prototype = Object.create(V.prototype), Un.prototype.constructor = Un, Bn.prototype = Object.create(B.prototype), 
Bn.prototype.constructor = Bn, zn.prototype = Object.create(V.prototype), zn.prototype.constructor = zn, 
zn.prototype.toJSON = function() {
var e = V.prototype.toJSON.call(this);
return Gn(this.parameters.shapes, e);
}, Fn.prototype = Object.create(B.prototype), Fn.prototype.constructor = Fn, Fn.prototype.toJSON = function() {
var e = B.prototype.toJSON.call(this);
return Gn(this.parameters.shapes, e);
}, Vn.prototype = Object.create(B.prototype), Vn.prototype.constructor = Vn, Wn.prototype = Object.create(V.prototype), 
Wn.prototype.constructor = Wn, qn.prototype = Object.create(B.prototype), qn.prototype.constructor = qn, 
Hn.prototype = Object.create(Wn.prototype), Hn.prototype.constructor = Hn, Xn.prototype = Object.create(qn.prototype), 
Xn.prototype.constructor = Xn, Yn.prototype = Object.create(V.prototype), Yn.prototype.constructor = Yn, 
Jn.prototype = Object.create(B.prototype), Jn.prototype.constructor = Jn;
var uc = Object.freeze({
__proto__: null,
WireframeGmtr: Vt,
ParametricGmtr: Wt,
ParametricBufferGmtr: qt,
TetrahedronGmtr: Yt,
TetrahedronBufferGmtr: Jt,
OctahedronGmtr: Zt,
OctahedronBufferGmtr: Kt,
IcosahedronGmtr: Qt,
IcosahedronBufferGmtr: en,
DodecahedronGmtr: tn,
DodecahedronBufferGmtr: nn,
PolyhedronGmtr: Ht,
PolyhedronBufferGmtr: Xt,
TubeGmtr: rn,
TubeBufferGmtr: an,
TorusKnotGmtr: on,
TorusKnotBufferGmtr: sn,
TorusGmtr: cn,
TorusBufferGmtr: ln,
TextGmtr: On,
TextBufferGmtr: Dn,
SphereGmtr: Nn,
SphereBufferGmtr: In,
RingGmtr: Rn,
RingBufferGmtr: jn,
PlaneGmtr: ne,
PlaneBufferGmtr: re,
LatheGmtr: Un,
LatheBufferGmtr: Bn,
ShapeGmtr: zn,
ShapeBufferGmtr: Fn,
ExtrudeGmtr: En,
ExtrudeBufferGmtr: Pn,
EdgesGmtr: Vn,
ConeGmtr: Hn,
ConeBufferGmtr: Xn,
CylinderGmtr: Wn,
CylinderBufferGmtr: qn,
CircleGmtr: Yn,
CircleBufferGmtr: Jn,
BoxGmtr: es,
BoxBufferGmtr: ts
});
Zn.prototype = Object.create(A.prototype), Zn.prototype.constructor = Zn, Zn.prototype.isShadowMtrl = !0, 
Zn.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this;
}, Kn.prototype = Object.create(H.prototype), Kn.prototype.constructor = Kn, Kn.prototype.isRawShaderMtrl = !0, 
Qn.prototype = Object.create(A.prototype), Qn.prototype.constructor = Qn, Qn.prototype.isMeshStandardMtrl = !0, 
Qn.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.defines = {
STANDARD: ""
}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, 
this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, 
this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), 
this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, 
this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, 
this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, 
this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, 
this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, 
this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, 
this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, 
this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, 
this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this;
}, er.prototype = Object.create(Qn.prototype), er.prototype.constructor = er, er.prototype.isMeshPhysicalMtrl = !0, 
er.prototype.copy = function(e) {
return Qn.prototype.copy.call(this, e), this.defines = {
STANDARD: "",
PHYSICAL: ""
}, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, 
this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, 
this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, 
this.sheen = e.sheen ? (this.sheen || new x()).copy(e.sheen) : null, this.transparency = e.transparency, 
this;
}, tr.prototype = Object.create(A.prototype), tr.prototype.constructor = tr, tr.prototype.isMeshPhongMtrl = !0, 
tr.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), 
this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, 
this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), 
this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, 
this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, 
this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, 
this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, 
this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, 
this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, 
this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, 
this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, 
this.morphNormals = e.morphNormals, this;
}, nr.prototype = Object.create(A.prototype), nr.prototype.constructor = nr, nr.prototype.isMeshToonMtrl = !0, 
nr.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), 
this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, 
this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, 
this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, 
this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, 
this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), 
this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, 
this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, 
this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, 
this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, 
this.morphNormals = e.morphNormals, this;
}, rr.prototype = Object.create(A.prototype), rr.prototype.constructor = rr, rr.prototype.isMeshNormalMtrl = !0, 
rr.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, 
this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), 
this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, 
this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, 
this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, 
this;
}, ir.prototype = Object.create(A.prototype), ir.prototype.constructor = ir, ir.prototype.isMeshLambertMtrl = !0, 
ir.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, 
this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, 
this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, 
this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, 
this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, 
this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, 
this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, 
this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, 
this;
}, ar.prototype = Object.create(A.prototype), ar.prototype.constructor = ar, ar.prototype.isMeshMatcapMtrl = !0, 
ar.prototype.copy = function(e) {
return A.prototype.copy.call(this, e), this.defines = {
MATCAP: ""
}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, 
this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, 
this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, 
this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, 
this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, 
this.morphNormals = e.morphNormals, this;
}, or.prototype = Object.create(Ot.prototype), or.prototype.constructor = or, or.prototype.isLineDashedMtrl = !0, 
or.prototype.copy = function(e) {
return Ot.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, 
this.gapSize = e.gapSize, this;
};
var hc = Object.freeze({
__proto__: null,
ShadowMtrl: Zn,
SpriteMtrl: St,
RawShaderMtrl: Kn,
ShaderMtrl: H,
PointsMtrl: Rt,
MeshPhysicalMtrl: er,
MeshStandardMtrl: Qn,
MeshPhongMtrl: tr,
MeshToonMtrl: nr,
MeshNormalMtrl: rr,
MeshLambertMtrl: ir,
MeshDepthMtrl: dt,
MeshDistanceMtrl: pt,
MeshBasicMtrl: T,
MeshMatcapMtrl: ar,
LineDashedMtrl: or,
LineBasicMtrl: Ot,
Mtrl: A
}), dc = {
arraySlice: function(e, t, n) {
return dc.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n);
},
convertArray: function(e, t, n) {
return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e);
},
isTypedArray: function(e) {
return ArrayBuffer.isView(e) && !(e instanceof DataView);
},
getKeyframeOrder: function(e) {
for (var t = e.length, n = Array(t), r = 0; r !== t; ++r) n[r] = r;
return n.sort(function(t, n) {
return e[t] - e[n];
}), n;
},
sortedArray: function(e, t, n) {
for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a) for (var s = n[a] * t, c = 0; c !== t; ++c) i[o++] = e[s + c];
return i;
},
flattenJSON: function(e, t, n, r) {
for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r]; ) a = e[i++];
if (void 0 !== a) {
var o = a[r];
if (void 0 !== o) if (Array.isArray(o)) do {
void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), a = e[i++];
} while (void 0 !== a); else if (void 0 !== o.toArray) do {
void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), a = e[i++];
} while (void 0 !== a); else do {
void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), a = e[i++];
} while (void 0 !== a);
}
},
subclip: function(e, t, n, r, i) {
i = i || 30, (e = e.clone()).name = t, t = [];
for (var a = 0; a < e.tracks.length; ++a) {
for (var o = e.tracks[a], s = o.getValueSize(), c = [], l = [], u = 0; u < o.times.length; ++u) {
var h = o.times[u] * i;
if (!(h < n || h >= r)) for (c.push(o.times[u]), h = 0; h < s; ++h) l.push(o.values[u * s + h]);
}
0 !== c.length && (o.times = dc.convertArray(c, o.times.constructor), o.values = dc.convertArray(l, o.values.constructor), 
t.push(o));
}
for (e.tracks = t, n = 1 / 0, r = 0; r < e.tracks.length; ++r) n > e.tracks[r].times[0] && (n = e.tracks[r].times[0]);
for (r = 0; r < e.tracks.length; ++r) e.tracks[r].shift(-1 * n);
return e.resetDuration(), e;
},
makeClipAdditive: function(e, t, n, r) {
void 0 === t && (t = 0), void 0 === n && (n = e), (void 0 === r || 0 >= r) && (r = 30);
var i = e.tracks.length, a = t / r;
for (t = function(t) {
var r = n.tracks[t], i = r.ValueTypeName;
if ("bool" !== i && "string" !== i && void 0 !== (t = e.tracks.find(function(e) {
return e.name === r.name && e.ValueTypeName === i;
}))) {
var o = r.getValueSize(), s = r.times.length - 1, l = void 0;
a <= r.times[0] ? l = dc.arraySlice(r.values, 0, r.valueSize) : a >= r.times[s] ? l = dc.arraySlice(r.values, s * o) : ((l = r.createInterpolant()).evaluate(a), 
l = l.resultBuffer), "quaternion" === i && new c(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l), 
s = t.times.length;
for (var u = 0; u < s; ++u) {
var h = u * o;
if ("quaternion" === i) c.multiplyQuaternionsFlat(t.values, h, l, 0, t.values, h); else for (var d = 0; d < o; ++d) t.values[h + d] -= l[d];
}
}
}, r = 0; r < i; ++r) t(r);
return e.blendMode = 2501, e;
}
};
Object.assign(sr.prototype, {
evaluate: function(e) {
var t = this.parameterPositions, n = this._cachedIndex, r = t[n], i = t[n - 1];
e: {
t: {
n: {
r: if (!(e < r)) {
for (var a = n + 2; ;) {
if (void 0 === r) {
if (e < i) break r;
return this._cachedIndex = n = t.length, this.afterEnd_(n - 1, e, i);
}
if (n === a) break;
if (i = r, e < (r = t[++n])) break t;
}
r = t.length;
break n;
}
if (e >= i) break e;
for (e < (a = t[1]) && (n = 2, i = a), a = n - 2; ;) {
if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
if (n === a) break;
if (r = i, e >= (i = t[--n - 1])) break t;
}
r = n, n = 0;
}
for (;n < r; ) e < t[i = n + r >>> 1] ? r = i : n = i + 1;
if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
if (void 0 === r) return this._cachedIndex = n = t.length, this.afterEnd_(n - 1, i, e);
}
this._cachedIndex = n, this.intervalChanged_(n, i, r);
}
return this.interpolate_(n, i, e, r);
},
settings: null,
DefaultSettings_: {},
getSettings_: function() {
return this.settings || this.DefaultSettings_;
},
copySampleValue_: function(e) {
var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize;
e *= r;
for (var i = 0; i !== r; ++i) t[i] = n[e + i];
return t;
},
interpolate_: function() {
throw Error("call to abstract method");
},
intervalChanged_: function() {}
}), Object.assign(sr.prototype, {
beforeStart_: sr.prototype.copySampleValue_,
afterEnd_: sr.prototype.copySampleValue_
}), cr.prototype = Object.assign(Object.create(sr.prototype), {
constructor: cr,
DefaultSettings_: {
endingStart: 2400,
endingEnd: 2400
},
intervalChanged_: function(e, t, n) {
var r = this.parameterPositions, i = e - 2, a = e + 1, o = r[i], s = r[a];
if (void 0 === o) switch (this.getSettings_().endingStart) {
case 2401:
i = e, o = 2 * t - n;
break;

case 2402:
o = t + r[i = r.length - 2] - r[i + 1];
break;

default:
i = e, o = n;
}
if (void 0 === s) switch (this.getSettings_().endingEnd) {
case 2401:
a = e, s = 2 * n - t;
break;

case 2402:
a = 1, s = n + r[1] - r[0];
break;

default:
a = e - 1, s = t;
}
e = .5 * (n - t), r = this.valueSize, this._weightPrev = e / (t - o), this._weightNext = e / (s - n), 
this._offsetPrev = i * r, this._offsetNext = a * r;
},
interpolate_: function(e, t, n, r) {
var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (e *= o) - o, c = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, h = this._weightNext, d = (n - t) / (r - t);
for (t = -u * (r = (n = d * d) * d) + 2 * u * n - u * d, u = (1 + u) * r + (-1.5 - 2 * u) * n + (-.5 + u) * d + 1, 
d = (-1 - h) * r + (1.5 + h) * n + .5 * d, h = h * r - h * n, n = 0; n !== o; ++n) i[n] = t * a[c + n] + u * a[s + n] + d * a[e + n] + h * a[l + n];
return i;
}
}), lr.prototype = Object.assign(Object.create(sr.prototype), {
constructor: lr,
interpolate_: function(e, t, n, r) {
var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (e *= o) - o;
for (n = 1 - (t = (n - t) / (r - t)), r = 0; r !== o; ++r) i[r] = a[s + r] * n + a[e + r] * t;
return i;
}
}), ur.prototype = Object.assign(Object.create(sr.prototype), {
constructor: ur,
interpolate_: function(e) {
return this.copySampleValue_(e - 1);
}
}), Object.assign(hr, {
toJSON: function(e) {
var t = e.constructor;
if (void 0 !== t.toJSON) t = t.toJSON(e); else {
t = {
name: e.name,
times: dc.convertArray(e.times, Array),
values: dc.convertArray(e.values, Array)
};
var n = e.getInterpolation();
n !== e.DefaultInterpolation && (t.interpolation = n);
}
return t.type = e.ValueTypeName, t;
}
}), Object.assign(hr.prototype, {
constructor: hr,
TimeBufferType: Float32Array,
ValueBufferType: Float32Array,
DefaultInterpolation: 2301,
InterpolantFactoryMethodDiscrete: function(e) {
return new ur(this.times, this.values, this.getValueSize(), e);
},
InterpolantFactoryMethodLinear: function(e) {
return new lr(this.times, this.values, this.getValueSize(), e);
},
InterpolantFactoryMethodSmooth: function(e) {
return new cr(this.times, this.values, this.getValueSize(), e);
},
setInterpolation: function(e) {
switch (e) {
case 2300:
var t = this.InterpolantFactoryMethodDiscrete;
break;

case 2301:
t = this.InterpolantFactoryMethodLinear;
break;

case 2302:
t = this.InterpolantFactoryMethodSmooth;
}
if (void 0 === t) {
if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, 
void 0 === this.createInterpolant) {
if (e === this.DefaultInterpolation) throw Error(t);
this.setInterpolation(this.DefaultInterpolation);
}
return console.warn("$3.KeyframeTrack:", t), this;
}
return this.createInterpolant = t, this;
},
getInterpolation: function() {
switch (this.createInterpolant) {
case this.InterpolantFactoryMethodDiscrete:
return 2300;

case this.InterpolantFactoryMethodLinear:
return 2301;

case this.InterpolantFactoryMethodSmooth:
return 2302;
}
},
getValueSize: function() {
return this.values.length / this.times.length;
},
shift: function(e) {
if (0 !== e) for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
return this;
},
scale: function(e) {
if (1 !== e) for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
return this;
},
trim: function(e, t) {
for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e; ) ++i;
for (;-1 !== a && n[a] > t; ) --a;
return ++a, 0 === i && a === r || (i >= a && (i = (a = Math.max(a, 1)) - 1), e = this.getValueSize(), 
this.times = dc.arraySlice(n, i, a), this.values = dc.arraySlice(this.values, i * e, a * e)), 
this;
},
validate: function() {
var e = !0, t = this.getValueSize();
0 != t - Math.floor(t) && (console.error("$3.KeyframeTrack: Invalid value size in track.", this), 
e = !1);
var n = this.times;
t = this.values;
var r = n.length;
0 === r && (console.error("$3.KeyframeTrack: Track is empty.", this), e = !1);
for (var i = null, a = 0; a !== r; a++) {
var o = n[a];
if ("number" == typeof o && isNaN(o)) {
console.error("$3.KeyframeTrack: Time is not a valid number.", this, a, o), e = !1;
break;
}
if (null !== i && i > o) {
console.error("$3.KeyframeTrack: Out of order keys.", this, a, o, i), e = !1;
break;
}
i = o;
}
if (void 0 !== t && dc.isTypedArray(t)) for (n = 0, r = t.length; n !== r; ++n) if (i = t[n], 
isNaN(i)) {
console.error("$3.KeyframeTrack: Value is not a valid number.", this, n, i), e = !1;
break;
}
return e;
},
optimize: function() {
for (var e = dc.arraySlice(this.times), t = dc.arraySlice(this.values), n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = e.length - 1, a = 1, o = 1; o < i; ++o) {
var s = !1, c = e[o];
if (c !== e[o + 1] && (1 !== o || c !== c[0])) if (r) s = !0; else for (var l = (c = o * n) - n, u = c + n, h = 0; h !== n; ++h) {
var d = t[c + h];
if (d !== t[l + h] || d !== t[u + h]) {
s = !0;
break;
}
}
if (s) {
if (o !== a) for (e[a] = e[o], s = o * n, c = a * n, l = 0; l !== n; ++l) t[c + l] = t[s + l];
++a;
}
}
if (0 < i) {
for (e[a] = e[i], r = i * n, i = a * n, o = 0; o !== n; ++o) t[i + o] = t[r + o];
++a;
}
return a !== e.length ? (this.times = dc.arraySlice(e, 0, a), this.values = dc.arraySlice(t, 0, a * n)) : (this.times = e, 
this.values = t), this;
},
clone: function() {
var e = dc.arraySlice(this.times, 0), t = dc.arraySlice(this.values, 0);
return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, 
e;
}
}), dr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: dr,
ValueTypeName: "bool",
ValueBufferType: Array,
DefaultInterpolation: 2300,
InterpolantFactoryMethodLinear: void 0,
InterpolantFactoryMethodSmooth: void 0
}), pr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: pr,
ValueTypeName: "color"
}), fr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: fr,
ValueTypeName: "number"
}), mr.prototype = Object.assign(Object.create(sr.prototype), {
constructor: mr,
interpolate_: function(e, t, n, r) {
var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize;
for (t = (n - t) / (r - t), n = (e *= o) + o; e !== n; e += 4) c.slerpFlat(i, 0, a, e - o, a, e, t);
return i;
}
}), gr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: gr,
ValueTypeName: "quaternion",
DefaultInterpolation: 2301,
InterpolantFactoryMethodLinear: function(e) {
return new mr(this.times, this.values, this.getValueSize(), e);
},
InterpolantFactoryMethodSmooth: void 0
}), vr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: vr,
ValueTypeName: "string",
ValueBufferType: Array,
DefaultInterpolation: 2300,
InterpolantFactoryMethodLinear: void 0,
InterpolantFactoryMethodSmooth: void 0
}), yr.prototype = Object.assign(Object.create(hr.prototype), {
constructor: yr,
ValueTypeName: "vector"
}), Object.assign($r, {
parse: function(e) {
for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push(br(n[i]).scale(r));
return new $r(e.name, e.duration, t, e.blendMode);
},
toJSON: function(e) {
var t = [], n = e.tracks;
e = {
name: e.name,
duration: e.duration,
tracks: t,
uuid: e.uuid,
blendMode: e.blendMode
};
for (var r = 0, i = n.length; r !== i; ++r) t.push(hr.toJSON(n[r]));
return e;
},
CreateFromMorphTargetSequence: function(e, t, n, r) {
for (var i = t.length, a = [], o = 0; o < i; o++) {
var s = [], c = [];
s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);
var l = dc.getKeyframeOrder(s);
s = dc.sortedArray(s, 1, l), c = dc.sortedArray(c, 1, l), r || 0 !== s[0] || (s.push(i), 
c.push(c[0])), a.push(new fr(".morphTargetInfluences[" + t[o].name + "]", s, c).scale(1 / n));
}
return new $r(e, -1, a);
},
findByName: function(e, t) {
var n = e;
for (Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations), 
e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
return null;
},
CreateClipsFromMorphTargetSequences: function(e, t, n) {
for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
var s = e[a], c = s.name.match(i);
if (c && 1 < c.length) {
var l = r[c = c[1]];
l || (r[c] = l = []), l.push(s);
}
}
for (var u in e = [], r) e.push($r.CreateFromMorphTargetSequence(u, r[u], t, n));
return e;
},
parseAnimation: function(e, t) {
if (!e) return console.error("$3.AnimationClip: No animation in JSONLoader data."), 
null;
var n = function(e, t, n, r, i) {
if (0 !== n.length) {
var a = [], o = [];
dc.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o));
}
}, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1;
e = e.hierarchy || [];
for (var c = 0; c < e.length; c++) {
var l = e[c].keys;
if (l && 0 !== l.length) if (l[0].morphTargets) {
s = {};
var u = void 0;
for (u = 0; u < l.length; u++) if (l[u].morphTargets) for (var h = 0; h < l[u].morphTargets.length; h++) s[l[u].morphTargets[h]] = -1;
for (var d in s) {
h = [];
for (var p = [], f = 0; f !== l[u].morphTargets.length; ++f) {
var m = l[u];
h.push(m.time), p.push(m.morphTarget === d ? 1 : 0);
}
r.push(new fr(".morphTargetInfluence[" + d + "]", h, p));
}
s = s.length * (a || 1);
} else n(yr, (u = ".bones[" + t[c].name + "]") + ".position", l, "pos", r), n(gr, u + ".quaternion", l, "rot", r), 
n(yr, u + ".scale", l, "scl", r);
}
return 0 === r.length ? null : new $r(i, s, r, o);
}
}), Object.assign($r.prototype, {
resetDuration: function() {
for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
var r = this.tracks[t];
e = Math.max(e, r.times[r.times.length - 1]);
}
return this.duration = e, this;
},
trim: function() {
for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
return this;
},
validate: function() {
for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
return e;
},
optimize: function() {
for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
return this;
},
clone: function() {
for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
return new $r(this.name, this.duration, e, this.blendMode);
}
});
var pc = {
enabled: !1,
files: {},
add: function(e, t) {
!1 !== this.enabled && (this.files[e] = t);
},
get: function(e) {
if (!1 !== this.enabled) return this.files[e];
},
remove: function(e) {
delete this.files[e];
},
clear: function() {
this.files = {};
}
}, fc = new xr();
Object.assign(wr.prototype, {
load: function() {},
loadAsync: function(e, t) {
var n = this;
return new Promise(function(r, i) {
n.load(e, r, t, i);
});
},
parse: function() {},
setCrossOrigin: function(e) {
return this.crossOrigin = e, this;
},
setPath: function(e) {
return this.path = e, this;
},
setResourcePath: function(e) {
return this.resourcePath = e, this;
},
setRequestHeader: function(e) {
return this.requestHeader = e, this;
}
});
var mc = {};
_r.prototype = Object.assign(Object.create(wr.prototype), {
constructor: _r,
load: function(e, t, n, r) {
void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
var i = this, a = pc.get(e);
if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
t && t(a), i.manager.itemEnd(e);
}, 0), a;
if (void 0 === mc[e]) {
var o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
if (o) {
n = o[1];
var s = !!o[2];
o = o[3], o = decodeURIComponent(o), s && (o = atob(o));
try {
var c = (this.responseType || "").toLowerCase();
switch (c) {
case "arraybuffer":
case "blob":
var l = new Uint8Array(o.length);
for (s = 0; s < o.length; s++) l[s] = o.charCodeAt(s);
var u = "blob" === c ? new Blob([ l.buffer ], {
type: n
}) : l.buffer;
break;

case "document":
u = new DOMParser().parseFromString(o, n);
break;

case "json":
u = JSON.parse(o);
break;

default:
u = o;
}
setTimeout(function() {
t && t(u), i.manager.itemEnd(e);
}, 0);
} catch (t) {
setTimeout(function() {
r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
}, 0);
}
} else {
mc[e] = [], mc[e].push({
onLoad: t,
onProgress: n,
onError: r
});
var h = new XMLHttpRequest();
for (s in h.open("GET", e, !0), h.addEventListener("load", function(t) {
var n = this.response, r = mc[e];
if (delete mc[e], 200 === this.status || 0 === this.status) {
0 === this.status && console.warn("$3.FileLoader: HTTP Status 0 received."), pc.add(e, n), 
t = 0;
for (var a = r.length; t < a; t++) {
var o = r[t];
o.onLoad && o.onLoad(n);
}
} else {
for (n = 0, a = r.length; n < a; n++) (o = r[n]).onError && o.onError(t);
i.manager.itemError(e);
}
i.manager.itemEnd(e);
}, !1), h.addEventListener("progress", function(t) {
for (var n = mc[e], r = 0, i = n.length; r < i; r++) {
var a = n[r];
a.onProgress && a.onProgress(t);
}
}, !1), h.addEventListener("error", function(t) {
var n = mc[e];
delete mc[e];
for (var r = 0, a = n.length; r < a; r++) {
var o = n[r];
o.onError && o.onError(t);
}
i.manager.itemError(e), i.manager.itemEnd(e);
}, !1), h.addEventListener("abort", function(t) {
var n = mc[e];
delete mc[e];
for (var r = 0, a = n.length; r < a; r++) {
var o = n[r];
o.onError && o.onError(t);
}
i.manager.itemError(e), i.manager.itemEnd(e);
}, !1), void 0 !== this.responseType && (h.responseType = this.responseType), void 0 !== this.withCredentials && (h.withCredentials = this.withCredentials), 
h.overrideMimeType && h.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), 
this.requestHeader) h.setRequestHeader(s, this.requestHeader[s]);
h.send(null);
}
return i.manager.itemStart(e), h;
}
mc[e].push({
onLoad: t,
onProgress: n,
onError: r
});
},
setResponseType: function(e) {
return this.responseType = e, this;
},
setWithCredentials: function(e) {
return this.withCredentials = e, this;
},
setMimeType: function(e) {
return this.mimeType = e, this;
}
}), Mr.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Mr,
load: function(e, t, n, r) {
var i = this, a = new _r(i.manager);
a.setPath(i.path), a.load(e, function(n) {
try {
t(i.parse(JSON.parse(n)));
} catch (t) {
r ? r(t) : console.error(t), i.manager.itemError(e);
}
}, n, r);
},
parse: function(e) {
for (var t = [], n = 0; n < e.length; n++) {
var r = $r.parse(e[n]);
t.push(r);
}
return t;
}
}), Sr.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Sr,
load: function(e, t, n, r) {
function i(i) {
c.load(e[i], function(e) {
e = a.parse(e, !0), o[i] = {
width: e.width,
height: e.height,
format: e.format,
mipmaps: e.mipmaps
}, 6 === (l += 1) && (1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, 
s.needsUpdate = !0, t && t(s));
}, n, r);
}
var a = this, o = [], s = new zt();
s.image = o;
var c = new _r(this.manager);
c.setPath(this.path), c.setResponseType("arraybuffer");
var l = 0;
if (Array.isArray(e)) for (var u = 0, h = e.length; u < h; ++u) i(u); else c.load(e, function(e) {
if ((e = a.parse(e, !0)).isCubemap) for (var n = e.mipmaps.length / e.mipmapCount, r = 0; r < n; r++) {
o[r] = {
mipmaps: []
};
for (var i = 0; i < e.mipmapCount; i++) o[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + i]), 
o[r].format = e.format, o[r].width = e.width, o[r].height = e.height;
} else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, 
t && t(s);
}, n, r);
return s;
}
}), Ar.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Ar,
load: function(e, t, n, r) {
var i = this, a = new K(), o = new _r(this.manager);
return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function(e) {
(e = i.parse(e)) && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, 
a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, 
a.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, a.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, 
a.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, 
void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), 
void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = 1008), 1 === e.mipmapCount && (a.minFilter = 1006), 
a.needsUpdate = !0, t && t(a, e));
}, n, r), a;
}
}), Tr.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Tr,
load: function(e, t, n, r) {
function i() {
c.removeEventListener("load", i, !1), c.removeEventListener("error", a, !1), pc.add(e, this), 
t && t(this), o.manager.itemEnd(e);
}
function a(t) {
c.removeEventListener("load", i, !1), c.removeEventListener("error", a, !1), r && r(t), 
o.manager.itemError(e), o.manager.itemEnd(e);
}
void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
var o = this, s = pc.get(e);
if (void 0 !== s) return o.manager.itemStart(e), setTimeout(function() {
t && t(s), o.manager.itemEnd(e);
}, 0), s;
var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
return c.addEventListener("load", i, !1), c.addEventListener("error", a, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), 
o.manager.itemStart(e), c.src = e, c;
}
}), Lr.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Lr,
load: function(e, t, n, r) {
function i(n) {
o.load(e[n], function(e) {
a.images[n] = e, 6 === ++s && (a.needsUpdate = !0, t && t(a));
}, void 0, r);
}
var a = new ce(), o = new Tr(this.manager);
o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
var s = 0;
for (n = 0; n < e.length; ++n) i(n);
return a;
}
}), Cr.prototype = Object.assign(Object.create(wr.prototype), {
constructor: Cr,
load: function(e, t, n, r) {
var a = new i(), o = new Tr(this.manager);
return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(n) {
a.image = n, n = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), 
a.format = n ? 1022 : 1023, a.needsUpdate = !0, void 0 !== t && t(a);
}, n, r), a;
}
}), Object.assign(Er.prototype, {
getPoint: function() {
return console.warn("$3.Curve: .getPoint() not implemented."), null;
},
getPointAt: function(e, t) {
return e = this.getUtoTmapping(e), this.getPoint(e, t);
},
getPoints: function(e) {
void 0 === e && (e = 5);
for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
return t;
},
getSpacedPoints: function(e) {
void 0 === e && (e = 5);
for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
return t;
},
getLength: function() {
var e = this.getLengths();
return e[e.length - 1];
},
getLengths: function(e) {
if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
this.needsUpdate = !1;
var t = [], n = this.getPoint(0), r = 0;
t.push(0);
for (var i = 1; i <= e; i++) {
var a = this.getPoint(i / e);
r += a.distanceTo(n), t.push(r), n = a;
}
return this.cacheArcLengths = t;
},
updateArcLengths: function() {
this.needsUpdate = !0, this.getLengths();
},
getUtoTmapping: function(e, t) {
var n = this.getLengths(), r = n.length;
t = t || e * n[r - 1];
for (var i, a = 0, o = r - 1; a <= o; ) if (0 > (i = n[e = Math.floor(a + (o - a) / 2)] - t)) a = e + 1; else {
if (!(0 < i)) {
o = e;
break;
}
o = e - 1;
}
return n[e = o] === t ? e / (r - 1) : (e + (t - (a = n[e])) / (n[e + 1] - a)) / (r - 1);
},
getTangent: function(e, t) {
var r = e - 1e-4;
return 0 > r && (r = 0), 1 < (e += 1e-4) && (e = 1), r = this.getPoint(r), e = this.getPoint(e), 
(t = t || (r.isVector2 ? new n() : new l())).copy(e).sub(r).normalize(), t;
},
getTangentAt: function(e, t) {
return e = this.getUtoTmapping(e), this.getTangent(e, t);
},
computeFrenetFrames: function(e, t) {
for (var n = new l(), r = [], i = [], a = [], o = new l(), s = new u(), c = 0; c <= e; c++) r[c] = this.getTangentAt(c / e, new l()), 
r[c].normalize();
i[0] = new l(), a[0] = new l(), c = Number.MAX_VALUE;
var h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z);
for (h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), 
o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]), 
n = 1; n <= e; n++) i[n] = i[n - 1].clone(), a[n] = a[n - 1].clone(), o.crossVectors(r[n - 1], r[n]), 
o.length() > Number.EPSILON && (o.normalize(), c = Math.acos(da.clamp(r[n - 1].dot(r[n]), -1, 1)), 
i[n].applyMatrix4(s.makeRotationAxis(o, c))), a[n].crossVectors(r[n], i[n]);
if (!0 === t) for (t = Math.acos(da.clamp(i[0].dot(i[e]), -1, 1)), t /= e, 0 < r[0].dot(o.crossVectors(i[0], i[e])) && (t = -t), 
o = 1; o <= e; o++) i[o].applyMatrix4(s.makeRotationAxis(r[o], t * o)), a[o].crossVectors(r[o], i[o]);
return {
tangents: r,
normals: i,
binormals: a
};
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.arcLengthDivisions = e.arcLengthDivisions, this;
},
toJSON: function() {
var e = {
metadata: {
version: 4.5,
type: "Curve",
generator: "Curve.toJSON"
}
};
return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
},
fromJSON: function(e) {
return this.arcLengthDivisions = e.arcLengthDivisions, this;
}
}), Pr.prototype = Object.create(Er.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isEllipseCurve = !0, 
Pr.prototype.getPoint = function(e, t) {
t = t || new n();
for (var r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; 0 > i; ) i += r;
for (;i > r; ) i -= r;
i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i = i === r ? -r : i - r), 
r = this.aStartAngle + e * i, e = this.aX + this.xRadius * Math.cos(r);
var o = this.aY + this.yRadius * Math.sin(r);
return 0 !== this.aRotation && (r = Math.cos(this.aRotation), i = Math.sin(this.aRotation), 
e = (a = e - this.aX) * r - (o -= this.aY) * i + this.aX, o = a * i + o * r + this.aY), 
t.set(e, o);
}, Pr.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, 
this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, 
this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
}, Pr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, 
e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, 
e.aRotation = this.aRotation, e;
}, Pr.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, 
this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, 
this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
}, kr.prototype = Object.create(Pr.prototype), kr.prototype.constructor = kr, kr.prototype.isArcCurve = !0;
var gc = new l(), vc = new Or(), yc = new Or(), $c = new Or();
Dr.prototype = Object.create(Er.prototype), Dr.prototype.constructor = Dr, Dr.prototype.isCatmullRomCurve3 = !0, 
Dr.prototype.getPoint = function(e, t) {
t = t || new l();
var n = this.points, r = n.length;
e *= r - (this.closed ? 0 : 1);
var i = Math.floor(e);
if (e -= i, this.closed ? i += 0 < i ? 0 : (Math.floor(Math.abs(i) / r) + 1) * r : 0 === e && i === r - 1 && (i = r - 2, 
e = 1), this.closed || 0 < i) var a = n[(i - 1) % r]; else gc.subVectors(n[0], n[1]).add(n[0]), 
a = gc;
var o = n[i % r], s = n[(i + 1) % r];
if (this.closed || i + 2 < r ? n = n[(i + 2) % r] : (gc.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), 
n = gc), "centripetal" === this.curveType || "chordal" === this.curveType) {
var c = "chordal" === this.curveType ? .5 : .25;
r = Math.pow(a.distanceToSquared(o), c), 1e-4 > (i = Math.pow(o.distanceToSquared(s), c)) && (i = 1), 
1e-4 > r && (r = i), 1e-4 > (c = Math.pow(s.distanceToSquared(n), c)) && (c = i), 
vc.initNonuniformCatmullRom(a.x, o.x, s.x, n.x, r, i, c), yc.initNonuniformCatmullRom(a.y, o.y, s.y, n.y, r, i, c), 
$c.initNonuniformCatmullRom(a.z, o.z, s.z, n.z, r, i, c);
} else "catmullrom" === this.curveType && (vc.initCatmullRom(a.x, o.x, s.x, n.x, this.tension), 
yc.initCatmullRom(a.y, o.y, s.y, n.y, this.tension), $c.initCatmullRom(a.z, o.z, s.z, n.z, this.tension));
return t.set(vc.calc(e), yc.calc(e), $c.calc(e)), t;
}, Dr.prototype.copy = function(e) {
Er.prototype.copy.call(this, e), this.points = [];
for (var t = 0, n = e.points.length; t < n; t++) this.points.push(e.points[t].clone());
return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, 
this;
}, Dr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
e.points = [];
for (var t = 0, n = this.points.length; t < n; t++) e.points.push(this.points[t].toArray());
return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, 
e;
}, Dr.prototype.fromJSON = function(e) {
Er.prototype.fromJSON.call(this, e), this.points = [];
for (var t = 0, n = e.points.length; t < n; t++) {
var r = e.points[t];
this.points.push(new l().fromArray(r));
}
return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, 
this;
}, jr.prototype = Object.create(Er.prototype), jr.prototype.constructor = jr, jr.prototype.isCubicBezierCurve = !0, 
jr.prototype.getPoint = function(e, t) {
t = t || new n();
var r = this.v0, i = this.v1, a = this.v2, o = this.v3;
return t.set(Rr(e, r.x, i.x, a.x, o.x), Rr(e, r.y, i.y, a.y, o.y)), t;
}, jr.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), 
this.v2.copy(e.v2), this.v3.copy(e.v3), this;
}, jr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), 
e.v3 = this.v3.toArray(), e;
}, jr.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), 
this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
}, Ur.prototype = Object.create(Er.prototype), Ur.prototype.constructor = Ur, Ur.prototype.isCubicBezierCurve3 = !0, 
Ur.prototype.getPoint = function(e, t) {
t = t || new l();
var n = this.v0, r = this.v1, i = this.v2, a = this.v3;
return t.set(Rr(e, n.x, r.x, i.x, a.x), Rr(e, n.y, r.y, i.y, a.y), Rr(e, n.z, r.z, i.z, a.z)), 
t;
}, Ur.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), 
this.v2.copy(e.v2), this.v3.copy(e.v3), this;
}, Ur.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), 
e.v3 = this.v3.toArray(), e;
}, Ur.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), 
this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
}, Br.prototype = Object.create(Er.prototype), Br.prototype.constructor = Br, Br.prototype.isLineCurve = !0, 
Br.prototype.getPoint = function(e, t) {
return t = t || new n(), 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), 
t.multiplyScalar(e).add(this.v1)), t;
}, Br.prototype.getPointAt = function(e, t) {
return this.getPoint(e, t);
}, Br.prototype.getTangent = function(e, t) {
return (e = t || new n()).copy(this.v2).sub(this.v1).normalize(), e;
}, Br.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), 
this;
}, Br.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
}, Br.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), 
this;
}, zr.prototype = Object.create(Er.prototype), zr.prototype.constructor = zr, zr.prototype.isLineCurve3 = !0, 
zr.prototype.getPoint = function(e, t) {
return t = t || new l(), 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), 
t.multiplyScalar(e).add(this.v1)), t;
}, zr.prototype.getPointAt = function(e, t) {
return this.getPoint(e, t);
}, zr.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), 
this;
}, zr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
}, zr.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), 
this;
}, Fr.prototype = Object.create(Er.prototype), Fr.prototype.constructor = Fr, Fr.prototype.isQuadraticBezierCurve = !0, 
Fr.prototype.getPoint = function(e, t) {
t = t || new n();
var r = this.v0, i = this.v1, a = this.v2;
return t.set(Ir(e, r.x, i.x, a.x), Ir(e, r.y, i.y, a.y)), t;
}, Fr.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), 
this.v2.copy(e.v2), this;
}, Fr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), 
e;
}, Fr.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), 
this.v2.fromArray(e.v2), this;
}, Gr.prototype = Object.create(Er.prototype), Gr.prototype.constructor = Gr, Gr.prototype.isQuadraticBezierCurve3 = !0, 
Gr.prototype.getPoint = function(e, t) {
t = t || new l();
var n = this.v0, r = this.v1, i = this.v2;
return t.set(Ir(e, n.x, r.x, i.x), Ir(e, n.y, r.y, i.y), Ir(e, n.z, r.z, i.z)), 
t;
}, Gr.prototype.copy = function(e) {
return Er.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), 
this.v2.copy(e.v2), this;
}, Gr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), 
e;
}, Gr.prototype.fromJSON = function(e) {
return Er.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), 
this.v2.fromArray(e.v2), this;
}, Vr.prototype = Object.create(Er.prototype), Vr.prototype.constructor = Vr, Vr.prototype.isSplineCurve = !0, 
Vr.prototype.getPoint = function(e, t) {
t = t || new n();
var r = this.points, i = (r.length - 1) * e;
i -= e = Math.floor(i);
var a = r[0 === e ? e : e - 1], o = r[e], s = r[e > r.length - 2 ? r.length - 1 : e + 1];
return r = r[e > r.length - 3 ? r.length - 1 : e + 2], t.set(Nr(i, a.x, o.x, s.x, r.x), Nr(i, a.y, o.y, s.y, r.y)), 
t;
}, Vr.prototype.copy = function(e) {
Er.prototype.copy.call(this, e), this.points = [];
for (var t = 0, n = e.points.length; t < n; t++) this.points.push(e.points[t].clone());
return this;
}, Vr.prototype.toJSON = function() {
var e = Er.prototype.toJSON.call(this);
e.points = [];
for (var t = 0, n = this.points.length; t < n; t++) e.points.push(this.points[t].toArray());
return e;
}, Vr.prototype.fromJSON = function(e) {
Er.prototype.fromJSON.call(this, e), this.points = [];
for (var t = 0, r = e.points.length; t < r; t++) {
var i = e.points[t];
this.points.push(new n().fromArray(i));
}
return this;
};
var bc = Object.freeze({
__proto__: null,
ArcCurve: kr,
CatmullRomCurve3: Dr,
CubicBezierCurve: jr,
CubicBezierCurve3: Ur,
EllipseCurve: Pr,
LineCurve: Br,
LineCurve3: zr,
QuadraticBezierCurve: Fr,
QuadraticBezierCurve3: Gr,
SplineCurve: Vr
});
Wr.prototype = Object.assign(Object.create(Er.prototype), {
constructor: Wr,
add: function(e) {
this.curves.push(e);
},
closePath: function() {
var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
e.equals(t) || this.curves.push(new Br(t, e));
},
getPoint: function(e) {
var t = e * this.getLength(), n = this.getCurveLengths();
for (e = 0; e < n.length; ) {
if (n[e] >= t) return t = n[e] - t, n = (e = this.curves[e]).getLength(), e.getPointAt(0 === n ? 0 : 1 - t / n);
e++;
}
return null;
},
getLength: function() {
var e = this.getCurveLengths();
return e[e.length - 1];
},
updateArcLengths: function() {
this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
},
getCurveLengths: function() {
if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), 
e.push(t);
return this.cacheLengths = e;
},
getSpacedPoints: function(e) {
void 0 === e && (e = 40);
for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
return this.autoClose && t.push(t[0]), t;
},
getPoints: function(e) {
e = e || 12;
for (var t, n = [], r = 0, i = this.curves; r < i.length; r++) {
var a = i[r];
a = a.getPoints(a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e);
for (var o = 0; o < a.length; o++) {
var s = a[o];
t && t.equals(s) || (n.push(s), t = s);
}
}
return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), 
n;
},
copy: function(e) {
Er.prototype.copy.call(this, e), this.curves = [];
for (var t = 0, n = e.curves.length; t < n; t++) this.curves.push(e.curves[t].clone());
return this.autoClose = e.autoClose, this;
},
toJSON: function() {
var e = Er.prototype.toJSON.call(this);
e.autoClose = this.autoClose, e.curves = [];
for (var t = 0, n = this.curves.length; t < n; t++) e.curves.push(this.curves[t].toJSON());
return e;
},
fromJSON: function(e) {
Er.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
for (var t = 0, n = e.curves.length; t < n; t++) {
var r = e.curves[t];
this.curves.push(new bc[r.type]().fromJSON(r));
}
return this;
}
}), qr.prototype = Object.assign(Object.create(Wr.prototype), {
constructor: qr,
setFromPoints: function(e) {
this.moveTo(e[0].x, e[0].y);
for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
return this;
},
moveTo: function(e, t) {
return this.currentPoint.set(e, t), this;
},
lineTo: function(e, t) {
var r = new Br(this.currentPoint.clone(), new n(e, t));
return this.curves.push(r), this.currentPoint.set(e, t), this;
},
quadraticCurveTo: function(e, t, r, i) {
return e = new Fr(this.currentPoint.clone(), new n(e, t), new n(r, i)), this.curves.push(e), 
this.currentPoint.set(r, i), this;
},
bezierCurveTo: function(e, t, r, i, a, o) {
return e = new jr(this.currentPoint.clone(), new n(e, t), new n(r, i), new n(a, o)), 
this.curves.push(e), this.currentPoint.set(a, o), this;
},
splineThru: function(e) {
var t = [ this.currentPoint.clone() ].concat(e);
return t = new Vr(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), 
this;
},
arc: function(e, t, n, r, i, a) {
return this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, n, r, i, a), 
this;
},
absarc: function(e, t, n, r, i, a) {
return this.absellipse(e, t, n, n, r, i, a), this;
},
ellipse: function(e, t, n, r, i, a, o, s) {
return this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, n, r, i, a, o, s), 
this;
},
absellipse: function(e, t, n, r, i, a, o, s) {
return e = new Pr(e, t, n, r, i, a, o, s), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), 
this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e), this;
},
copy: function(e) {
return Wr.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), 
this;
},
toJSON: function() {
var e = Wr.prototype.toJSON.call(this);
return e.currentPoint = this.currentPoint.toArray(), e;
},
fromJSON: function(e) {
return Wr.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), 
this;
}
}), Hr.prototype = Object.assign(Object.create(qr.prototype), {
constructor: Hr,
getPointsHoles: function(e) {
for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
return t;
},
extractPoints: function(e) {
return {
shape: this.getPoints(e),
holes: this.getPointsHoles(e)
};
},
copy: function(e) {
qr.prototype.copy.call(this, e), this.holes = [];
for (var t = 0, n = e.holes.length; t < n; t++) this.holes.push(e.holes[t].clone());
return this;
},
toJSON: function() {
var e = qr.prototype.toJSON.call(this);
e.uuid = this.uuid, e.holes = [];
for (var t = 0, n = this.holes.length; t < n; t++) e.holes.push(this.holes[t].toJSON());
return e;
},
fromJSON: function(e) {
qr.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
for (var t = 0, n = e.holes.length; t < n; t++) {
var r = e.holes[t];
this.holes.push(new qr().fromJSON(r));
}
return this;
}
}), Xr.prototype = Object.assign(Object.create(p.prototype), {
constructor: Xr,
isLight: !0,
copy: function(e) {
return p.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, 
this;
},
toJSON: function(e) {
return (e = p.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), 
e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), 
void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), 
void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), 
void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
}
}), Yr.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: Yr,
isHemisphereLight: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
}
}), Object.assign(Jr.prototype, {
_projScreenMatrix: new u(),
_lightPositionWorld: new l(),
_lookTarget: new l(),
getViewportCount: function() {
return this._viewportCount;
},
getFrustum: function() {
return this._frustum;
},
updateMatrices: function(e) {
var t = this.camera, n = this.matrix, r = this._projScreenMatrix, i = this._lookTarget, a = this._lightPositionWorld;
a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), i.setFromMatrixPosition(e.target.matrixWorld), 
t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), 
this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse);
},
getViewport: function(e) {
return this._viewports[e];
},
getFrameExtents: function() {
return this._frameExtents;
},
copy: function(e) {
return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, 
this.mapSize.copy(e.mapSize), this;
},
clone: function() {
return new this.constructor().copy(this);
},
toJSON: function() {
var e = {};
return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 
512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), 
e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
}
}), Zr.prototype = Object.assign(Object.create(Jr.prototype), {
constructor: Zr,
isSpotLightShadow: !0,
updateMatrices: function(e) {
var t = this.camera, n = 2 * da.RAD2DEG * e.angle, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far;
n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, 
t.updateProjectionMatrix()), Jr.prototype.updateMatrices.call(this, e);
}
}), Kr.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: Kr,
isSpotLight: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, 
this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), 
this.shadow = e.shadow.clone(), this;
}
}), Qr.prototype = Object.assign(Object.create(Jr.prototype), {
constructor: Qr,
isPointLightShadow: !0,
updateMatrices: function(e, t) {
void 0 === t && (t = 0);
var n = this.camera, r = this.matrix, i = this._lightPositionWorld, a = this._lookTarget, o = this._projScreenMatrix;
i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), a.copy(n.position), 
a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), 
r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), 
this._frustum.setFromProjectionMatrix(o);
}
}), ei.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: ei,
isPointLight: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, 
this.shadow = e.shadow.clone(), this;
}
}), ti.prototype = Object.assign(Object.create(X.prototype), {
constructor: ti,
isOrthographicCamera: !0,
copy: function(e, t) {
return X.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, 
this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, 
this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), 
this;
},
setViewOffset: function(e, t, n, r, i, a) {
null === this.view && (this.view = {
enabled: !0,
fullWidth: 1,
fullHeight: 1,
offsetX: 0,
offsetY: 0,
width: 1,
height: 1
}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, 
this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
},
clearViewOffset: function() {
null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
},
updateProjectionMatrix: function() {
var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, i = n - e;
n += e, e = r + t, t = r - t, null !== this.view && this.view.enabled && (r = (this.right - this.left) / this.view.fullWidth / this.zoom, 
t = (this.top - this.bottom) / this.view.fullHeight / this.zoom, n = (i += r * this.view.offsetX) + r * this.view.width, 
t = (e -= t * this.view.offsetY) - t * this.view.height), this.projectionMatrix.makeOrthographic(i, n, e, t, this.near, this.far), 
this.projectionMatrixInverse.getInverse(this.projectionMatrix);
},
toJSON: function(e) {
return (e = p.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, 
e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, 
e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), 
e;
}
}), ni.prototype = Object.assign(Object.create(Jr.prototype), {
constructor: ni,
isDirectionalLightShadow: !0,
updateMatrices: function(e) {
Jr.prototype.updateMatrices.call(this, e);
}
}), ri.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: ri,
isDirectionalLight: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), 
this;
}
}), ii.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: ii,
isAmbientLight: !0
}), ai.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: ai,
isRectAreaLight: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, 
this;
},
toJSON: function(e) {
return (e = Xr.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, 
e;
}
}), Object.assign(oi.prototype, {
isSphericalHarmonics3: !0,
set: function(e) {
for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]);
return this;
},
zero: function() {
for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0);
return this;
},
getAt: function(e, t) {
var n = e.x, r = e.y;
e = e.z;
var i = this.coefficients;
return t.copy(i[0]).multiplyScalar(.282095), t.addScaledVector(i[1], .488603 * r), 
t.addScaledVector(i[2], .488603 * e), t.addScaledVector(i[3], .488603 * n), t.addScaledVector(i[4], 1.092548 * n * r), 
t.addScaledVector(i[5], 1.092548 * r * e), t.addScaledVector(i[6], .315392 * (3 * e * e - 1)), 
t.addScaledVector(i[7], 1.092548 * n * e), t.addScaledVector(i[8], .546274 * (n * n - r * r)), 
t;
},
getIrradianceAt: function(e, t) {
var n = e.x, r = e.y;
e = e.z;
var i = this.coefficients;
return t.copy(i[0]).multiplyScalar(.886227), t.addScaledVector(i[1], 1.023328 * r), 
t.addScaledVector(i[2], 1.023328 * e), t.addScaledVector(i[3], 1.023328 * n), t.addScaledVector(i[4], .858086 * n * r), 
t.addScaledVector(i[5], .858086 * r * e), t.addScaledVector(i[6], .743125 * e * e - .247708), 
t.addScaledVector(i[7], .858086 * n * e), t.addScaledVector(i[8], .429043 * (n * n - r * r)), 
t;
},
add: function(e) {
for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]);
return this;
},
addScaledSH: function(e, t) {
for (var n = 0; 9 > n; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
return this;
},
scale: function(e) {
for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e);
return this;
},
lerp: function(e, t) {
for (var n = 0; 9 > n; n++) this.coefficients[n].lerp(e.coefficients[n], t);
return this;
},
equals: function(e) {
for (var t = 0; 9 > t; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
return !0;
},
copy: function(e) {
return this.set(e.coefficients);
},
clone: function() {
return new this.constructor().copy(this);
},
fromArray: function(e, t) {
void 0 === t && (t = 0);
for (var n = this.coefficients, r = 0; 9 > r; r++) n[r].fromArray(e, t + 3 * r);
return this;
},
toArray: function(e, t) {
void 0 === e && (e = []), void 0 === t && (t = 0);
for (var n = this.coefficients, r = 0; 9 > r; r++) n[r].toArray(e, t + 3 * r);
return e;
}
}), Object.assign(oi, {
getBasisAt: function(e, t) {
var n = e.x, r = e.y;
e = e.z, t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * e, t[3] = .488603 * n, 
t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * e, t[6] = .315392 * (3 * e * e - 1), 
t[7] = 1.092548 * n * e, t[8] = .546274 * (n * n - r * r);
}
}), si.prototype = Object.assign(Object.create(Xr.prototype), {
constructor: si,
isLightProbe: !0,
copy: function(e) {
return Xr.prototype.copy.call(this, e), this.sh.copy(e.sh), this;
},
fromJSON: function(e) {
return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
},
toJSON: function(e) {
return (e = Xr.prototype.toJSON.call(this, e)).object.sh = this.sh.toArray(), e;
}
}), ci.prototype = Object.assign(Object.create(wr.prototype), {
constructor: ci,
load: function(e, t, n, r) {
var i = this, a = new _r(i.manager);
a.setPath(i.path), a.load(e, function(n) {
try {
t(i.parse(JSON.parse(n)));
} catch (t) {
r ? r(t) : console.error(t), i.manager.itemError(e);
}
}, n, r);
},
parse: function(e) {
function t(e) {
return void 0 === i[e] && console.warn("$3.MtrlLoader: Undefined texture", e), i[e];
}
var i = this.textures, o = new hc[e.type]();
if (void 0 !== e.uuid && (o.uuid = e.uuid), void 0 !== e.name && (o.name = e.name), 
void 0 !== e.color && o.color.setHex(e.color), void 0 !== e.roughness && (o.roughness = e.roughness), 
void 0 !== e.metalness && (o.metalness = e.metalness), void 0 !== e.sheen && (o.sheen = new x().setHex(e.sheen)), 
void 0 !== e.emissive && o.emissive.setHex(e.emissive), void 0 !== e.specular && o.specular.setHex(e.specular), 
void 0 !== e.shininess && (o.shininess = e.shininess), void 0 !== e.clearcoat && (o.clearcoat = e.clearcoat), 
void 0 !== e.clearcoatRoughness && (o.clearcoatRoughness = e.clearcoatRoughness), 
void 0 !== e.fog && (o.fog = e.fog), void 0 !== e.flatShading && (o.flatShading = e.flatShading), 
void 0 !== e.blending && (o.blending = e.blending), void 0 !== e.combine && (o.combine = e.combine), 
void 0 !== e.side && (o.side = e.side), void 0 !== e.opacity && (o.opacity = e.opacity), 
void 0 !== e.transparent && (o.transparent = e.transparent), void 0 !== e.alphaTest && (o.alphaTest = e.alphaTest), 
void 0 !== e.depthTest && (o.depthTest = e.depthTest), void 0 !== e.depthWrite && (o.depthWrite = e.depthWrite), 
void 0 !== e.colorWrite && (o.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (o.stencilWrite = e.stencilWrite), 
void 0 !== e.stencilWriteMask && (o.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (o.stencilFunc = e.stencilFunc), 
void 0 !== e.stencilRef && (o.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (o.stencilFuncMask = e.stencilFuncMask), 
void 0 !== e.stencilFail && (o.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (o.stencilZFail = e.stencilZFail), 
void 0 !== e.stencilZPass && (o.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (o.wireframe = e.wireframe), 
void 0 !== e.wireframeLinewidth && (o.wireframeLinewidth = e.wireframeLinewidth), 
void 0 !== e.wireframeLinecap && (o.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (o.wireframeLinejoin = e.wireframeLinejoin), 
void 0 !== e.rotation && (o.rotation = e.rotation), 1 !== e.linewidth && (o.linewidth = e.linewidth), 
void 0 !== e.dashSize && (o.dashSize = e.dashSize), void 0 !== e.gapSize && (o.gapSize = e.gapSize), 
void 0 !== e.scale && (o.scale = e.scale), void 0 !== e.polygonOffset && (o.polygonOffset = e.polygonOffset), 
void 0 !== e.polygonOffsetFactor && (o.polygonOffsetFactor = e.polygonOffsetFactor), 
void 0 !== e.polygonOffsetUnits && (o.polygonOffsetUnits = e.polygonOffsetUnits), 
void 0 !== e.skinning && (o.skinning = e.skinning), void 0 !== e.morphTargets && (o.morphTargets = e.morphTargets), 
void 0 !== e.morphNormals && (o.morphNormals = e.morphNormals), void 0 !== e.dithering && (o.dithering = e.dithering), 
void 0 !== e.vertexTangents && (o.vertexTangents = e.vertexTangents), void 0 !== e.visible && (o.visible = e.visible), 
void 0 !== e.toneMapped && (o.toneMapped = e.toneMapped), void 0 !== e.userData && (o.userData = e.userData), 
void 0 !== e.vertexColors && (o.vertexColors = "number" == typeof e.vertexColors ? 0 < e.vertexColors : e.vertexColors), 
void 0 !== e.uniforms) for (var s in e.uniforms) {
var c = e.uniforms[s];
switch (o.uniforms[s] = {}, c.type) {
case "t":
o.uniforms[s].value = t(c.value);
break;

case "c":
o.uniforms[s].value = new x().setHex(c.value);
break;

case "v2":
o.uniforms[s].value = new n().fromArray(c.value);
break;

case "v3":
o.uniforms[s].value = new l().fromArray(c.value);
break;

case "v4":
o.uniforms[s].value = new a().fromArray(c.value);
break;

case "m3":
o.uniforms[s].value = new r().fromArray(c.value);

case "m4":
o.uniforms[s].value = new u().fromArray(c.value);
break;

default:
o.uniforms[s].value = c.value;
}
}
if (void 0 !== e.defines && (o.defines = e.defines), void 0 !== e.vertexShader && (o.vertexShader = e.vertexShader), 
void 0 !== e.fragmentShader && (o.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (var h in e.extensions) o.extensions[h] = e.extensions[h];
return void 0 !== e.shading && (o.flatShading = 1 === e.shading), void 0 !== e.size && (o.size = e.size), 
void 0 !== e.sizeAttenuation && (o.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (o.map = t(e.map)), 
void 0 !== e.matcap && (o.matcap = t(e.matcap)), void 0 !== e.alphaMap && (o.alphaMap = t(e.alphaMap)), 
void 0 !== e.bumpMap && (o.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (o.bumpScale = e.bumpScale), 
void 0 !== e.normalMap && (o.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (o.normalMapType = e.normalMapType), 
void 0 !== e.normalScale && (s = e.normalScale, !1 === Array.isArray(s) && (s = [ s, s ]), 
o.normalScale = new n().fromArray(s)), void 0 !== e.displacementMap && (o.displacementMap = t(e.displacementMap)), 
void 0 !== e.displacementScale && (o.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (o.displacementBias = e.displacementBias), 
void 0 !== e.roughnessMap && (o.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (o.metalnessMap = t(e.metalnessMap)), 
void 0 !== e.emissiveMap && (o.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (o.emissiveIntensity = e.emissiveIntensity), 
void 0 !== e.specularMap && (o.specularMap = t(e.specularMap)), void 0 !== e.envMap && (o.envMap = t(e.envMap)), 
void 0 !== e.envMapIntensity && (o.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (o.reflectivity = e.reflectivity), 
void 0 !== e.refractionRatio && (o.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (o.lightMap = t(e.lightMap)), 
void 0 !== e.lightMapIntensity && (o.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (o.aoMap = t(e.aoMap)), 
void 0 !== e.aoMapIntensity && (o.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (o.gradientMap = t(e.gradientMap)), 
void 0 !== e.clearcoatMap && (o.clearcoatMap = t(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (o.clearcoatRoughnessMap = t(e.clearcoatRoughnessMap)), 
void 0 !== e.clearcoatNormalMap && (o.clearcoatNormalMap = t(e.clearcoatNormalMap)), 
void 0 !== e.clearcoatNormalScale && (o.clearcoatNormalScale = new n().fromArray(e.clearcoatNormalScale)), 
o;
},
setTextures: function(e) {
return this.textures = e, this;
}
});
var xc = {
decodeText: function(e) {
if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
try {
return decodeURIComponent(escape(t));
} catch (e) {
return t;
}
},
extractUrlBase: function(e) {
var t = e.lastIndexOf("/");
return -1 === t ? "./" : e.substr(0, t + 1);
}
};
li.prototype = Object.assign(Object.create(B.prototype), {
constructor: li,
isInstancedBufferGmtr: !0,
copy: function(e) {
return B.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this;
},
clone: function() {
return new this.constructor().copy(this);
},
toJSON: function() {
var e = B.prototype.toJSON.call(this);
return e.instanceCount = this.instanceCount, e.isInstancedBufferGmtr = !0, e;
}
}), ui.prototype = Object.assign(Object.create(L.prototype), {
constructor: ui,
isInstancedBufferAttribute: !0,
copy: function(e) {
return L.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, 
this;
},
toJSON: function() {
var e = L.prototype.toJSON.call(this);
return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, 
e;
}
}), hi.prototype = Object.assign(Object.create(wr.prototype), {
constructor: hi,
load: function(e, t, n, r) {
var i = this, a = new _r(i.manager);
a.setPath(i.path), a.load(e, function(n) {
try {
t(i.parse(JSON.parse(n)));
} catch (t) {
r ? r(t) : console.error(t), i.manager.itemError(e);
}
}, n, r);
},
parse: function(e) {
function t(e, t) {
if (void 0 !== n[t]) return n[t];
var i = e.interleavedBuffers[t], a = i.buffer;
return void 0 !== r[a] ? a = r[a] : (e = new Uint32Array(e.arrayBuffers[a]).buffer, 
a = r[a] = e), (a = new _t(a = new wc[i.type](a), i.stride)).uuid = i.uuid, n[t] = a;
}
var n = {}, r = {}, i = e.isInstancedBufferGmtr ? new li() : new B(), a = e.data.index;
for (var o in void 0 !== a && (a = new wc[a.type](a.array), i.setIndex(new L(a, 1))), 
a = e.data.attributes) {
var s = a[o], c = void 0;
s.isInterleavedBufferAttribute ? c = new Mt(c = t(e.data, s.data), s.itemSize, s.offset, s.normalized) : (c = new wc[s.type](s.array), 
c = new (s.isInstancedBufferAttribute ? ui : L)(c, s.itemSize, s.normalized)), void 0 !== s.name && (c.name = s.name), 
i.setAttribute(o, c);
}
if (o = e.data.morphAttributes) for (var u in o) {
s = [], c = 0;
for (var h = (a = o[u]).length; c < h; c++) {
var d = a[c], p = void 0;
d.isInterleavedBufferAttribute ? p = new Mt(p = t(e.data, d.data), d.itemSize, d.offset, d.normalized) : p = new L(p = new wc[d.type](d.array), d.itemSize, d.normalized), 
void 0 !== d.name && (p.name = d.name), s.push(p);
}
i.morphAttributes[u] = s;
}
if (e.data.morphTargetsRelative && (i.morphTargetsRelative = !0), void 0 !== (u = e.data.groups || e.data.drawcalls || e.data.offsets)) for (o = 0, 
a = u.length; o !== a; ++o) s = u[o], i.addGroup(s.start, s.count, s.materialIndex);
return void 0 !== (u = e.data.boundingSphere) && (o = new l(), void 0 !== u.center && o.fromArray(u.center), 
i.boundingSphere = new v(o, u.radius)), e.name && (i.name = e.name), e.userData && (i.userData = e.userData), 
i;
}
});
var wc = {
Int8Array: Int8Array,
Uint8Array: Uint8Array,
Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
Int16Array: Int16Array,
Uint16Array: Uint16Array,
Int32Array: Int32Array,
Uint32Array: Uint32Array,
Float32Array: Float32Array,
Float64Array: Float64Array
};
di.prototype = Object.assign(Object.create(wr.prototype), {
constructor: di,
load: function(e, t, n, r) {
var i = this, a = "" === this.path ? xc.extractUrlBase(e) : this.path;
this.resourcePath = this.resourcePath || a, (a = new _r(i.manager)).setPath(this.path), 
a.load(e, function(n) {
var a = null;
try {
a = JSON.parse(n);
} catch (t) {
return void 0 !== r && r(t), void console.error("$3:ObjectLoader: Can't parse " + e + ".", t.message);
}
void 0 === (n = a.metadata) || void 0 === n.type || "geometry" === n.type.toLowerCase() ? console.error("$3.ObjectLoader: Can't load " + e) : i.parse(a, t);
}, n, r);
},
parse: function(e, t) {
var n = this.parseShape(e.shapes);
n = this.parseGeometries(e.geometries, n);
var r = this.parseImages(e.images, function() {
void 0 !== t && t(i);
});
r = this.parseTextures(e.textures, r), r = this.parseMtrls(e.materials, r);
var i = this.parseObject(e.object, n, r);
return e.animations && (i.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(i), 
i;
},
parseShape: function(e) {
var t = {};
if (void 0 !== e) for (var n = 0, r = e.length; n < r; n++) {
var i = new Hr().fromJSON(e[n]);
t[i.uuid] = i;
}
return t;
},
parseGeometries: function(e, t) {
var n = {};
if (void 0 !== e) for (var r = new hi(), i = 0, a = e.length; i < a; i++) {
var o = void 0, s = e[i];
switch (s.type) {
case "PlaneGmtr":
case "PlaneBufferGmtr":
o = new uc[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
break;

case "BoxGmtr":
case "BoxBufferGmtr":
case "CubeGmtr":
o = new uc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
break;

case "CircleGmtr":
case "CircleBufferGmtr":
o = new uc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
break;

case "CylinderGmtr":
case "CylinderBufferGmtr":
o = new uc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
break;

case "ConeGmtr":
case "ConeBufferGmtr":
o = new uc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
break;

case "SphereGmtr":
case "SphereBufferGmtr":
o = new uc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
break;

case "DodecahedronGmtr":
case "DodecahedronBufferGmtr":
case "IcosahedronGmtr":
case "IcosahedronBufferGmtr":
case "OctahedronGmtr":
case "OctahedronBufferGmtr":
case "TetrahedronGmtr":
case "TetrahedronBufferGmtr":
o = new uc[s.type](s.radius, s.detail);
break;

case "RingGmtr":
case "RingBufferGmtr":
o = new uc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
break;

case "TorusGmtr":
case "TorusBufferGmtr":
o = new uc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
break;

case "TorusKnotGmtr":
case "TorusKnotBufferGmtr":
o = new uc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
break;

case "TubeGmtr":
case "TubeBufferGmtr":
o = new uc[s.type](new bc[s.path.type]().fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
break;

case "LatheGmtr":
case "LatheBufferGmtr":
o = new uc[s.type](s.points, s.segments, s.phiStart, s.phiLength);
break;

case "PolyhedronGmtr":
case "PolyhedronBufferGmtr":
o = new uc[s.type](s.vertices, s.indices, s.radius, s.details);
break;

case "ShapeGmtr":
case "ShapeBufferGmtr":
o = [];
for (var c = 0, l = s.shapes.length; c < l; c++) o.push(t[s.shapes[c]]);
o = new uc[s.type](o, s.curveSegments);
break;

case "ExtrudeGmtr":
case "ExtrudeBufferGmtr":
for (o = [], c = 0, l = s.shapes.length; c < l; c++) o.push(t[s.shapes[c]]);
void 0 !== (c = s.options.extrudePath) && (s.options.extrudePath = new bc[c.type]().fromJSON(c)), 
o = new uc[s.type](o, s.options);
break;

case "BufferGmtr":
case "InstancedBufferGmtr":
o = r.parse(s);
break;

case "Gmtr":
console.error('$3.ObjectLoader: Loading "Gmtr" is not supported anymore.');
break;

default:
console.warn('$3.ObjectLoader: Unsupported geometry type "' + s.type + '"');
continue;
}
o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGmtr && void 0 !== s.userData && (o.userData = s.userData), 
n[s.uuid] = o;
}
return n;
},
parseMtrls: function(e, t) {
var n = {}, r = {};
if (void 0 !== e) {
var i = new ci();
i.setTextures(t), t = 0;
for (var a = e.length; t < a; t++) {
var o = e[t];
if ("MultiMtrl" === o.type) {
for (var s = [], c = 0; c < o.materials.length; c++) {
var l = o.materials[c];
void 0 === n[l.uuid] && (n[l.uuid] = i.parse(l)), s.push(n[l.uuid]);
}
r[o.uuid] = s;
} else void 0 === n[o.uuid] && (n[o.uuid] = i.parse(o)), r[o.uuid] = n[o.uuid];
}
}
return r;
},
parseAnimations: function(e) {
for (var t = [], n = 0; n < e.length; n++) {
var r = e[n], i = $r.parse(r);
void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i);
}
return t;
},
parseImages: function(e, t) {
function n(e) {
return r.manager.itemStart(e), a.load(e, function() {
r.manager.itemEnd(e);
}, void 0, function() {
r.manager.itemError(e), r.manager.itemEnd(e);
});
}
var r = this, i = {};
if (void 0 !== e && 0 < e.length) {
var a = new Tr(t = new xr(t));
a.setCrossOrigin(this.crossOrigin), t = 0;
for (var o = e.length; t < o; t++) {
var s = e[t], c = s.url;
if (Array.isArray(c)) {
i[s.uuid] = [];
for (var l = 0, u = c.length; l < u; l++) {
var h = c[l];
h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : r.resourcePath + h, i[s.uuid].push(n(h));
}
} else c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : r.resourcePath + s.url, 
i[s.uuid] = n(c);
}
}
return i;
},
parseTextures: function(e, t) {
function n(e, t) {
return "number" == typeof e ? e : (console.warn("$3.ObjectLoader.parseTexture: Constant should be in numeric form.", e), 
t[e]);
}
var r = {};
if (void 0 !== e) for (var a = 0, o = e.length; a < o; a++) {
var s = e[a];
void 0 === s.image && console.warn('$3.ObjectLoader: No "image" specified for', s.uuid), 
void 0 === t[s.image] && console.warn("$3.ObjectLoader: Undefined image", s.image);
var c = void 0;
(c = Array.isArray(t[s.image]) ? new ce(t[s.image]) : new i(t[s.image])).needsUpdate = !0, 
c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = n(s.mapping, _c)), 
void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), 
void 0 !== s.center && c.center.fromArray(s.center), void 0 !== s.rotation && (c.rotation = s.rotation), 
void 0 !== s.wrap && (c.wrapS = n(s.wrap[0], Mc), c.wrapT = n(s.wrap[1], Mc)), void 0 !== s.format && (c.format = s.format), 
void 0 !== s.type && (c.type = s.type), void 0 !== s.encoding && (c.encoding = s.encoding), 
void 0 !== s.minFilter && (c.minFilter = n(s.minFilter, Sc)), void 0 !== s.magFilter && (c.magFilter = n(s.magFilter, Sc)), 
void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), 
void 0 !== s.premultiplyAlpha && (c.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (c.unpackAlignment = s.unpackAlignment), 
r[s.uuid] = c;
}
return r;
},
parseObject: function(e, t, n) {
function r(e) {
return void 0 === t[e] && console.warn("$3.ObjectLoader: Undefined geometry", e), 
t[e];
}
function i(e) {
if (void 0 !== e) {
if (Array.isArray(e)) {
for (var t = [], r = 0, i = e.length; r < i; r++) {
var a = e[r];
void 0 === n[a] && console.warn("$3.ObjectLoader: Undefined material", a), t.push(n[a]);
}
return t;
}
return void 0 === n[e] && console.warn("$3.ObjectLoader: Undefined material", e), 
n[e];
}
}
switch (e.type) {
case "Scene":
var a = new f();
void 0 !== e.background && Number.isInteger(e.background) && (a.background = new x(e.background)), 
void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new wt(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new xt(e.fog.color, e.fog.density)));
break;

case "PerspectiveCamera":
a = new Y(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), 
void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), 
void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
break;

case "OrthographicCamera":
a = new ti(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), 
void 0 !== e.view && (a.view = Object.assign({}, e.view));
break;

case "AmbientLight":
a = new ii(e.color, e.intensity);
break;

case "DirectionalLight":
a = new ri(e.color, e.intensity);
break;

case "PointLight":
a = new ei(e.color, e.intensity, e.distance, e.decay);
break;

case "RectAreaLight":
a = new ai(e.color, e.intensity, e.width, e.height);
break;

case "SpotLight":
a = new Kr(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
break;

case "HemisphereLight":
a = new Yr(e.color, e.groundColor, e.intensity);
break;

case "LightProbe":
a = new si().fromJSON(e);
break;

case "SkinnedMesh":
console.warn("$3.ObjectLoader.parseObject() does not support SkinnedMesh yet.");

case "Mesh":
a = r(e.geometry);
var o = i(e.material);
a = new z(a, o);
break;

case "InstancedMesh":
a = r(e.geometry), o = i(e.material);
var s = e.instanceMatrix;
(a = new kt(a, o, e.count)).instanceMatrix = new L(new Float32Array(s.array), 16);
break;

case "LOD":
a = new Lt();
break;

case "Line":
a = new Dt(r(e.geometry), i(e.material), e.mode);
break;

case "LineLoop":
a = new It(r(e.geometry), i(e.material));
break;

case "LineSegments":
a = new Nt(r(e.geometry), i(e.material));
break;

case "PointCloud":
case "Points":
a = new jt(r(e.geometry), i(e.material));
break;

case "Sprite":
a = new At(i(e.material));
break;

case "Group":
a = new vt();
break;

default:
a = new p();
}
if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), 
void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), 
void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), 
void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), 
void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), 
void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), 
void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), 
void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), 
void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), 
void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children) for (s = e.children, 
o = 0; o < s.length; o++) a.add(this.parseObject(s[o], t, n));
if ("LOD" === e.type) for (void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate), 
e = e.levels, s = 0; s < e.length; s++) {
o = e[s];
var c = a.getObjectByProperty("uuid", o.object);
void 0 !== c && a.addLevel(c, o.distance);
}
return a;
}
});
var _c = {
UVMapping: 300,
CubeReflectionMapping: 301,
CubeRefractionMapping: 302,
EquirectangularReflectionMapping: 303,
EquirectangularRefractionMapping: 304,
CubeUVReflectionMapping: 306,
CubeUVRefractionMapping: 307
}, Mc = {
RepeatWrapping: 1e3,
ClampToEdgeWrapping: 1001,
MirroredRepeatWrapping: 1002
}, Sc = {
NearestFilter: 1003,
NearestMipmapNearestFilter: 1004,
NearestMipmapLinearFilter: 1005,
LinearFilter: 1006,
LinearMipmapNearestFilter: 1007,
LinearMipmapLinearFilter: 1008
};
pi.prototype = Object.assign(Object.create(wr.prototype), {
constructor: pi,
setOptions: function(e) {
return this.options = e, this;
},
load: function(e, t, n, r) {
void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
var i = this, a = pc.get(e);
if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
t && t(a), i.manager.itemEnd(e);
}, 0), a;
fetch(e).then(function(e) {
return e.blob();
}).then(function(e) {
return void 0 === i.options ? createImageBitmap(e) : createImageBitmap(e, i.options);
}).then(function(n) {
pc.add(e, n), t && t(n), i.manager.itemEnd(e);
}).catch(function(t) {
r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
}), i.manager.itemStart(e);
}
}), Object.assign(fi.prototype, {
moveTo: function(e, t) {
return this.currentPath = new qr(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), 
this;
},
lineTo: function(e, t) {
return this.currentPath.lineTo(e, t), this;
},
quadraticCurveTo: function(e, t, n, r) {
return this.currentPath.quadraticCurveTo(e, t, n, r), this;
},
bezierCurveTo: function(e, t, n, r, i, a) {
return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this;
},
splineThru: function(e) {
return this.currentPath.splineThru(e), this;
},
toShapes: function(e, t) {
function n(e) {
for (var t = [], n = 0, r = e.length; n < r; n++) {
var i = e[n], a = new Hr();
a.curves = i.curves, t.push(a);
}
return t;
}
function r(e, t) {
for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
var o = t[i], s = t[a], c = s.x - o.x, l = s.y - o.y;
if (Math.abs(l) > Number.EPSILON) {
if (0 > l && (o = t[a], c = -c, s = t[i], l = -l), !(e.y < o.y || e.y > s.y)) if (e.y === o.y) {
if (e.x === o.x) return !0;
} else {
if (0 === (i = l * (e.x - o.x) - c * (e.y - o.y))) return !0;
0 > i || (r = !r);
}
} else if (e.y === o.y && (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x)) return !0;
}
return r;
}
var i = cc.isClockWise, a = this.subPaths;
if (0 === a.length) return [];
if (!0 === t) return n(a);
if (t = [], 1 === a.length) {
var o = a[0], s = new Hr();
return s.curves = o.curves, t.push(s), t;
}
var c = !i(a[0].getPoints());
c = e ? !c : c, s = [];
var l = [], u = [], h = 0;
l[h] = void 0, u[h] = [];
for (var d = 0, p = a.length; d < p; d++) {
var f = (o = a[d]).getPoints(), m = i(f);
(m = e ? !m : m) ? (!c && l[h] && h++, l[h] = {
s: new Hr(),
p: f
}, l[h].s.curves = o.curves, c && h++, u[h] = []) : u[h].push({
h: o,
p: f[0]
});
}
if (!l[0]) return n(a);
if (1 < l.length) {
for (e = !1, i = [], a = 0, o = l.length; a < o; a++) s[a] = [];
for (a = 0, o = l.length; a < o; a++) for (m = u[a], c = 0; c < m.length; c++) {
for (h = m[c], f = !0, d = 0; d < l.length; d++) r(h.p, l[d].p) && (a !== d && i.push({
froms: a,
tos: d,
hole: c
}), f ? (f = !1, s[d].push(h)) : e = !0);
f && s[a].push(h);
}
0 < i.length && (e || (u = s));
}
for (i = 0, a = l.length; i < a; i++) for (s = l[i].s, t.push(s), o = 0, m = (e = u[i]).length; o < m; o++) s.holes.push(e[o].h);
return t;
}
}), Object.assign(mi.prototype, {
isFont: !0,
generateShapes: function(e, t) {
void 0 === t && (t = 100);
var n = [], r = t;
t = this.data;
var i = Array.from ? Array.from(e) : String(e).split("");
r /= t.resolution;
var a = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * r;
e = [];
for (var o = 0, s = 0, c = 0; c < i.length; c++) {
var l = i[c];
if ("\n" === l) o = 0, s -= a; else {
var u = l;
l = r;
var h = o, d = s, p = t, f = p.glyphs[u] || p.glyphs["?"];
if (f) {
if (u = new fi(), f.o) for (var m = 0, g = (p = f._cachedOutline || (f._cachedOutline = f.o.split(" "))).length; m < g; ) switch (p[m++]) {
case "m":
var v = p[m++] * l + h, y = p[m++] * l + d;
u.moveTo(v, y);
break;

case "l":
v = p[m++] * l + h, y = p[m++] * l + d, u.lineTo(v, y);
break;

case "q":
var $ = p[m++] * l + h, b = p[m++] * l + d, x = p[m++] * l + h, w = p[m++] * l + d;
u.quadraticCurveTo(x, w, $, b);
break;

case "b":
$ = p[m++] * l + h, b = p[m++] * l + d, x = p[m++] * l + h, w = p[m++] * l + d, 
v = p[m++] * l + h, y = p[m++] * l + d, u.bezierCurveTo(x, w, v, y, $, b);
}
l = {
offsetX: f.ha * l,
path: u
};
} else console.error('$3.Font: character "' + u + '" does not exists in font family ' + p.familyName + "."), 
l = void 0;
o += l.offsetX, e.push(l.path);
}
}
for (t = 0, i = e.length; t < i; t++) Array.prototype.push.apply(n, e[t].toShapes());
return n;
}
}), gi.prototype = Object.assign(Object.create(wr.prototype), {
constructor: gi,
load: function(e, t, n, r) {
var i = this, a = new _r(this.manager);
a.setPath(this.path), a.load(e, function(e) {
try {
var n = JSON.parse(e);
} catch (t) {
console.warn("$3.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), 
n = JSON.parse(e.substring(65, e.length - 2));
}
e = i.parse(n), t && t(e);
}, n, r);
},
parse: function(e) {
return new mi(e);
}
});
var Ac, Tc = {
getContext: function() {
return void 0 === Ac && (Ac = new (window.AudioContext || window.webkitAudioContext)()), 
Ac;
},
setContext: function(e) {
Ac = e;
}
};
vi.prototype = Object.assign(Object.create(wr.prototype), {
constructor: vi,
load: function(e, t, n, r) {
var i = this, a = new _r(i.manager);
a.setResponseType("arraybuffer"), a.setPath(i.path), a.load(e, function(n) {
try {
var a = n.slice(0);
Tc.getContext().decodeAudioData(a, function(e) {
t(e);
});
} catch (t) {
r ? r(t) : console.error(t), i.manager.itemError(e);
}
}, n, r);
}
}), yi.prototype = Object.assign(Object.create(si.prototype), {
constructor: yi,
isHemisphereLightProbe: !0,
copy: function(e) {
return si.prototype.copy.call(this, e), this;
},
toJSON: function(e) {
return si.prototype.toJSON.call(this, e);
}
}), $i.prototype = Object.assign(Object.create(si.prototype), {
constructor: $i,
isAmbientLightProbe: !0,
copy: function(e) {
return si.prototype.copy.call(this, e), this;
},
toJSON: function(e) {
return si.prototype.toJSON.call(this, e);
}
});
var Lc = new u(), Cc = new u();
Object.assign(bi.prototype, {
update: function(e) {
var t = this._cache;
if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, 
t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
var n = e.projectionMatrix.clone(), r = t.eyeSep / 2, i = r * t.near / t.focus, a = t.near * Math.tan(da.DEG2RAD * t.fov * .5) / t.zoom;
Cc.elements[12] = -r, Lc.elements[12] = r, r = -a * t.aspect + i;
var o = a * t.aspect + i;
n.elements[0] = 2 * t.near / (o - r), n.elements[8] = (o + r) / (o - r), this.cameraL.projectionMatrix.copy(n), 
r = -a * t.aspect - i, o = a * t.aspect - i, n.elements[0] = 2 * t.near / (o - r), 
n.elements[8] = (o + r) / (o - r), this.cameraR.projectionMatrix.copy(n);
}
this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Cc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Lc);
}
}), Object.assign(xi.prototype, {
start: function() {
this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), 
this.elapsedTime = 0, this.running = !0;
},
stop: function() {
this.getElapsedTime(), this.autoStart = this.running = !1;
},
getElapsedTime: function() {
return this.getDelta(), this.elapsedTime;
},
getDelta: function() {
var e = 0;
if (this.autoStart && !this.running) return this.start(), 0;
if (this.running) {
var t = ("undefined" == typeof performance ? Date : performance).now();
e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
}
return e;
}
});
var Ec = new l(), Pc = new c(), kc = new l(), Oc = new l();
wi.prototype = Object.assign(Object.create(p.prototype), {
constructor: wi,
getInput: function() {
return this.gain;
},
removeFilter: function() {
return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), 
this.gain.connect(this.context.destination), this.filter = null), this;
},
getFilter: function() {
return this.filter;
},
setFilter: function(e) {
return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), 
this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), 
this;
},
getMasterVolume: function() {
return this.gain.gain.value;
},
setMasterVolume: function(e) {
return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
},
updateMatrixWorld: function(e) {
p.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
var t = this.up;
if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Ec, Pc, kc), 
Oc.set(0, 0, -1).applyQuaternion(Pc), e.positionX) {
var n = this.context.currentTime + this.timeDelta;
e.positionX.linearRampToValueAtTime(Ec.x, n), e.positionY.linearRampToValueAtTime(Ec.y, n), 
e.positionZ.linearRampToValueAtTime(Ec.z, n), e.forwardX.linearRampToValueAtTime(Oc.x, n), 
e.forwardY.linearRampToValueAtTime(Oc.y, n), e.forwardZ.linearRampToValueAtTime(Oc.z, n), 
e.upX.linearRampToValueAtTime(t.x, n), e.upY.linearRampToValueAtTime(t.y, n), e.upZ.linearRampToValueAtTime(t.z, n);
} else e.setPosition(Ec.x, Ec.y, Ec.z), e.setOrientation(Oc.x, Oc.y, Oc.z, t.x, t.y, t.z);
}
}), _i.prototype = Object.assign(Object.create(p.prototype), {
constructor: _i,
getOutput: function() {
return this.gain;
},
setNodeSource: function(e) {
return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, 
this.connect(), this;
},
setMediaElementSource: function(e) {
return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), 
this.connect(), this;
},
setMediaStreamSource: function(e) {
return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), 
this.connect(), this;
},
setBuffer: function(e) {
return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), 
this;
},
play: function(e) {
if (void 0 === e && (e = 0), !0 === this.isPlaying) console.warn("$3.Audio: Audio is already playing."); else {
if (!1 !== this.hasPlaybackControl) return this._startedAt = this.context.currentTime + e, 
(e = this.context.createBufferSource()).buffer = this.buffer, e.loop = this.loop, 
e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), 
e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, 
this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), 
this.connect();
console.warn("$3.Audio: this Audio has no playback control.");
}
},
pause: function() {
if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, 
!0 === this.loop && (this._progress %= this.duration || this.buffer.duration), this.source.stop(), 
this.source.onended = null, this.isPlaying = !1), this;
console.warn("$3.Audio: this Audio has no playback control.");
},
stop: function() {
if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), 
this.source.onended = null, this.isPlaying = !1, this;
console.warn("$3.Audio: this Audio has no playback control.");
},
connect: function() {
if (0 < this.filters.length) {
this.source.connect(this.filters[0]);
for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
this.filters[this.filters.length - 1].connect(this.getOutput());
} else this.source.connect(this.getOutput());
return this;
},
disconnect: function() {
if (0 < this.filters.length) {
this.source.disconnect(this.filters[0]);
for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
this.filters[this.filters.length - 1].disconnect(this.getOutput());
} else this.source.disconnect(this.getOutput());
return this;
},
getFilters: function() {
return this.filters;
},
setFilters: function(e) {
return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, 
this.connect()) : this.filters = e, this;
},
setDetune: function(e) {
if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), 
this;
},
getDetune: function() {
return this.detune;
},
getFilter: function() {
return this.getFilters()[0];
},
setFilter: function(e) {
return this.setFilters(e ? [ e ] : []);
},
setPlaybackRate: function(e) {
if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), 
this;
console.warn("$3.Audio: this Audio has no playback control.");
},
getPlaybackRate: function() {
return this.playbackRate;
},
onEnded: function() {
this.isPlaying = !1;
},
getLoop: function() {
return !1 === this.hasPlaybackControl ? (console.warn("$3.Audio: this Audio has no playback control."), 
!1) : this.loop;
},
setLoop: function(e) {
if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), 
this;
console.warn("$3.Audio: this Audio has no playback control.");
},
setLoopStart: function(e) {
return this.loopStart = e, this;
},
setLoopEnd: function(e) {
return this.loopEnd = e, this;
},
getVolume: function() {
return this.gain.gain.value;
},
setVolume: function(e) {
return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
}
});
var Dc = new l(), Nc = new c(), Ic = new l(), Rc = new l();
Mi.prototype = Object.assign(Object.create(_i.prototype), {
constructor: Mi,
getOutput: function() {
return this.panner;
},
getRefDistance: function() {
return this.panner.refDistance;
},
setRefDistance: function(e) {
return this.panner.refDistance = e, this;
},
getRolloffFactor: function() {
return this.panner.rolloffFactor;
},
setRolloffFactor: function(e) {
return this.panner.rolloffFactor = e, this;
},
getDistanceModel: function() {
return this.panner.distanceModel;
},
setDistanceModel: function(e) {
return this.panner.distanceModel = e, this;
},
getMaxDistance: function() {
return this.panner.maxDistance;
},
setMaxDistance: function(e) {
return this.panner.maxDistance = e, this;
},
setDirectionalCone: function(e, t, n) {
return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, 
this;
},
updateMatrixWorld: function(e) {
if (p.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) if (this.matrixWorld.decompose(Dc, Nc, Ic), 
Rc.set(0, 0, 1).applyQuaternion(Nc), (e = this.panner).positionX) {
var t = this.context.currentTime + this.listener.timeDelta;
e.positionX.linearRampToValueAtTime(Dc.x, t), e.positionY.linearRampToValueAtTime(Dc.y, t), 
e.positionZ.linearRampToValueAtTime(Dc.z, t), e.orientationX.linearRampToValueAtTime(Rc.x, t), 
e.orientationY.linearRampToValueAtTime(Rc.y, t), e.orientationZ.linearRampToValueAtTime(Rc.z, t);
} else e.setPosition(Dc.x, Dc.y, Dc.z), e.setOrientation(Rc.x, Rc.y, Rc.z);
}
}), Object.assign(Si.prototype, {
getFrequencyData: function() {
return this.analyser.getByteFrequencyData(this.data), this.data;
},
getAverageFrequency: function() {
for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
return e / t.length;
}
}), Object.assign(Ai.prototype, {
accumulate: function(e, t) {
var n = this.buffer, r = this.valueSize;
e = e * r + r;
var i = this.cumulativeWeight;
if (0 === i) {
for (i = 0; i !== r; ++i) n[e + i] = n[i];
i = t;
} else i += t, this._mixBufferRegion(n, e, 0, t / i, r);
this.cumulativeWeight = i;
},
accumulateAdditive: function(e) {
var t = this.buffer, n = this.valueSize, r = n * this._addIndex;
0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), 
this.cumulativeWeightAdditive += e;
},
apply: function(e) {
var t = this.valueSize, n = this.buffer;
e = e * t + t;
var r = this.cumulativeWeight, i = this.cumulativeWeightAdditive, a = this.binding;
for (this.cumulativeWeightAdditive = this.cumulativeWeight = 0, 1 > r && this._mixBufferRegion(n, e, t * this._origIndex, 1 - r, t), 
0 < i && this._mixBufferRegionAdditive(n, e, this._addIndex * t, 1, t), r = t, i = t + t; r !== i; ++r) if (n[r] !== n[r + t]) {
a.setValue(n, e);
break;
}
},
saveOriginalState: function() {
var e = this.buffer, t = this.valueSize, n = t * this._origIndex;
this.binding.getValue(e, n);
for (var r = t; r !== n; ++r) e[r] = e[n + r % t];
this._setIdentity(), this.cumulativeWeightAdditive = this.cumulativeWeight = 0;
},
restoreOriginalState: function() {
this.binding.setValue(this.buffer, 3 * this.valueSize);
},
_setAdditiveIdentityNumeric: function() {
for (var e = this._addIndex * this.valueSize, t = e + this.valueSize; e < t; e++) this.buffer[e] = 0;
},
_setAdditiveIdentityQuaternion: function() {
this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1;
},
_setAdditiveIdentityOther: function() {
for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
},
_select: function(e, t, n, r, i) {
if (.5 <= r) for (r = 0; r !== i; ++r) e[t + r] = e[n + r];
},
_slerp: function(e, t, n, r) {
c.slerpFlat(e, t, e, t, e, n, r);
},
_slerpAdditive: function(e, t, n, r, i) {
i *= this._workIndex, c.multiplyQuaternionsFlat(e, i, e, t, e, n), c.slerpFlat(e, t, e, t, e, i, r);
},
_lerp: function(e, t, n, r, i) {
for (var a = 1 - r, o = 0; o !== i; ++o) {
var s = t + o;
e[s] = e[s] * a + e[n + o] * r;
}
},
_lerpAdditive: function(e, t, n, r, i) {
for (var a = 0; a !== i; ++a) {
e[t + a] += e[n + a] * r;
}
}
});
var jc = /[\[\]\.:\/]/g, Uc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Bc = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), zc = /(WCOD+)?/.source.replace("WCOD", Uc), Fc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Gc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Vc = new RegExp("^" + Bc + zc + Fc + Gc + "$"), Wc = [ "material", "materials", "bones" ];
Object.assign(Ti.prototype, {
getValue: function(e, t) {
this.bind();
var n = this._bindings[this._targetGroup.nCachedObjects_];
void 0 !== n && n.getValue(e, t);
},
setValue: function(e, t) {
for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t);
},
bind: function() {
for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
},
unbind: function() {
for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
}
}), Object.assign(Li, {
Composite: Ti,
create: function(e, t, n) {
return e && e.isAnimationObjectGroup ? new Li.Composite(e, t, n) : new Li(e, t, n);
},
sanitizeNodeName: function(e) {
return e.replace(/\s/g, "_").replace(jc, "");
},
parseTrackName: function(e) {
var t = Vc.exec(e);
if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
var n = (t = {
nodeName: t[2],
objectName: t[3],
objectIndex: t[4],
propertyName: t[5],
propertyIndex: t[6]
}).nodeName && t.nodeName.lastIndexOf(".");
if (void 0 !== n && -1 !== n) {
var r = t.nodeName.substring(n + 1);
-1 !== Wc.indexOf(r) && (t.nodeName = t.nodeName.substring(0, n), t.objectName = r);
}
if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
return t;
},
findNode: function(e, t) {
if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
if (e.skeleton) {
var n = e.skeleton.getBoneByName(t);
if (void 0 !== n) return n;
}
if (e.children) {
var r = function(e) {
for (var n = 0; n < e.length; n++) {
var i = e[n];
if (i.name === t || i.uuid === t || (i = r(i.children))) return i;
}
return null;
};
if (e = r(e.children)) return e;
}
return null;
}
}), Object.assign(Li.prototype, {
_getValue_unavailable: function() {},
_setValue_unavailable: function() {},
BindingType: {
Direct: 0,
EntireArray: 1,
ArrayElement: 2,
HasFromToArray: 3
},
Versioning: {
None: 0,
NeedsUpdate: 1,
MatrixWorldNeedsUpdate: 2
},
GetterByBindingType: [ function(e, t) {
e[t] = this.node[this.propertyName];
}, function(e, t) {
for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r];
}, function(e, t) {
e[t] = this.resolvedProperty[this.propertyIndex];
}, function(e, t) {
this.resolvedProperty.toArray(e, t);
} ],
SetterByBindingTypeAndVersioning: [ [ function(e, t) {
this.targetObject[this.propertyName] = e[t];
}, function(e, t) {
this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
}, function(e, t) {
this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
} ], [ function(e, t) {
for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
}, function(e, t) {
for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
this.targetObject.needsUpdate = !0;
}, function(e, t) {
for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
this.targetObject.matrixWorldNeedsUpdate = !0;
} ], [ function(e, t) {
this.resolvedProperty[this.propertyIndex] = e[t];
}, function(e, t) {
this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
}, function(e, t) {
this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
} ], [ function(e, t) {
this.resolvedProperty.fromArray(e, t);
}, function(e, t) {
this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
}, function(e, t) {
this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
} ] ],
getValue: function(e, t) {
this.bind(), this.getValue(e, t);
},
setValue: function(e, t) {
this.bind(), this.setValue(e, t);
},
bind: function() {
var e = this.node, t = this.parsedPath, n = t.objectName, r = t.propertyName, i = t.propertyIndex;
if (e || (this.node = e = Li.findNode(this.rootNode, t.nodeName) || this.rootNode), 
this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, 
e) {
if (n) {
var a = t.objectIndex;
switch (n) {
case "materials":
if (!e.material) return void console.error("$3.PropertyBinding: Can not bind to material as node does not have a material.", this);
if (!e.material.materials) return void console.error("$3.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
e = e.material.materials;
break;

case "bones":
if (!e.skeleton) return void console.error("$3.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
for (e = e.skeleton.bones, n = 0; n < e.length; n++) if (e[n].name === a) {
a = n;
break;
}
break;

default:
if (void 0 === e[n]) return void console.error("$3.PropertyBinding: Can not bind to objectName of node undefined.", this);
e = e[n];
}
if (void 0 !== a) {
if (void 0 === e[a]) return void console.error("$3.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
e = e[a];
}
}
if (void 0 === (a = e[r])) console.error("$3.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + r + " but it wasn't found.", e); else {
if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), 
n = this.BindingType.Direct, void 0 !== i) {
if ("morphTargetInfluences" === r) {
if (!e.geometry) return void console.error("$3.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
if (!e.geometry.isBufferGmtr) return void console.error("$3.PropertyBinding: Can not bind to morphTargetInfluences on $3.Gmtr. Use $3.BufferGmtr instead.", this);
if (!e.geometry.morphAttributes) return void console.error("$3.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]);
}
n = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = i;
} else void 0 !== a.fromArray && void 0 !== a.toArray ? (n = this.BindingType.HasFromToArray, 
this.resolvedProperty = a) : Array.isArray(a) ? (n = this.BindingType.EntireArray, 
this.resolvedProperty = a) : this.propertyName = r;
this.getValue = this.GetterByBindingType[n], this.setValue = this.SetterByBindingTypeAndVersioning[n][t];
}
} else console.error("$3.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
},
unbind: function() {
this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
}
}), Object.assign(Li.prototype, {
_getValue_unbound: Li.prototype.getValue,
_setValue_unbound: Li.prototype.setValue
}), Object.assign(Ci.prototype, {
isAnimationObjectGroup: !0,
add: function() {
for (var e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length, o = void 0, s = e.length, c = this.nCachedObjects_, l = 0, u = arguments.length; l !== u; ++l) {
var h = arguments[l], d = h.uuid, p = t[d];
if (void 0 === p) {
p = s++, t[d] = p, e.push(h), p = 0;
for (var f = a; p !== f; ++p) i[p].push(new Li(h, n[p], r[p]));
} else if (p < c) {
o = e[p];
var m = e[f = --c];
for (t[m.uuid] = p, e[p] = m, t[d] = f, e[f] = h, d = 0, m = a; d !== m; ++d) {
var g = i[d], v = g[p];
g[p] = g[f], void 0 === v && (v = new Li(h, n[d], r[d])), g[f] = v;
}
} else e[p] !== o && console.error("$3.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
}
this.nCachedObjects_ = c;
},
remove: function() {
for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = 0, o = arguments.length; a !== o; ++a) {
var s = arguments[a], c = s.uuid, l = t[c];
if (void 0 !== l && l >= i) {
var u = i++, h = e[u];
for (t[h.uuid] = l, e[l] = h, t[c] = u, e[u] = s, s = 0, c = r; s !== c; ++s) {
var d = (h = n[s])[l];
h[l] = h[u], h[u] = d;
}
}
}
this.nCachedObjects_ = i;
},
uncache: function() {
for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = e.length, o = 0, s = arguments.length; o !== s; ++o) {
var c = arguments[o].uuid, l = t[c];
if (void 0 !== l) if (delete t[c], l < i) {
var u = e[c = --i], h = --a, d = e[h];
for (t[u.uuid] = l, e[l] = u, t[d.uuid] = c, e[c] = d, e.pop(), u = 0, d = r; u !== d; ++u) {
var p = n[u], f = p[h];
p[l] = p[c], p[c] = f, p.pop();
}
} else for (t[(h = e[c = --a]).uuid] = l, e[l] = h, e.pop(), h = 0, u = r; h !== u; ++h) (d = n[h])[l] = d[c], 
d.pop();
}
this.nCachedObjects_ = i;
},
subscribe_: function(e, t) {
var n = this._bindingsIndicesByPath, r = n[e], i = this._bindings;
if (void 0 !== r) return i[r];
var a = this._paths, o = this._parsedPaths, s = this._objects, c = this.nCachedObjects_, l = Array(s.length);
for (r = i.length, n[e] = r, a.push(e), o.push(t), i.push(l), n = c, r = s.length; n !== r; ++n) l[n] = new Li(s[n], e, t);
return l;
},
unsubscribe_: function(e) {
var t = this._bindingsIndicesByPath, n = t[e];
if (void 0 !== n) {
var r = this._paths, i = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o];
t[e[o]] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop();
}
}
}), Object.assign(Ei.prototype, {
play: function() {
return this._mixer._activateAction(this), this;
},
stop: function() {
return this._mixer._deactivateAction(this), this.reset();
},
reset: function() {
return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, 
this._startTime = null, this.stopFading().stopWarping();
},
isRunning: function() {
return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
},
isScheduled: function() {
return this._mixer._isActiveAction(this);
},
startAt: function(e) {
return this._startTime = e, this;
},
setLoop: function(e, t) {
return this.loop = e, this.repetitions = t, this;
},
setEffectiveWeight: function(e) {
return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
},
getEffectiveWeight: function() {
return this._effectiveWeight;
},
fadeIn: function(e) {
return this._scheduleFading(e, 0, 1);
},
fadeOut: function(e) {
return this._scheduleFading(e, 1, 0);
},
crossFadeFrom: function(e, t, n) {
if (e.fadeOut(t), this.fadeIn(t), n) {
n = this._clip.duration;
var r = e._clip.duration, i = n / r;
e.warp(1, r / n, t), this.warp(i, 1, t);
}
return this;
},
crossFadeTo: function(e, t, n) {
return e.crossFadeFrom(this, t, n);
},
stopFading: function() {
var e = this._weightInterpolant;
return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), 
this;
},
setEffectiveTimeScale: function(e) {
return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
},
getEffectiveTimeScale: function() {
return this._effectiveTimeScale;
},
setDuration: function(e) {
return this.timeScale = this._clip.duration / e, this.stopWarping();
},
syncWith: function(e) {
return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
},
halt: function(e) {
return this.warp(this._effectiveTimeScale, 0, e);
},
warp: function(e, t, n) {
var r = this._mixer, i = r.time, a = this.timeScale, o = this._timeScaleInterpolant;
return null === o && (this._timeScaleInterpolant = o = r._lendControlInterpolant()), 
r = o.parameterPositions, o = o.sampleValues, r[0] = i, r[1] = i + n, o[0] = e / a, 
o[1] = t / a, this;
},
stopWarping: function() {
var e = this._timeScaleInterpolant;
return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), 
this;
},
getMixer: function() {
return this._mixer;
},
getClip: function() {
return this._clip;
},
getRoot: function() {
return this._localRoot || this._mixer._root;
},
_update: function(e, t, n, r) {
if (this.enabled) {
var i = this._startTime;
if (null !== i) {
if (0 > (t = (e - i) * n) || 0 === n) return;
this._startTime = null, t *= n;
}
if (t *= this._updateTimeScale(e), n = this._updateTime(t), 0 < (e = this._updateWeight(e))) switch (t = this._interpolants, 
i = this._propertyBindings, this.blendMode) {
case 2501:
r = 0;
for (var a = t.length; r !== a; ++r) t[r].evaluate(n), i[r].accumulateAdditive(e);
break;

default:
a = 0;
for (var o = t.length; a !== o; ++a) t[a].evaluate(n), i[a].accumulate(r, e);
}
} else this._updateWeight(e);
},
_updateWeight: function(e) {
var t = 0;
if (this.enabled) {
t = this.weight;
var n = this._weightInterpolant;
if (null !== n) {
var r = n.evaluate(e)[0];
t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1));
}
}
return this._effectiveWeight = t;
},
_updateTimeScale: function(e) {
var t = 0;
if (!this.paused) {
t = this.timeScale;
var n = this._timeScaleInterpolant;
if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 
0 === t ? this.paused = !0 : this.timeScale = t);
}
return this._effectiveTimeScale = t;
},
_updateTime: function(e) {
var t = this._clip.duration, n = this.loop, r = this.time + e, i = this._loopCount, a = 2202 === n;
if (0 === e) return -1 === i ? r : a && 1 == (1 & i) ? t - r : r;
if (2200 === n) e: {
if (-1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)), r >= t) r = t; else {
if (!(0 > r)) {
this.time = r;
break e;
}
r = 0;
}
this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
type: "finished",
action: this,
direction: 0 > e ? -1 : 1
});
} else {
if (-1 === i && (0 <= e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), 
r >= t || 0 > r) {
r -= t * (n = Math.floor(r / t)), i += Math.abs(n);
var o = this.repetitions - i;
0 >= o ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r = 0 < e ? t : 0, 
this._mixer.dispatchEvent({
type: "finished",
action: this,
direction: 0 < e ? 1 : -1
})) : (1 === o ? (e = 0 > e, this._setEndings(e, !e, a)) : this._setEndings(!1, !1, a), 
this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
type: "loop",
action: this,
loopDelta: n
}));
} else this.time = r;
if (a && 1 == (1 & i)) return t - r;
}
return r;
},
_setEndings: function(e, t, n) {
var r = this._interpolantSettings;
n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, 
r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
},
_scheduleFading: function(e, t, n) {
var r = this._mixer, i = r.time, a = this._weightInterpolant;
return null === a && (this._weightInterpolant = a = r._lendControlInterpolant()), 
r = a.parameterPositions, a = a.sampleValues, r[0] = i, a[0] = t, r[1] = i + e, 
a[1] = n, this;
}
}), Pi.prototype = Object.assign(Object.create(t.prototype), {
constructor: Pi,
_bindAction: function(e, t) {
var n = e._localRoot || this._root, r = e._clip.tracks, i = r.length, a = e._propertyBindings;
e = e._interpolants;
var o = n.uuid, s = this._bindingsByRootAndName, c = s[o];
for (void 0 === c && (c = {}, s[o] = c), s = 0; s !== i; ++s) {
var l = r[s], u = l.name, h = c[u];
if (void 0 === h) {
if (void 0 !== (h = a[s])) {
null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, u));
continue;
}
++(h = new Ai(Li.create(n, u, t && t._propertyBindings[s].binding.parsedPath), l.ValueTypeName, l.getValueSize())).referenceCount, 
this._addInactiveBinding(h, o, u);
}
a[s] = h, e[s].resultBuffer = h.buffer;
}
},
_activateAction: function(e) {
if (!this._isActiveAction(e)) {
if (null === e._cacheIndex) {
var t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n];
this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t);
}
for (n = 0, r = (t = e._propertyBindings).length; n !== r; ++n) {
var i = t[n];
0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
}
this._lendAction(e);
}
},
_deactivateAction: function(e) {
if (this._isActiveAction(e)) {
for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
var i = t[n];
0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
}
this._takeBackAction(e);
}
},
_initMemoryManager: function() {
this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], 
this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], 
this._nActiveControlInterpolants = 0;
var e = this;
this.stats = {
actions: {
get total() {
return e._actions.length;
},
get inUse() {
return e._nActiveActions;
}
},
bindings: {
get total() {
return e._bindings.length;
},
get inUse() {
return e._nActiveBindings;
}
},
controlInterpolants: {
get total() {
return e._controlInterpolants.length;
},
get inUse() {
return e._nActiveControlInterpolants;
}
}
};
},
_isActiveAction: function(e) {
return null !== (e = e._cacheIndex) && e < this._nActiveActions;
},
_addInactiveAction: function(e, t, n) {
var r = this._actions, i = this._actionsByClip, a = i[t];
void 0 === a ? (a = {
knownActions: [ e ],
actionByRoot: {}
}, e._byClipCacheIndex = 0, i[t] = a) : (t = a.knownActions, e._byClipCacheIndex = t.length, 
t.push(e)), e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e;
},
_removeInactiveAction: function(e) {
var t = this._actions, n = t[t.length - 1], r = e._cacheIndex;
n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null, t = e._clip.uuid;
var i = (r = (n = this._actionsByClip)[t]).knownActions, a = i[i.length - 1], o = e._byClipCacheIndex;
a._byClipCacheIndex = o, i[o] = a, i.pop(), e._byClipCacheIndex = null, delete r.actionByRoot[(e._localRoot || this._root).uuid], 
0 === i.length && delete n[t], this._removeInactiveBindingsForAction(e);
},
_removeInactiveBindingsForAction: function(e) {
for (var t = 0, n = (e = e._propertyBindings).length; t !== n; ++t) {
var r = e[t];
0 == --r.referenceCount && this._removeInactiveBinding(r);
}
},
_lendAction: function(e) {
var t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, i = t[r];
e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
},
_takeBackAction: function(e) {
var t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, i = t[r];
e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
},
_addInactiveBinding: function(e, t, n) {
var r = this._bindingsByRootAndName, i = this._bindings, a = r[t];
void 0 === a && (a = {}, r[t] = a), a[n] = e, e._cacheIndex = i.length, i.push(e);
},
_removeInactiveBinding: function(e) {
var t = this._bindings, n = e.binding, r = n.rootNode.uuid;
n = n.path;
var i = this._bindingsByRootAndName, a = i[r], o = t[t.length - 1];
e = e._cacheIndex, o._cacheIndex = e, t[e] = o, t.pop(), delete a[n], 0 === Object.keys(a).length && delete i[r];
},
_lendBinding: function(e) {
var t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, i = t[r];
e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
},
_takeBackBinding: function(e) {
var t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, i = t[r];
e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
},
_lendControlInterpolant: function() {
var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, n = e[t];
return void 0 === n && ((n = new lr(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, 
e[t] = n), n;
},
_takeBackControlInterpolant: function(e) {
var t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, i = t[r];
e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i;
},
_controlInterpolantsResultBuffer: new Float32Array(1),
clipAction: function(e, t, n) {
var r = t || this._root, i = r.uuid;
e = null !== (r = "string" == typeof e ? $r.findByName(r, e) : e) ? r.uuid : e;
var a = this._actionsByClip[e], o = null;
if (void 0 === n && (n = null !== r ? r.blendMode : 2500), void 0 !== a) {
if (void 0 !== (o = a.actionByRoot[i]) && o.blendMode === n) return o;
o = a.knownActions[0], null === r && (r = o._clip);
}
return null === r ? null : (t = new Ei(this, r, t, n), this._bindAction(t, o), this._addInactiveAction(t, e, i), 
t);
},
existingAction: function(e, t) {
var n = t || this._root;
return t = n.uuid, n = "string" == typeof e ? $r.findByName(n, e) : e, void 0 !== (e = this._actionsByClip[n ? n.uuid : e]) && e.actionByRoot[t] || null;
},
stopAllAction: function() {
for (var e = this._actions, t = this._nActiveActions - 1; 0 <= t; --t) e[t].stop();
return this;
},
update: function(e) {
e *= this.timeScale;
for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) t[o]._update(r, e, i, a);
for (e = this._bindings, t = this._nActiveBindings, n = 0; n !== t; ++n) e[n].apply(a);
return this;
},
setTime: function(e) {
for (var t = this.time = 0; t < this._actions.length; t++) this._actions[t].time = 0;
return this.update(e);
},
getRoot: function() {
return this._root;
},
uncacheClip: function(e) {
var t = this._actions;
e = e.uuid;
var n = this._actionsByClip, r = n[e];
if (void 0 !== r) {
for (var i = 0, a = (r = r.knownActions).length; i !== a; ++i) {
var o = r[i];
this._deactivateAction(o);
var s = o._cacheIndex, c = t[t.length - 1];
o._cacheIndex = null, o._byClipCacheIndex = null, c._cacheIndex = s, t[s] = c, t.pop(), 
this._removeInactiveBindingsForAction(o);
}
delete n[e];
}
},
uncacheRoot: function(e) {
e = e.uuid;
var t = this._actionsByClip;
for (r in t) {
var n = t[r].actionByRoot[e];
void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
}
var r = this._bindingsByRootAndName[e];
if (void 0 !== r) for (var i in r) (e = r[i]).restoreOriginalState(), this._removeInactiveBinding(e);
},
uncacheAction: function(e, t) {
null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e));
}
}), ki.prototype.clone = function() {
return new ki(void 0 === this.value.clone ? this.value : this.value.clone());
}, Oi.prototype = Object.assign(Object.create(_t.prototype), {
constructor: Oi,
isInstancedInterleavedBuffer: !0,
copy: function(e) {
return _t.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, 
this;
},
clone: function(e) {
return (e = _t.prototype.clone.call(this, e)).meshPerAttribute = this.meshPerAttribute, 
e;
},
toJSON: function(e) {
return (e = _t.prototype.toJSON.call(this, e)).isInstancedInterleavedBuffer = !0, 
e.meshPerAttribute = this.meshPerAttribute, e;
}
}), Object.assign(Di.prototype, {
set: function(e, t) {
this.ray.set(e, t);
},
setFromCamera: function(e, t) {
t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), 
this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), 
this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), 
this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("$3.Raycaster: Unsupported camera type.");
},
intersectObject: function(e, t, n) {
return Ii(e, this, n = n || [], t), n.sort(Ni), n;
},
intersectObjects: function(e, t, n) {
if (n = n || [], !1 === Array.isArray(e)) return console.warn("$3.Raycaster.intersectObjects: objects is not an Array."), 
n;
for (var r = 0, i = e.length; r < i; r++) Ii(e[r], this, n, t);
return n.sort(Ni), n;
}
}), Object.assign(Ri.prototype, {
set: function(e, t, n) {
return this.radius = e, this.phi = t, this.theta = n, this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
},
makeSafe: function() {
return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
},
setFromVector3: function(e) {
return this.setFromCartesianCoords(e.x, e.y, e.z);
},
setFromCartesianCoords: function(e, t, n) {
return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, n), 
this.phi = Math.acos(da.clamp(t / this.radius, -1, 1))), this;
}
}), Object.assign(ji.prototype, {
set: function(e, t, n) {
return this.radius = e, this.theta = t, this.y = n, this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
},
setFromVector3: function(e) {
return this.setFromCartesianCoords(e.x, e.y, e.z);
},
setFromCartesianCoords: function(e, t, n) {
return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, 
this;
}
});
var qc = new n();
Object.assign(Ui.prototype, {
set: function(e, t) {
return this.min.copy(e), this.max.copy(t), this;
},
setFromPoints: function(e) {
this.makeEmpty();
for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
return this;
},
setFromCenterAndSize: function(e, t) {
return t = qc.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), 
this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.min.copy(e.min), this.max.copy(e.max), this;
},
makeEmpty: function() {
return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
},
isEmpty: function() {
return this.max.x < this.min.x || this.max.y < this.min.y;
},
getCenter: function(e) {
return void 0 === e && (console.warn("$3.Box2: .getCenter() target is now required"), 
e = new n()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
},
getSize: function(e) {
return void 0 === e && (console.warn("$3.Box2: .getSize() target is now required"), 
e = new n()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
},
expandByPoint: function(e) {
return this.min.min(e), this.max.max(e), this;
},
expandByVector: function(e) {
return this.min.sub(e), this.max.add(e), this;
},
expandByScalar: function(e) {
return this.min.addScalar(-e), this.max.addScalar(e), this;
},
containsPoint: function(e) {
return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
},
containsBox: function(e) {
return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
},
getParameter: function(e, t) {
return void 0 === t && (console.warn("$3.Box2: .getParameter() target is now required"), 
t = new n()), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
},
intersectsBox: function(e) {
return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
},
clampPoint: function(e, t) {
return void 0 === t && (console.warn("$3.Box2: .clampPoint() target is now required"), 
t = new n()), t.copy(e).clamp(this.min, this.max);
},
distanceToPoint: function(e) {
return qc.copy(e).clamp(this.min, this.max).sub(e).length();
},
intersect: function(e) {
return this.min.max(e.min), this.max.min(e.max), this;
},
union: function(e) {
return this.min.min(e.min), this.max.max(e.max), this;
},
translate: function(e) {
return this.min.add(e), this.max.add(e), this;
},
equals: function(e) {
return e.min.equals(this.min) && e.max.equals(this.max);
}
});
var Hc = new l(), Xc = new l();
Object.assign(Bi.prototype, {
set: function(e, t) {
return this.start.copy(e), this.end.copy(t), this;
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(e) {
return this.start.copy(e.start), this.end.copy(e.end), this;
},
getCenter: function(e) {
return void 0 === e && (console.warn("$3.Line3: .getCenter() target is now required"), 
e = new l()), e.addVectors(this.start, this.end).multiplyScalar(.5);
},
delta: function(e) {
return void 0 === e && (console.warn("$3.Line3: .delta() target is now required"), 
e = new l()), e.subVectors(this.end, this.start);
},
distanceSq: function() {
return this.start.distanceToSquared(this.end);
},
distance: function() {
return this.start.distanceTo(this.end);
},
at: function(e, t) {
return void 0 === t && (console.warn("$3.Line3: .at() target is now required"), 
t = new l()), this.delta(t).multiplyScalar(e).add(this.start);
},
closestPointToPointParameter: function(e, t) {
return Hc.subVectors(e, this.start), Xc.subVectors(this.end, this.start), e = Xc.dot(Xc), 
e = Xc.dot(Hc) / e, t && (e = da.clamp(e, 0, 1)), e;
},
closestPointToPoint: function(e, t, n) {
return e = this.closestPointToPointParameter(e, t), void 0 === n && (console.warn("$3.Line3: .closestPointToPoint() target is now required"), 
n = new l()), this.delta(n).multiplyScalar(e).add(this.start);
},
applyMatrix4: function(e) {
return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
},
equals: function(e) {
return e.start.equals(this.start) && e.end.equals(this.end);
}
}), zi.prototype = Object.create(p.prototype), zi.prototype.constructor = zi, zi.prototype.isImmediateRenderObject = !0;
var Yc = new l();
Fi.prototype = Object.create(p.prototype), Fi.prototype.constructor = Fi, Fi.prototype.dispose = function() {
this.cone.geometry.dispose(), this.cone.material.dispose();
}, Fi.prototype.update = function() {
this.light.updateMatrixWorld();
var e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
this.cone.scale.set(t, t, e), Yc.setFromMatrixPosition(this.light.target.matrixWorld), 
this.cone.lookAt(Yc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
};
var Jc = new l(), Zc = new u(), Kc = new u();
Gi.prototype = Object.create(Nt.prototype), Gi.prototype.constructor = Gi, Gi.prototype.isSkeletonHelper = !0, 
Gi.prototype.updateMatrixWorld = function(e) {
var t = this.bones, n = this.geometry, r = n.getAttribute("position");
Kc.getInverse(this.root.matrixWorld);
for (var i = 0, a = 0; i < t.length; i++) {
var o = t[i];
o.parent && o.parent.isBone && (Zc.multiplyMatrices(Kc, o.matrixWorld), Jc.setFromMatrixPosition(Zc), 
r.setXYZ(a, Jc.x, Jc.y, Jc.z), Zc.multiplyMatrices(Kc, o.parent.matrixWorld), Jc.setFromMatrixPosition(Zc), 
r.setXYZ(a + 1, Jc.x, Jc.y, Jc.z), a += 2);
}
n.getAttribute("position").needsUpdate = !0, p.prototype.updateMatrixWorld.call(this, e);
}, Vi.prototype = Object.create(z.prototype), Vi.prototype.constructor = Vi, Vi.prototype.dispose = function() {
this.geometry.dispose(), this.material.dispose();
}, Vi.prototype.update = function() {
void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
var Qc = new l(), el = new x(), tl = new x();
Wi.prototype = Object.create(p.prototype), Wi.prototype.constructor = Wi, Wi.prototype.dispose = function() {
this.children[0].geometry.dispose(), this.children[0].material.dispose();
}, Wi.prototype.update = function() {
var e = this.children[0];
if (void 0 !== this.color) this.material.color.set(this.color); else {
var t = e.geometry.getAttribute("color");
el.copy(this.light.color), tl.copy(this.light.groundColor);
for (var n = 0, r = t.count; n < r; n++) {
var i = n < r / 2 ? el : tl;
t.setXYZ(n, i.r, i.g, i.b);
}
t.needsUpdate = !0;
}
e.lookAt(Qc.setFromMatrixPosition(this.light.matrixWorld).negate());
}, qi.prototype = Object.assign(Object.create(Nt.prototype), {
constructor: qi,
copy: function(e) {
return Nt.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), 
this;
},
clone: function() {
return new this.constructor().copy(this);
}
}), Hi.prototype = Object.create(Nt.prototype), Hi.prototype.constructor = Hi;
var nl = new l(), rl = new l(), il = new l();
Xi.prototype = Object.create(p.prototype), Xi.prototype.constructor = Xi, Xi.prototype.dispose = function() {
this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), 
this.targetLine.material.dispose();
}, Xi.prototype.update = function() {
nl.setFromMatrixPosition(this.light.matrixWorld), rl.setFromMatrixPosition(this.light.target.matrixWorld), 
il.subVectors(rl, nl), this.lightPlane.lookAt(rl), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), 
this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), 
this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(rl), 
this.targetLine.scale.z = il.length();
};
var al = new l(), ol = new X();
Yi.prototype = Object.create(Nt.prototype), Yi.prototype.constructor = Yi, Yi.prototype.update = function() {
var e = this.geometry, t = this.pointMap;
ol.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ji("c", t, e, ol, 0, 0, -1), 
Ji("t", t, e, ol, 0, 0, 1), Ji("n1", t, e, ol, -1, -1, -1), Ji("n2", t, e, ol, 1, -1, -1), 
Ji("n3", t, e, ol, -1, 1, -1), Ji("n4", t, e, ol, 1, 1, -1), Ji("f1", t, e, ol, -1, -1, 1), 
Ji("f2", t, e, ol, 1, -1, 1), Ji("f3", t, e, ol, -1, 1, 1), Ji("f4", t, e, ol, 1, 1, 1), 
Ji("u1", t, e, ol, .7, 1.1, -1), Ji("u2", t, e, ol, -.7, 1.1, -1), Ji("u3", t, e, ol, 0, 2, -1), 
Ji("cf1", t, e, ol, -1, 0, 1), Ji("cf2", t, e, ol, 1, 0, 1), Ji("cf3", t, e, ol, 0, -1, 1), 
Ji("cf4", t, e, ol, 0, 1, 1), Ji("cn1", t, e, ol, -1, 0, -1), Ji("cn2", t, e, ol, 1, 0, -1), 
Ji("cn3", t, e, ol, 0, -1, -1), Ji("cn4", t, e, ol, 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
};
var sl = new m();
Zi.prototype = Object.create(Nt.prototype), Zi.prototype.constructor = Zi, Zi.prototype.update = function(e) {
if (void 0 !== e && console.warn("$3.BoxHelper: .update() has no longer arguments."), 
void 0 !== this.object && sl.setFromObject(this.object), !sl.isEmpty()) {
e = sl.min;
var t = sl.max, n = this.geometry.attributes.position, r = n.array;
r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, 
r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, 
r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, 
r[21] = t.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
}
}, Zi.prototype.setFromObject = function(e) {
return this.object = e, this.update(), this;
}, Zi.prototype.copy = function(e) {
return Nt.prototype.copy.call(this, e), this.object = e.object, this;
}, Zi.prototype.clone = function() {
return new this.constructor().copy(this);
}, Ki.prototype = Object.create(Nt.prototype), Ki.prototype.constructor = Ki, Ki.prototype.updateMatrixWorld = function(e) {
var t = this.box;
t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), 
p.prototype.updateMatrixWorld.call(this, e));
}, Qi.prototype = Object.create(Dt.prototype), Qi.prototype.constructor = Qi, Qi.prototype.updateMatrixWorld = function(e) {
var t = -this.plane.constant;
1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), 
this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), 
p.prototype.updateMatrixWorld.call(this, e);
};
var cl, ll, ul = new l();
ea.prototype = Object.create(p.prototype), ea.prototype.constructor = ea, ea.prototype.setDirection = function(e) {
.99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > e.y ? this.quaternion.set(1, 0, 0, 0) : (ul.set(e.z, 0, -e.x).normalize(), 
this.quaternion.setFromAxisAngle(ul, Math.acos(e.y)));
}, ea.prototype.setLength = function(e, t, n) {
void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), 
this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, 
this.cone.updateMatrix();
}, ea.prototype.setColor = function(e) {
this.line.material.color.set(e), this.cone.material.color.set(e);
}, ea.prototype.copy = function(e) {
return p.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), 
this;
}, ea.prototype.clone = function() {
return new this.constructor().copy(this);
}, ta.prototype = Object.create(Nt.prototype), ta.prototype.constructor = ta;
var hl = Math.pow(2, 8), dl = [ .125, .215, .35, .446, .526, .582 ], pl = 5 + dl.length, fl = {
3000: 0,
3001: 1,
3002: 2,
3004: 3,
3005: 4,
3006: 5,
3007: 6
}, ml = new ti(), gl = function() {
for (var e = [], t = [], n = [], r = 8, i = 0; i < pl; i++) {
var a = Math.pow(2, r);
t.push(a);
var o = 1 / a;
4 < i ? o = dl[i - 8 + 4 - 1] : 0 == i && (o = 0), n.push(o);
var s = [ a = -(o = 1 / (a - 1)) / 2, a, o = 1 + o / 2, a, o, o, a, a, o, o, a, o ];
a = new Float32Array(108), o = new Float32Array(72);
for (var c = new Float32Array(36), l = 0; 6 > l; l++) {
var u = l % 3 * 2 / 3 - 1, h = 2 < l ? 0 : -1;
a.set([ u, h, 0, u + 2 / 3, h, 0, u + 2 / 3, h + 1, 0, u, h, 0, u + 2 / 3, h + 1, 0, u, h + 1, 0 ], 18 * l), 
o.set(s, 12 * l), c.set([ l, l, l, l, l, l ], 6 * l);
}
(s = new B()).setAttribute("position", new L(a, 3)), s.setAttribute("uv", new L(o, 2)), 
s.setAttribute("faceIndex", new L(c, 1)), e.push(s), 4 < r && r--;
}
return {
_lodPlanes: e,
_sizeLods: t,
_sigmas: n
};
}(), vl = gl._lodPlanes, yl = gl._sizeLods, $l = gl._sigmas, bl = null, xl = (1 + Math.sqrt(5)) / 2, wl = 1 / xl, _l = [ new l(1, 1, 1), new l(-1, 1, 1), new l(1, 1, -1), new l(-1, 1, -1), new l(0, xl, wl), new l(0, xl, -wl), new l(wl, 0, xl), new l(-wl, 0, xl), new l(xl, wl, 0), new l(-xl, wl, 0) ];
na.prototype = {
constructor: na,
fromScene: function(e, t, n, r) {
void 0 === t && (t = 0), void 0 === n && (n = .1), void 0 === r && (r = 100), bl = this._renderer.getRenderTarget();
var i = this._allocateTargets();
return this._sceneToCubeUV(e, n, r, i), 0 < t && this._blur(i, 0, 0, t), this._applyPMREM(i), 
this._cleanup(i), i;
},
fromEquirectangular: function(e) {
return e.magFilter = 1003, e.minFilter = 1003, e.generateMipmaps = !1, this.fromCubemap(e);
},
fromCubemap: function(e) {
bl = this._renderer.getRenderTarget();
var t = this._allocateTargets(e);
return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t;
},
compileCubemapShader: function() {
null === this._cubemapShader && (this._cubemapShader = oa(), this._compileMtrl(this._cubemapShader));
},
compileEquirectangularShader: function() {
null === this._equirectShader && (this._equirectShader = aa(), this._compileMtrl(this._equirectShader));
},
dispose: function() {
this._blurMtrl.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), 
null !== this._equirectShader && this._equirectShader.dispose();
for (var e = 0; e < vl.length; e++) vl[e].dispose();
},
_cleanup: function(e) {
this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(bl), e.scissorTest = !1, 
e.setSize(e.width, e.height);
},
_allocateTargets: function(e) {
var t = void 0 !== e && 1009 === e.type && (3e3 === e.encoding || 3001 === e.encoding || 3007 === e.encoding), n = ra(t = {
magFilter: 1003,
minFilter: 1003,
generateMipmaps: !1,
type: 1009,
format: 1023,
encoding: t ? e.encoding : 3002,
depthBuffer: !1,
stencilBuffer: !1
});
return n.depthBuffer = !e, this._pingPongRenderTarget = ra(t), n;
},
_compileMtrl: function(e) {
e = new z(vl[0], e), this._renderer.compile(e, ml);
},
_sceneToCubeUV: function(e, t, n, r) {
t = new Y(90, 1, t, n), n = [ 1, -1, 1, 1, 1, 1 ];
var i = [ 1, 1, 1, -1, -1, -1 ], a = this._renderer, o = a.outputEncoding, s = a.toneMapping, c = a.toneMappingExposure, l = a.getClearColor(), u = a.getClearAlpha();
a.toneMapping = 1, a.toneMappingExposure = 1, a.outputEncoding = 3e3;
var h = e.background;
if (h && h.isColor) {
h.convertSRGBToLinear();
var d = Math.min(Math.max(Math.ceil(Math.log2(Math.max(h.r, h.g, h.b))), -128), 127);
h = h.multiplyScalar(Math.pow(2, -d)), a.setClearColor(h, (d + 128) / 255), e.background = null;
}
for (h = 0; 6 > h; h++) 0 == (d = h % 3) ? (t.up.set(0, n[h], 0), t.lookAt(i[h], 0, 0)) : 1 == d ? (t.up.set(0, 0, n[h]), 
t.lookAt(0, i[h], 0)) : (t.up.set(0, n[h], 0), t.lookAt(0, 0, i[h])), ia(r, d * hl, 2 < h ? hl : 0, hl, hl), 
a.setRenderTarget(r), a.render(e, t);
a.toneMapping = s, a.toneMappingExposure = c, a.outputEncoding = o, a.setClearColor(l, u);
},
_textureToCubeUV: function(e, t) {
var n = this._renderer;
e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = oa()) : null == this._equirectShader && (this._equirectShader = aa());
var r = e.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new z(vl[0], r);
(r = r.uniforms).envMap.value = e, e.isCubeTexture || r.texelSize.value.set(1 / e.image.width, 1 / e.image.height), 
r.inputEncoding.value = fl[e.encoding], r.outputEncoding.value = fl[t.texture.encoding], 
ia(t, 0, 0, 3 * hl, 2 * hl), n.setRenderTarget(t), n.render(i, ml);
},
_applyPMREM: function(e) {
var t = this._renderer, n = t.autoClear;
t.autoClear = !1;
for (var r = 1; r < pl; r++) this._blur(e, r - 1, r, Math.sqrt($l[r] * $l[r] - $l[r - 1] * $l[r - 1]), _l[(r - 1) % _l.length]);
t.autoClear = n;
},
_blur: function(e, t, n, r, i) {
var a = this._pingPongRenderTarget;
this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i);
},
_halfBlur: function(e, t, n, r, i, a, o) {
var s = this._renderer, c = this._blurMtrl;
"latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
var l = new z(vl[r], c);
c = c.uniforms;
var u = yl[n] - 1, h = i / (u = isFinite(i) ? Math.PI / (2 * u) : 2 * Math.PI / 39), d = isFinite(i) ? 1 + Math.floor(3 * h) : 20;
20 < d && console.warn("sigmaRadians, " + i + ", is too large and will clip, as it requested " + d + " samples when the maximum is set to 20"), 
i = [];
for (var p = 0, f = 0; 20 > f; ++f) {
var m = f / h;
m = Math.exp(-m * m / 2), i.push(m), 0 == f ? p += m : f < d && (p += 2 * m);
}
for (h = 0; h < i.length; h++) i[h] /= p;
c.envMap.value = e.texture, c.samples.value = d, c.weights.value = i, c.latitudinal.value = "latitudinal" === a, 
o && (c.poleAxis.value = o), c.dTheta.value = u, c.mipInt.value = 8 - n, c.inputEncoding.value = fl[e.texture.encoding], 
c.outputEncoding.value = fl[e.texture.encoding], e = yl[r], ia(t, 3 * Math.max(0, hl - 2 * e), (0 === r ? 0 : 2 * hl) + 2 * e * (4 < r ? r - 8 + 4 : 0), 3 * e, 2 * e), 
s.setRenderTarget(t), s.render(l, ml);
}
}, Er.create = function(e, t) {
return console.log("$3.Curve.create() has been deprecated"), e.prototype = Object.create(Er.prototype), 
e.prototype.constructor = e, e.prototype.getPoint = t, e;
}, Object.assign(Wr.prototype, {
createPointsGmtr: function(e) {
return console.warn("$3.CurvePath: .createPointsGmtr() has been removed. Use new $3.Gmtr().setFromPoints( points ) instead."), 
e = this.getPoints(e), this.createGmtr(e);
},
createSpacedPointsGmtr: function(e) {
return console.warn("$3.CurvePath: .createSpacedPointsGmtr() has been removed. Use new $3.Gmtr().setFromPoints( points ) instead."), 
e = this.getSpacedPoints(e), this.createGmtr(e);
},
createGmtr: function(e) {
console.warn("$3.CurvePath: .createGmtr() has been removed. Use new $3.Gmtr().setFromPoints( points ) instead.");
for (var t = new V(), n = 0, r = e.length; n < r; n++) {
var i = e[n];
t.vertices.push(new l(i.x, i.y, i.z || 0));
}
return t;
}
}), Object.assign(qr.prototype, {
fromPoints: function(e) {
return console.warn("$3.Path: .fromPoints() has been renamed to .setFromPoints()."), 
this.setFromPoints(e);
}
}), sa.prototype = Object.create(Dr.prototype), ca.prototype = Object.create(Dr.prototype), 
la.prototype = Object.create(Dr.prototype), Object.assign(la.prototype, {
initFromArray: function() {
console.error("$3.Spline: .initFromArray() has been removed.");
},
getControlPointsArray: function() {
console.error("$3.Spline: .getControlPointsArray() has been removed.");
},
reparametrizeByArcLength: function() {
console.error("$3.Spline: .reparametrizeByArcLength() has been removed.");
}
}), qi.prototype.setColors = function() {
console.error("$3.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
}, Gi.prototype.update = function() {
console.error("$3.SkeletonHelper: update() no longer needs to be called.");
}, Object.assign(wr.prototype, {
extractUrlBase: function(e) {
return console.warn("$3.Loader: .extractUrlBase() has been deprecated. Use $3.LoaderUtils.extractUrlBase() instead."), 
xc.extractUrlBase(e);
}
}), wr.Handlers = {
add: function() {
console.error("$3.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
},
get: function() {
console.error("$3.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
}
}, Object.assign(di.prototype, {
setTexturePath: function(e) {
return console.warn("$3.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), 
this.setResourcePath(e);
}
}), Object.assign(Ui.prototype, {
center: function(e) {
return console.warn("$3.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e);
},
empty: function() {
return console.warn("$3.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
},
isIntersectionBox: function(e) {
return console.warn("$3.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), 
this.intersectsBox(e);
},
size: function(e) {
return console.warn("$3.Box2: .size() has been renamed to .getSize()."), this.getSize(e);
}
}), Object.assign(m.prototype, {
center: function(e) {
return console.warn("$3.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e);
},
empty: function() {
return console.warn("$3.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
},
isIntersectionBox: function(e) {
return console.warn("$3.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), 
this.intersectsBox(e);
},
isIntersectionSphere: function(e) {
return console.warn("$3.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
this.intersectsSphere(e);
},
size: function(e) {
return console.warn("$3.Box3: .size() has been renamed to .getSize()."), this.getSize(e);
}
}), Object.assign(v.prototype, {
empty: function() {
return console.warn("$3.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}
}), Q.prototype.setFromMatrix = function(e) {
return console.warn("$3.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), 
this.setFromProjectionMatrix(e);
}, Bi.prototype.center = function(e) {
return console.warn("$3.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e);
}, Object.assign(da, {
random16: function() {
return console.warn("$3.Math: .random16() has been deprecated. Use Math.random() instead."), 
Math.random();
},
nearestPowerOfTwo: function(e) {
return console.warn("$3.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), 
da.floorPowerOfTwo(e);
},
nextPowerOfTwo: function(e) {
return console.warn("$3.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), 
da.ceilPowerOfTwo(e);
}
}), Object.assign(r.prototype, {
flattenToArrayOffset: function(e, t) {
return console.warn("$3.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
this.toArray(e, t);
},
multiplyVector3: function(e) {
return console.warn("$3.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
e.applyMatrix3(this);
},
multiplyVector3Array: function() {
console.error("$3.Matrix3: .multiplyVector3Array() has been removed.");
},
applyToBufferAttribute: function(e) {
return console.warn("$3.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), 
e.applyMatrix3(this);
},
applyToVector3Array: function() {
console.error("$3.Matrix3: .applyToVector3Array() has been removed.");
}
}), Object.assign(u.prototype, {
extractPosition: function(e) {
return console.warn("$3.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
this.copyPosition(e);
},
flattenToArrayOffset: function(e, t) {
return console.warn("$3.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
this.toArray(e, t);
},
getPosition: function() {
return console.warn("$3.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), 
new l().setFromMatrixColumn(this, 3);
},
setRotationFromQuaternion: function(e) {
return console.warn("$3.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
this.makeRotationFromQuaternion(e);
},
multiplyToArray: function() {
console.warn("$3.Matrix4: .multiplyToArray() has been removed.");
},
multiplyVector3: function(e) {
return console.warn("$3.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
e.applyMatrix4(this);
},
multiplyVector4: function(e) {
return console.warn("$3.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
e.applyMatrix4(this);
},
multiplyVector3Array: function() {
console.error("$3.Matrix4: .multiplyVector3Array() has been removed.");
},
rotateAxis: function(e) {
console.warn("$3.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
e.transformDirection(this);
},
crossVector: function(e) {
return console.warn("$3.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
e.applyMatrix4(this);
},
translate: function() {
console.error("$3.Matrix4: .translate() has been removed.");
},
rotateX: function() {
console.error("$3.Matrix4: .rotateX() has been removed.");
},
rotateY: function() {
console.error("$3.Matrix4: .rotateY() has been removed.");
},
rotateZ: function() {
console.error("$3.Matrix4: .rotateZ() has been removed.");
},
rotateByAxis: function() {
console.error("$3.Matrix4: .rotateByAxis() has been removed.");
},
applyToBufferAttribute: function(e) {
return console.warn("$3.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), 
e.applyMatrix4(this);
},
applyToVector3Array: function() {
console.error("$3.Matrix4: .applyToVector3Array() has been removed.");
},
makeFrustum: function(e, t, n, r, i, a) {
return console.warn("$3.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), 
this.makePerspective(e, t, r, n, i, a);
}
}), $.prototype.isIntersectionLine = function(e) {
return console.warn("$3.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), 
this.intersectsLine(e);
}, c.prototype.multiplyVector3 = function(e) {
return console.warn("$3.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
e.applyQuaternion(this);
}, Object.assign(y.prototype, {
isIntersectionBox: function(e) {
return console.warn("$3.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), 
this.intersectsBox(e);
},
isIntersectionPlane: function(e) {
return console.warn("$3.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), 
this.intersectsPlane(e);
},
isIntersectionSphere: function(e) {
return console.warn("$3.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
this.intersectsSphere(e);
}
}), Object.assign(b.prototype, {
area: function() {
return console.warn("$3.Triangle: .area() has been renamed to .getArea()."), this.getArea();
},
barycoordFromPoint: function(e, t) {
return console.warn("$3.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), 
this.getBarycoord(e, t);
},
midpoint: function(e) {
return console.warn("$3.Triangle: .midpoint() has been renamed to .getMidpoint()."), 
this.getMidpoint(e);
},
normal: function(e) {
return console.warn("$3.Triangle: .normal() has been renamed to .getNormal()."), 
this.getNormal(e);
},
plane: function(e) {
return console.warn("$3.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e);
}
}), Object.assign(b, {
barycoordFromPoint: function(e, t, n, r, i) {
return console.warn("$3.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), 
b.getBarycoord(e, t, n, r, i);
},
normal: function(e, t, n, r) {
return console.warn("$3.Triangle: .normal() has been renamed to .getNormal()."), 
b.getNormal(e, t, n, r);
}
}), Object.assign(Hr.prototype, {
extractAllPoints: function(e) {
return console.warn("$3.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), 
this.extractPoints(e);
},
extrude: function(e) {
return console.warn("$3.Shape: .extrude() has been removed. Use ExtrudeGmtr() instead."), 
new En(this, e);
},
makeGmtr: function(e) {
return console.warn("$3.Shape: .makeGmtr() has been removed. Use ShapeGmtr() instead."), 
new zn(this, e);
}
}), Object.assign(n.prototype, {
fromAttribute: function(e, t, n) {
return console.warn("$3.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
this.fromBufferAttribute(e, t, n);
},
distanceToManhattan: function(e) {
return console.warn("$3.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), 
this.manhattanDistanceTo(e);
},
lengthManhattan: function() {
return console.warn("$3.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), 
this.manhattanLength();
}
}), Object.assign(l.prototype, {
setEulerFromRotationMatrix: function() {
console.error("$3.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
},
setEulerFromQuaternion: function() {
console.error("$3.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
},
getPositionFromMatrix: function(e) {
return console.warn("$3.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
this.setFromMatrixPosition(e);
},
getScaleFromMatrix: function(e) {
return console.warn("$3.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
this.setFromMatrixScale(e);
},
getColumnFromMatrix: function(e, t) {
return console.warn("$3.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
this.setFromMatrixColumn(t, e);
},
applyProjection: function(e) {
return console.warn("$3.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), 
this.applyMatrix4(e);
},
fromAttribute: function(e, t, n) {
return console.warn("$3.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
this.fromBufferAttribute(e, t, n);
},
distanceToManhattan: function(e) {
return console.warn("$3.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), 
this.manhattanDistanceTo(e);
},
lengthManhattan: function() {
return console.warn("$3.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), 
this.manhattanLength();
}
}), Object.assign(a.prototype, {
fromAttribute: function(e, t, n) {
return console.warn("$3.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
this.fromBufferAttribute(e, t, n);
},
lengthManhattan: function() {
return console.warn("$3.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), 
this.manhattanLength();
}
}), Object.assign(V.prototype, {
computeTangents: function() {
console.error("$3.Gmtr: .computeTangents() has been removed.");
},
computeLineDistances: function() {
console.error("$3.Gmtr: .computeLineDistances() has been removed. Use $3.Line.computeLineDistances() instead.");
},
applyMatrix: function(e) {
return console.warn("$3.Gmtr: .applyMatrix() has been renamed to .applyMatrix4()."), 
this.applyMatrix4(e);
}
}), Object.assign(p.prototype, {
getChildByName: function(e) {
return console.warn("$3.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
this.getObjectByName(e);
},
renderDepth: function() {
console.warn("$3.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
},
translate: function(e, t) {
return console.warn("$3.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
this.translateOnAxis(t, e);
},
getWorldRotation: function() {
console.error("$3.Object3D: .getWorldRotation() has been removed. Use $3.Object3D.getWorldQuaternion( target ) instead.");
},
applyMatrix: function(e) {
return console.warn("$3.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), 
this.applyMatrix4(e);
}
}), Object.defineProperties(p.prototype, {
eulerOrder: {
get: function() {
return console.warn("$3.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
},
set: function(e) {
console.warn("$3.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e;
}
},
useQuaternion: {
get: function() {
console.warn("$3.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
},
set: function() {
console.warn("$3.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
}
}
}), Object.assign(z.prototype, {
setDrawMode: function() {
console.error("$3.Mesh: .setDrawMode() has been removed. The renderer now always assumes $3.TrianglesDrawMode. Transform your geometry via BufferGmtrUtils.toTrianglesDrawMode() if necessary.");
}
}), Object.defineProperties(z.prototype, {
drawMode: {
get: function() {
return console.error("$3.Mesh: .drawMode has been removed. The renderer now always assumes $3.TrianglesDrawMode."), 
0;
},
set: function() {
console.error("$3.Mesh: .drawMode has been removed. The renderer now always assumes $3.TrianglesDrawMode. Transform your geometry via BufferGmtrUtils.toTrianglesDrawMode() if necessary.");
}
}
}), Object.defineProperties(Lt.prototype, {
objects: {
get: function() {
return console.warn("$3.LOD: .objects has been renamed to .levels."), this.levels;
}
}
}), Object.defineProperty(Et.prototype, "useVertexTexture", {
get: function() {
console.warn("$3.Skeleton: useVertexTexture has been removed.");
},
set: function() {
console.warn("$3.Skeleton: useVertexTexture has been removed.");
}
}), Ct.prototype.initBones = function() {
console.error("$3.SkinnedMesh: initBones() has been removed.");
}, Object.defineProperty(Er.prototype, "__arcLengthDivisions", {
get: function() {
return console.warn("$3.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), 
this.arcLengthDivisions;
},
set: function(e) {
console.warn("$3.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e;
}
}), Y.prototype.setLens = function(e, t) {
console.warn("$3.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), 
void 0 !== t && (this.filmGauge = t), this.setFocalLength(e);
}, Object.defineProperties(Xr.prototype, {
onlyShadow: {
set: function() {
console.warn("$3.Light: .onlyShadow has been removed.");
}
},
shadowCameraFov: {
set: function(e) {
console.warn("$3.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e;
}
},
shadowCameraLeft: {
set: function(e) {
console.warn("$3.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e;
}
},
shadowCameraRight: {
set: function(e) {
console.warn("$3.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e;
}
},
shadowCameraTop: {
set: function(e) {
console.warn("$3.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e;
}
},
shadowCameraBottom: {
set: function(e) {
console.warn("$3.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e;
}
},
shadowCameraNear: {
set: function(e) {
console.warn("$3.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e;
}
},
shadowCameraFar: {
set: function(e) {
console.warn("$3.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e;
}
},
shadowCameraVisible: {
set: function() {
console.warn("$3.Light: .shadowCameraVisible has been removed. Use new $3.CameraHelper( light.shadow.camera ) instead.");
}
},
shadowBias: {
set: function(e) {
console.warn("$3.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e;
}
},
shadowDarkness: {
set: function() {
console.warn("$3.Light: .shadowDarkness has been removed.");
}
},
shadowMapWidth: {
set: function(e) {
console.warn("$3.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e;
}
},
shadowMapHeight: {
set: function(e) {
console.warn("$3.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e;
}
}
}), Object.defineProperties(L.prototype, {
length: {
get: function() {
return console.warn("$3.BufferAttribute: .length has been deprecated. Use .count instead."), 
this.array.length;
}
},
dynamic: {
get: function() {
return console.warn("$3.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 
35048 === this.usage;
},
set: function() {
console.warn("$3.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 
this.setUsage(35048);
}
}
}), Object.assign(L.prototype, {
setDynamic: function(e) {
return console.warn("$3.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), 
this.setUsage(!0 === e ? 35048 : 35044), this;
},
copyIndicesArray: function() {
console.error("$3.BufferAttribute: .copyIndicesArray() has been removed.");
},
setArray: function() {
console.error("$3.BufferAttribute: .setArray has been removed. Use BufferGmtr .setAttribute to replace/resize attribute buffers");
}
}), Object.assign(B.prototype, {
addIndex: function(e) {
console.warn("$3.BufferGmtr: .addIndex() has been renamed to .setIndex()."), this.setIndex(e);
},
addAttribute: function(e, t, n) {
return console.warn("$3.BufferGmtr: .addAttribute() has been renamed to .setAttribute()."), 
t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("$3.BufferGmtr.addAttribute: Use .setIndex() for index attribute."), 
this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("$3.BufferGmtr: .addAttribute() now expects ( name, attribute )."), 
this.setAttribute(e, new L(t, n)));
},
addDrawCall: function(e, t, n) {
void 0 !== n && console.warn("$3.BufferGmtr: .addDrawCall() no longer supports indexOffset."), 
console.warn("$3.BufferGmtr: .addDrawCall() is now .addGroup()."), this.addGroup(e, t);
},
clearDrawCalls: function() {
console.warn("$3.BufferGmtr: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
},
computeTangents: function() {
console.warn("$3.BufferGmtr: .computeTangents() has been removed.");
},
computeOffsets: function() {
console.warn("$3.BufferGmtr: .computeOffsets() has been removed.");
},
removeAttribute: function(e) {
return console.warn("$3.BufferGmtr: .removeAttribute() has been renamed to .deleteAttribute()."), 
this.deleteAttribute(e);
},
applyMatrix: function(e) {
return console.warn("$3.BufferGmtr: .applyMatrix() has been renamed to .applyMatrix4()."), 
this.applyMatrix4(e);
}
}), Object.defineProperties(B.prototype, {
drawcalls: {
get: function() {
return console.error("$3.BufferGmtr: .drawcalls has been renamed to .groups."), 
this.groups;
}
},
offsets: {
get: function() {
return console.warn("$3.BufferGmtr: .offsets has been renamed to .groups."), this.groups;
}
}
}), Object.defineProperties(li.prototype, {
maxInstancedCount: {
get: function() {
return console.warn("$3.InstancedBufferGmtr: .maxInstancedCount has been renamed to .instanceCount."), 
this.instanceCount;
},
set: function(e) {
console.warn("$3.InstancedBufferGmtr: .maxInstancedCount has been renamed to .instanceCount."), 
this.instanceCount = e;
}
}
}), Object.defineProperties(Di.prototype, {
linePrecision: {
get: function() {
return console.warn("$3.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), 
this.params.Line.threshold;
},
set: function(e) {
console.warn("$3.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), 
this.params.Line.threshold = e;
}
}
}), Object.defineProperties(_t.prototype, {
dynamic: {
get: function() {
return console.warn("$3.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 
35048 === this.usage;
},
set: function(e) {
console.warn("$3.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 
this.setUsage(e);
}
}
}), Object.assign(_t.prototype, {
setDynamic: function(e) {
return console.warn("$3.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), 
this.setUsage(!0 === e ? 35048 : 35044), this;
},
setArray: function() {
console.error("$3.InterleavedBuffer: .setArray has been removed. Use BufferGmtr .setAttribute to replace/resize attribute buffers");
}
}), Object.assign(Pn.prototype, {
getArrays: function() {
console.error("$3.ExtrudeBufferGmtr: .getArrays() has been removed.");
},
addShapeList: function() {
console.error("$3.ExtrudeBufferGmtr: .addShapeList() has been removed.");
},
addShape: function() {
console.error("$3.ExtrudeBufferGmtr: .addShape() has been removed.");
}
}), Object.defineProperties(ki.prototype, {
dynamic: {
set: function() {
console.warn("$3.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
}
},
onUpdate: {
value: function() {
return console.warn("$3.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), 
this;
}
}
}), Object.defineProperties(A.prototype, {
wrapAround: {
get: function() {
console.warn("$3.Mtrl: .wrapAround has been removed.");
},
set: function() {
console.warn("$3.Mtrl: .wrapAround has been removed.");
}
},
overdraw: {
get: function() {
console.warn("$3.Mtrl: .overdraw has been removed.");
},
set: function() {
console.warn("$3.Mtrl: .overdraw has been removed.");
}
},
wrapRGB: {
get: function() {
return console.warn("$3.Mtrl: .wrapRGB has been removed."), new x();
}
},
shading: {
get: function() {
console.error("$3." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
},
set: function(e) {
console.warn("$3." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
this.flatShading = 1 === e;
}
},
stencilMask: {
get: function() {
return console.warn("$3." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), 
this.stencilFuncMask;
},
set: function(e) {
console.warn("$3." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), 
this.stencilFuncMask = e;
}
}
}), Object.defineProperties(tr.prototype, {
metal: {
get: function() {
return console.warn("$3.MeshPhongMtrl: .metal has been removed. Use $3.MeshStandardMtrl instead."), 
!1;
},
set: function() {
console.warn("$3.MeshPhongMtrl: .metal has been removed. Use $3.MeshStandardMtrl instead");
}
}
}), Object.defineProperties(H.prototype, {
derivatives: {
get: function() {
return console.warn("$3.ShaderMtrl: .derivatives has been moved to .extensions.derivatives."), 
this.extensions.derivatives;
},
set: function(e) {
console.warn("$3. ShaderMtrl: .derivatives has been moved to .extensions.derivatives."), 
this.extensions.derivatives = e;
}
}
}), Object.assign(bt.prototype, {
clearTarget: function(e, t, n, r) {
console.warn("$3.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), 
this.setRenderTarget(e), this.clear(t, n, r);
},
animate: function(e) {
console.warn("$3.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e);
},
getCurrentRenderTarget: function() {
return console.warn("$3.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), 
this.getRenderTarget();
},
getMaxAnisotropy: function() {
return console.warn("$3.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), 
this.capabilities.getMaxAnisotropy();
},
getPrecision: function() {
return console.warn("$3.WebGLRenderer: .getPrecision() is now .capabilities.precision."), 
this.capabilities.precision;
},
resetGLState: function() {
return console.warn("$3.WebGLRenderer: .resetGLState() is now .state.reset()."), 
this.state.reset();
},
supportsFloatTextures: function() {
return console.warn("$3.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), 
this.extensions.get("OES_texture_float");
},
supportsHalfFloatTextures: function() {
return console.warn("$3.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), 
this.extensions.get("OES_texture_half_float");
},
supportsStandardDerivatives: function() {
return console.warn("$3.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), 
this.extensions.get("OES_standard_derivatives");
},
supportsCompressedTextureS3TC: function() {
return console.warn("$3.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), 
this.extensions.get("WEBGL_compressed_texture_s3tc");
},
supportsCompressedTexturePVRTC: function() {
return console.warn("$3.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), 
this.extensions.get("WEBGL_compressed_texture_pvrtc");
},
supportsBlendMinMax: function() {
return console.warn("$3.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), 
this.extensions.get("EXT_blend_minmax");
},
supportsVertexTextures: function() {
return console.warn("$3.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), 
this.capabilities.vertexTextures;
},
supportsInstancedArrays: function() {
return console.warn("$3.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), 
this.extensions.get("ANGLE_instanced_arrays");
},
enableScissorTest: function(e) {
console.warn("$3.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), 
this.setScissorTest(e);
},
initMtrl: function() {
console.warn("$3.WebGLRenderer: .initMtrl() has been removed.");
},
addPrePlugin: function() {
console.warn("$3.WebGLRenderer: .addPrePlugin() has been removed.");
},
addPostPlugin: function() {
console.warn("$3.WebGLRenderer: .addPostPlugin() has been removed.");
},
updateShadowMap: function() {
console.warn("$3.WebGLRenderer: .updateShadowMap() has been removed.");
},
setFaceCulling: function() {
console.warn("$3.WebGLRenderer: .setFaceCulling() has been removed.");
},
allocTextureUnit: function() {
console.warn("$3.WebGLRenderer: .allocTextureUnit() has been removed.");
},
setTexture: function() {
console.warn("$3.WebGLRenderer: .setTexture() has been removed.");
},
setTexture2D: function() {
console.warn("$3.WebGLRenderer: .setTexture2D() has been removed.");
},
setTextureCube: function() {
console.warn("$3.WebGLRenderer: .setTextureCube() has been removed.");
},
getActiveMipMapLevel: function() {
return console.warn("$3.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), 
this.getActiveMipmapLevel();
}
}), Object.defineProperties(bt.prototype, {
shadowMapEnabled: {
get: function() {
return this.shadowMap.enabled;
},
set: function(e) {
console.warn("$3.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), 
this.shadowMap.enabled = e;
}
},
shadowMapType: {
get: function() {
return this.shadowMap.type;
},
set: function(e) {
console.warn("$3.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e;
}
},
shadowMapCullFace: {
get: function() {
console.warn("$3.WebGLRenderer: .shadowMapCullFace has been removed. Set Mtrl.shadowSide instead.");
},
set: function() {
console.warn("$3.WebGLRenderer: .shadowMapCullFace has been removed. Set Mtrl.shadowSide instead.");
}
},
context: {
get: function() {
return console.warn("$3.WebGLRenderer: .context has been removed. Use .getContext() instead."), 
this.getContext();
}
},
vr: {
get: function() {
return console.warn("$3.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
}
},
gammaInput: {
get: function() {
return console.warn("$3.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), 
!1;
},
set: function() {
console.warn("$3.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
}
},
gammaOutput: {
get: function() {
return console.warn("$3.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), 
!1;
},
set: function(e) {
console.warn("$3.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), 
this.outputEncoding = !0 === e ? 3001 : 3e3;
}
}
}), Object.defineProperties(ft.prototype, {
cullFace: {
get: function() {
console.warn("$3.WebGLRenderer: .shadowMap.cullFace has been removed. Set Mtrl.shadowSide instead.");
},
set: function() {
console.warn("$3.WebGLRenderer: .shadowMap.cullFace has been removed. Set Mtrl.shadowSide instead.");
}
},
renderReverseSided: {
get: function() {
console.warn("$3.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Mtrl.shadowSide instead.");
},
set: function() {
console.warn("$3.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Mtrl.shadowSide instead.");
}
},
renderSingleSided: {
get: function() {
console.warn("$3.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Mtrl.shadowSide instead.");
},
set: function() {
console.warn("$3.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Mtrl.shadowSide instead.");
}
}
}), Object.defineProperties(o.prototype, {
wrapS: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e;
}
},
wrapT: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e;
}
},
magFilter: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
this.texture.magFilter;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e;
}
},
minFilter: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
this.texture.minFilter;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e;
}
},
anisotropy: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
this.texture.anisotropy;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e;
}
},
offset: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e;
}
},
repeat: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e;
}
},
format: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e;
}
},
type: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e;
}
},
generateMipmaps: {
get: function() {
return console.warn("$3.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
this.texture.generateMipmaps;
},
set: function(e) {
console.warn("$3.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
this.texture.generateMipmaps = e;
}
}
}), Object.defineProperties(_i.prototype, {
load: {
value: function(e) {
console.warn("$3.Audio: .load has been deprecated. Use $3.AudioLoader instead.");
var t = this;
return new vi().load(e, function(e) {
t.setBuffer(e);
}), this;
}
},
startTime: {
set: function() {
console.warn("$3.Audio: .startTime is now .play( delay ).");
}
}
}), Si.prototype.getData = function() {
return console.warn("$3.AudioAnalyser: .getData() is now .getFrequencyData()."), 
this.getFrequencyData();
}, J.prototype.updateCubeMap = function(e, t) {
return console.warn("$3.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t);
}, fa.crossOrigin = void 0, fa.loadTexture = function(e, t, n, r) {
console.warn("$3.ImageUtils.loadTexture has been deprecated. Use $3.TextureLoader() instead.");
var i = new Cr();
return i.setCrossOrigin(this.crossOrigin), e = i.load(e, n, void 0, r), t && (e.mapping = t), 
e;
}, fa.loadTextureCube = function(e, t, n, r) {
console.warn("$3.ImageUtils.loadTextureCube has been deprecated. Use $3.CubeTextureLoader() instead.");
var i = new Lr();
return i.setCrossOrigin(this.crossOrigin), e = i.load(e, n, void 0, r), t && (e.mapping = t), 
e;
}, fa.loadCompressedTexture = function() {
console.error("$3.ImageUtils.loadCompressedTexture has been removed. Use $3.DDSLoader instead.");
}, fa.loadCompressedTextureCube = function() {
console.error("$3.ImageUtils.loadCompressedTextureCube has been removed. Use $3.DDSLoader instead.");
}, "undefined" != typeof __$3_DEVTOOLS__ && __$3_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
detail: {
revision: "118dev"
}
})), e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveAnimationBlendMode = 2501, 
e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, 
e.AmbientLight = ii, e.AmbientLightProbe = $i, e.AnimationClip = $r, e.AnimationLoader = Mr, 
e.AnimationMixer = Pi, e.AnimationObjectGroup = Ci, e.AnimationUtils = dc, e.ArcCurve = kr, 
e.ArrayCamera = gt, e.ArrowHelper = ea, e.Audio = _i, e.AudioAnalyser = Si, e.AudioContext = Tc, 
e.AudioListener = wi, e.AudioLoader = vi, e.AxesHelper = ta, e.AxisHelper = function(e) {
return console.warn("$3.AxisHelper has been renamed to $3.AxesHelper."), new ta(e);
}, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) {
return console.warn("$3.BinaryTextureLoader has been renamed to $3.DataTextureLoader."), 
new Ar(e);
}, e.Bone = Pt, e.BooleanKeyframeTrack = dr, e.BoundingBoxHelper = function(e, t) {
return console.warn("$3.BoundingBoxHelper has been deprecated. Creating a $3.BoxHelper instead."), 
new Zi(e, t);
}, e.Box2 = Ui, e.Box3 = m, e.Box3Helper = Ki, e.BoxBufferGmtr = ts, e.BoxGmtr = es, 
e.BoxHelper = Zi, e.BufferAttribute = L, e.BufferGmtr = B, e.BufferGmtrLoader = hi, 
e.ByteType = 1010, e.Cache = pc, e.Camera = X, e.CameraHelper = Yi, e.CanvasRenderer = function() {
console.error("$3.CanvasRenderer has been removed");
}, e.CanvasTexture = Ft, e.CatmullRomCurve3 = Dr, e.CineonToneMapping = 4, e.CircleBufferGmtr = Jn, 
e.CircleGmtr = Yn, e.ClampToEdgeWrapping = 1001, e.Clock = xi, e.ClosedSplineCurve3 = sa, 
e.Color = x, e.ColorKeyframeTrack = pr, e.CompressedTexture = zt, e.CompressedTextureLoader = Sr, 
e.ConeBufferGmtr = Xn, e.ConeGmtr = Hn, e.CubeCamera = J, e.CubeGmtr = es, e.CubeReflectionMapping = 301, 
e.CubeRefractionMapping = 302, e.CubeTexture = ce, e.CubeTextureLoader = Lr, e.CubeUVReflectionMapping = 306, 
e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = jr, e.CubicBezierCurve3 = Ur, 
e.CubicInterpolant = cr, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, 
e.CullFaceNone = 0, e.Curve = Er, e.CurvePath = Wr, e.CustomBlending = 5, e.CylinderBufferGmtr = qn, 
e.CylinderGmtr = Wn, e.Cylindrical = ji, e.DataTexture = K, e.DataTexture2DArray = le, 
e.DataTexture3D = ue, e.DataTextureLoader = Ar, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, 
e.DefaultLoadingManager = fc, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, 
e.DepthTexture = Gt, e.DirectionalLight = ri, e.DirectionalLightHelper = Xi, e.DirectionalLightShadow = ni, 
e.DiscreteInterpolant = ur, e.DodecahedronBufferGmtr = nn, e.DodecahedronGmtr = tn, 
e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) {
return console.warn("$3.DynamicBufferAttribute has been removed. Use new $3.BufferAttribute().setUsage( $3.DynamicDrawUsage ) instead."), 
new L(e, t).setUsage(35048);
}, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = 35048, e.DynamicReadUsage = 35049, 
e.EdgesGmtr = Vn, e.EdgesHelper = function(e, t) {
return console.warn("$3.EdgesHelper has been removed. Use $3.EdgesGmtr instead."), 
new Nt(new Vn(e.geometry), new Ot({
color: void 0 !== t ? t : 16777215
}));
}, e.EllipseCurve = Pr, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = 303, 
e.EquirectangularRefractionMapping = 304, e.Euler = h, e.EventDispatcher = t, e.ExtrudeBufferGmtr = Pn, 
e.ExtrudeGmtr = En, e.Face3 = S, e.Face4 = function(e, t, n, r, i, a, o) {
return console.warn("$3.Face4 has been removed. A $3.Face3 will be created instead."), 
new S(e, t, n, i, a, o);
}, e.FaceColors = 1, e.FileLoader = _r, e.FlatShading = 1, e.Float32Attribute = function(e, t) {
return console.warn("$3.Float32Attribute has been removed. Use new $3.Float32BufferAttribute() instead."), 
new I(e, t);
}, e.Float32BufferAttribute = I, e.Float64Attribute = function(e, t) {
return console.warn("$3.Float64Attribute has been removed. Use new $3.Float64BufferAttribute() instead."), 
new R(e, t);
}, e.Float64BufferAttribute = R, e.FloatType = 1015, e.Fog = wt, e.FogExp2 = xt, 
e.Font = mi, e.FontLoader = gi, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, 
e.FrontSide = 0, e.Frustum = Q, e.GammaEncoding = 3007, e.Gmtr = V, e.GmtrUtils = {
merge: function(e, t, n) {
if (console.warn("$3.GmtrUtils: .merge() has been moved to Gmtr. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), 
t.isMesh) {
t.matrixAutoUpdate && t.updateMatrix();
var r = t.matrix;
t = t.geometry;
}
e.merge(t, r, n);
},
center: function(e) {
return console.warn("$3.GmtrUtils: .center() has been moved to Gmtr. Use geometry.center() instead."), 
e.center();
}
}, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, 
e.GreaterStencilFunc = 516, e.GridHelper = qi, e.Group = vt, e.HalfFloatType = 1016, 
e.HemisphereLight = Yr, e.HemisphereLightHelper = Wi, e.HemisphereLightProbe = yi, 
e.IcosahedronBufferGmtr = en, e.IcosahedronGmtr = Qt, e.ImageBitmapLoader = pi, 
e.ImageLoader = Tr, e.ImageUtils = fa, e.ImmediateRenderObject = zi, e.IncrementStencilOp = 7682, 
e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = ui, e.InstancedBufferGmtr = li, 
e.InstancedInterleavedBuffer = Oi, e.InstancedMesh = kt, e.Int16Attribute = function(e, t) {
return console.warn("$3.Int16Attribute has been removed. Use new $3.Int16BufferAttribute() instead."), 
new k(e, t);
}, e.Int16BufferAttribute = k, e.Int32Attribute = function(e, t) {
return console.warn("$3.Int32Attribute has been removed. Use new $3.Int32BufferAttribute() instead."), 
new D(e, t);
}, e.Int32BufferAttribute = D, e.Int8Attribute = function(e, t) {
return console.warn("$3.Int8Attribute has been removed. Use new $3.Int8BufferAttribute() instead."), 
new C(e, t);
}, e.Int8BufferAttribute = C, e.IntType = 1013, e.InterleavedBuffer = _t, e.InterleavedBufferAttribute = Mt, 
e.Interpolant = sr, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, 
e.InvertStencilOp = 5386, e.JSONLoader = function() {
console.error("$3.JSONLoader has been removed.");
}, e.KeepStencilOp = 7680, e.KeyframeTrack = hr, e.LOD = Lt, e.LatheBufferGmtr = Bn, 
e.LatheGmtr = Un, e.Layers = d, e.LensFlare = function() {
console.error("$3.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, 
e.Light = Xr, e.LightProbe = si, e.LightShadow = Jr, e.Line = Dt, e.Line3 = Bi, 
e.LineBasicMtrl = Ot, e.LineCurve = Br, e.LineCurve3 = zr, e.LineDashedMtrl = or, 
e.LineLoop = It, e.LinePieces = 1, e.LineSegments = Nt, e.LineStrip = 0, e.LinearEncoding = 3e3, 
e.LinearFilter = 1006, e.LinearInterpolant = lr, e.LinearMipMapLinearFilter = 1008, 
e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = 1008, e.LinearMipmapNearestFilter = 1007, 
e.LinearToneMapping = 1, e.Loader = wr, e.LoaderUtils = xc, e.LoadingManager = xr, 
e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, 
e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
LEFT: 0,
MIDDLE: 1,
RIGHT: 2,
ROTATE: 0,
DOLLY: 1,
PAN: 2
}, e.Mtrl = A, e.MtrlLoader = ci, e.Math = da, e.MathUtils = da, e.Matrix3 = r, 
e.Matrix4 = u, e.MaxEquation = 104, e.Mesh = z, e.MeshBasicMtrl = T, e.MeshDepthMtrl = dt, 
e.MeshDistanceMtrl = pt, e.MeshFaceMtrl = function(e) {
return console.warn("$3.MeshFaceMtrl has been removed. Use an Array instead."), 
e;
}, e.MeshLambertMtrl = ir, e.MeshMatcapMtrl = ar, e.MeshNormalMtrl = rr, e.MeshPhongMtrl = tr, 
e.MeshPhysicalMtrl = er, e.MeshStandardMtrl = Qn, e.MeshToonMtrl = nr, e.MinEquation = 103, 
e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMtrl = function(e) {
return void 0 === e && (e = []), console.warn("$3.MultiMtrl has been removed. Use an Array instead."), 
e.isMultiMtrl = !0, e.materials = e, e.clone = function() {
return e.slice();
}, e;
}, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, 
e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = 1005, e.NearestMipmapNearestFilter = 1004, 
e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, 
e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, 
e.NumberKeyframeTrack = fr, e.Object3D = p, e.ObjectLoader = di, e.ObjectSpaceNormalMap = 1, 
e.OctahedronBufferGmtr = Kt, e.OctahedronGmtr = Zt, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, 
e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, 
e.OrthographicCamera = ti, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = na, 
e.ParametricBufferGmtr = qt, e.ParametricGmtr = Wt, e.Particle = function(e) {
return console.warn("$3.Particle has been renamed to $3.Sprite."), new At(e);
}, e.ParticleBasicMtrl = function(e) {
return console.warn("$3.ParticleBasicMtrl has been renamed to $3.PointsMtrl."), 
new Rt(e);
}, e.ParticleSystem = function(e, t) {
return console.warn("$3.ParticleSystem has been renamed to $3.Points."), new jt(e, t);
}, e.ParticleSystemMtrl = function(e) {
return console.warn("$3.ParticleSystemMtrl has been renamed to $3.PointsMtrl."), 
new Rt(e);
}, e.Path = qr, e.PerspectiveCamera = Y, e.Plane = $, e.PlaneBufferGmtr = re, e.PlaneGmtr = ne, 
e.PlaneHelper = Qi, e.PointCloud = function(e, t) {
return console.warn("$3.PointCloud has been renamed to $3.Points."), new jt(e, t);
}, e.PointCloudMtrl = function(e) {
return console.warn("$3.PointCloudMtrl has been renamed to $3.PointsMtrl."), new Rt(e);
}, e.PointLight = ei, e.PointLightHelper = Vi, e.Points = jt, e.PointsMtrl = Rt, 
e.PolarGridHelper = Hi, e.PolyhedronBufferGmtr = Xt, e.PolyhedronGmtr = Ht, e.PositionalAudio = Mi, 
e.PropertyBinding = Li, e.PropertyMixer = Ai, e.QuadraticBezierCurve = Fr, e.QuadraticBezierCurve3 = Gr, 
e.Quaternion = c, e.QuaternionKeyframeTrack = gr, e.QuaternionLinearInterpolant = mr, 
e.REVISION = "118dev", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBAIntegerFormat = 1033, 
e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, 
e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, 
e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, 
e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, 
e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, 
e.RGBA_ETC2_EAC_Format = 37496, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, 
e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, 
e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, 
e.RGBIntegerFormat = 1032, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, 
e.RGB_ETC2_Format = 37492, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, 
e.RGB_S3TC_DXT1_Format = 33776, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMtrl = Kn, 
e.Ray = y, e.Raycaster = Di, e.RectAreaLight = ai, e.RedFormat = 1028, e.RedIntegerFormat = 1029, 
e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, 
e.RingBufferGmtr = jn, e.RingGmtr = Rn, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, 
e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, 
e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, 
e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, 
e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, 
e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, 
e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, 
e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = f, e.SceneUtils = {
createMultiMtrlObject: function() {
console.error("$3.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
},
detach: function() {
console.error("$3.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
},
attach: function() {
console.error("$3.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
}
}, e.ShaderChunk = os, e.ShaderLib = ss, e.ShaderMtrl = H, e.ShadowMtrl = Zn, e.Shape = Hr, 
e.ShapeBufferGmtr = Fn, e.ShapeGmtr = zn, e.ShapePath = fi, e.ShapeUtils = cc, e.ShortType = 1011, 
e.Skeleton = Et, e.SkeletonHelper = Gi, e.SkinnedMesh = Ct, e.SmoothShading = 2, 
e.Sphere = v, e.SphereBufferGmtr = In, e.SphereGmtr = Nn, e.Spherical = Ri, e.SphericalHarmonics3 = oi, 
e.Spline = la, e.SplineCurve = Vr, e.SplineCurve3 = ca, e.SpotLight = Kr, e.SpotLightHelper = Fi, 
e.SpotLightShadow = Zr, e.Sprite = At, e.SpriteMtrl = St, e.SrcAlphaFactor = 204, 
e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, 
e.StaticDrawUsage = 35044, e.StaticReadUsage = 35045, e.StereoCamera = bi, e.StreamCopyUsage = 35042, 
e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = vr, 
e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = {
ROTATE: 0,
PAN: 1,
DOLLY_PAN: 2,
DOLLY_ROTATE: 3
}, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGmtr = Jt, e.TetrahedronGmtr = Yt, 
e.TextBufferGmtr = Dn, e.TextGmtr = On, e.Texture = i, e.TextureLoader = Cr, e.TorusBufferGmtr = ln, 
e.TorusGmtr = cn, e.TorusKnotBufferGmtr = sn, e.TorusKnotGmtr = on, e.Triangle = b, 
e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, 
e.TubeBufferGmtr = an, e.TubeGmtr = rn, e.UVMapping = 300, e.Uint16Attribute = function(e, t) {
return console.warn("$3.Uint16Attribute has been removed. Use new $3.Uint16BufferAttribute() instead."), 
new O(e, t);
}, e.Uint16BufferAttribute = O, e.Uint32Attribute = function(e, t) {
return console.warn("$3.Uint32Attribute has been removed. Use new $3.Uint32BufferAttribute() instead."), 
new N(e, t);
}, e.Uint32BufferAttribute = N, e.Uint8Attribute = function(e, t) {
return console.warn("$3.Uint8Attribute has been removed. Use new $3.Uint8BufferAttribute() instead."), 
new E(e, t);
}, e.Uint8BufferAttribute = E, e.Uint8ClampedAttribute = function(e, t) {
return console.warn("$3.Uint8ClampedAttribute has been removed. Use new $3.Uint8ClampedBufferAttribute() instead."), 
new P(e, t);
}, e.Uint8ClampedBufferAttribute = P, e.Uncharted2ToneMapping = 3, e.Uniform = ki, 
e.UniformsLib = as, e.UniformsUtils = ns, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, 
e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, 
e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.VSMShadowMap = 3, e.Vector2 = n, 
e.Vector3 = l, e.Vector4 = a, e.VectorKeyframeTrack = yr, e.Vertex = function(e, t, n) {
return console.warn("$3.Vertex has been removed. Use $3.Vector3 instead."), new l(e, t, n);
}, e.VertexColors = 2, e.VideoTexture = Bt, e.WebGLCubeRenderTarget = Z, e.WebGLMultisampleRenderTarget = s, 
e.WebGLRenderTarget = o, e.WebGLRenderTargetCube = function(e, t, n) {
return console.warn("$3.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), 
new Z(e, n);
}, e.WebGLRenderer = bt, e.WebGLUtils = mt, e.WireframeGmtr = Vt, e.WireframeHelper = function(e, t) {
return console.warn("$3.WireframeHelper has been removed. Use $3.WireframeGmtr instead."), 
new Nt(new Vt(e.geometry), new Ot({
color: void 0 !== t ? t : 16777215
}));
}, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) {
return console.warn("$3.XHRLoader has been renamed to $3.FileLoader."), new _r(e);
}, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.ZeroStencilOp = 0, 
e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", {
value: !0
});
}), String.prototype.repeat = function(e) {
if (e < 1) return "";
for (var t = "", n = this.valueOf(); e > 1; ) 1 & e && (t += n), e >>>= 1, n += n;
return t + n;
};

var PROFANE_WORDS = "ahole,anal,analprobe,anilingus,anus,areola,areole,arian,aryan,ass,assbang,assbang,assfuck,assfucker,asshat,asshole,assmaster,assmunch,asswipe,asswipes,azazel,azz,babe,babes,balsack,bang,banger,barf,bastard,bawdy,beaner,beardedclam,beastiality,beatch,beater,beaver,beer,beeyotch,beotch,biatch,bigtit,bimbo,bitch,blow,blowjob,bodily,boink,bolock,bolok,bone,boner,bong,boob,boobie,booger,bookie,bootee,bootie,booty,booze,boozer,boozy,bosom,bosomy,bowel,brassiere,bugger,bukake,bulshit,bulturd,bung,busty,butt,butfuck,butfucker,butfucker,butplug,caca,cahone,cameltoe,carpetmuncher,cawk,cervix,chinc,chink,chink,chode,climax,clit,clitoris,clitorus,clits,clity,cocain,cocaine,cock,cockblock,cockholster,cocknocker,cocksmoker,cocksucker,coital,comie,condom,coon,corksucker,crack,cracker,crackwhore,crap,crapy,cum,cumin,cuming,cumshot,cumslut,cumstain,cunilingus,cunilingus,cunny,cunt,cuntface,cunthunter,cuntlick,cuntlicker,dago,damit,damn,damnit,dawgiestyle,dick,dickbag,dickdiper,dickface,dickfliper,dickhead,dickish,dickriper,dicksiper,dickweed,dickwhiper,dickziper,didle,dike,dildo,diligaf,dilweed,dimwit,dingle,dipship,dogiestyle,dogystyle,dong,doofus,doosh,dopey,douche,douchebag,douchey,drunk,dumass,dumbass,dyck,dyke,ejaculate,enlargement,erect,erection,erotic,essohbe,extacy,extasy,fack,fag,faged,fagit,fagot,fagot,faig,faigt,fanybandit,fart,fartknocker,felch,felcher,felching,felate,felatio,feltch,feltcher,fisted,fisting,fisty,floozy,foad,fondle,foobar,foreskin,freex,frig,friga,fubar,fuck,fuckass,fucker,fuckface,fuckin,fucking,fucknuget,fucknut,fuckof,fucktard,fuckup,fuckwad,fuckwit,fudgepacker,fuk,fvck,fxck,gae,gÃ¦,ganja,gay,gey,gfy,ghay,ghey,gigolo,glans,goatse,godamn,godamnit,godam,godamit,godamn,goldenshower,gonad,gonads,gook,gringo,gspot,gtfo,guido,handjob,hardon,hebe,heeb,hemp,heroin,herp,herpes,herpy,hitler,hiv,hobag,homey,homo,homoey,honky,hooch,hookah,hooker,hoor,hootch,hooter,horny,hump,humping,hussy,hymen,inbred,incest,injun,jackass,jackhole,jackof,jerk,jerkof,jism,jiz,jizm,junkie,junky,jesusloves,kike,kill,kinky,kkk,klan,knobend,kooch,kootch,kraut,kyke,labia,lech,leper,lesbian,lesbo,lesbo,lez,lezbian,lezbian,lezbo,lezbo,lezie,lezy,lgbt,lgbtq,lmfao,loin,lube,lusty,massa,masterbate,masterbating,masterbation,masturbate,masturbating,masturbation,menses,menstruate,menstruation,milf,mofo,molest,moolie,moron,motherfucka,motherfucker,motherfucking,mtherfucker,mthrfucker,mthrfucking,muff,mufdiver,murder,muthafuckaz,muthafucker,mutherfucker,mutherfucking,muthrfucking,naked,napalm,nappy,nazi,nazism,negro,niga,nigah,nigaz,niger,nigers,nigle,niglet,nimrod,ninny,niple,nooky,nympho,opiate,opium,oral,orally,organ,orgasm,orgasmic,orgie,orgy,ovary,ovum,paddy,paki,pantie,panty,pastie,pasty,pcp,pecker,pedo,pedophile,pedophilia,pedophiliac,pee,peepee,penetrate,penetration,penial,penile,penis,perversion,peyote,phali,phalic,phuck,pilowbiter,pinko,piss,polack,polock,poon,poontang,poo,porn,pot,potty,prick,prig,prostitute,prude,pube,pubic,pubis,punkass,punky,puss,pussies,pussy,pussypounder,puto,queaf,queef,queef,queer,quero,quicky,quim,racy,rape,rapist,raunch,rectal,rectum,rectus,reefer,reich,retard,revue,rimjob,ritard,rtard,rumpramer,ruski,sadism,sadist,scag,scantily,schizo,schlong,screw,scrog,scrot,scrote,scrotum,scrud,scum,seaman,seamen,seduce,semen,sex,sexual,hamedame,shit,shite,shiteater,shitface,shithead,shithole,shithouse,shiz,sissy,skag,skank,sleaze,sleazy,slut,slutdumper,slutkis,smegma,smut,smutty,snatch,snuf,sodom,souse,sperm,spic,spick,spik,spooge,spunk,steamy,stfu,stify,stoned,strip,stroke,stupid,suck,sucking,sucker,sumofabiatch,tampon,tard,tawdry,teabaging,teat,teste,testes,testicle,testis,thrust,thug,tinkle,tit,titi,tits,titie,tity,toke,toots,transsexual,tubgirl,turd,tush,twat,undie,unwed,urinal,urine,uterus,uzi,vagina,valium,viagra,vixen,vodka,vomit,voyeur,vulva,wang,wank,wanker,wazoo,wedgie,weed,weenie,weewee,weiner,weirdo,wench,wetback,whitey,whiz,whoralicious,whore,whoring,wigger,womb,woody,wop,wtf,xrated,xxx,yeasty,yobo,zoophile,putin,rusia,soviet,trump", PROFANE_WORDS2 = "blya,suka,syka,Ð±Ð»ÑÐ´Ñ,Ð±Ð»Ñ,Ð±Ð»ÑÐ´,Ð±Ð»ÑÑ,roÐ½Ð´oÐ½,raÐ½Ð´oÐ½,cyÑk,Ð¿Ð¸Ð´ap,Ð¿eÐ´Ð¸k,eÐ±aÑ,eÐ±aÐ½,eÐ±ap,eÐ±Ð¸c,eÐ±aÐ»a,eÐ±aÐ»,eÐ±Ð¸,Ð¿Ð¸Ð·Ð´a,oxyÐ¸,oxye,Ð¶oÐ¿a,Ð´poÑ,Ð´poÑep,Ð¼aÐ½Ð´a,Ð¿Ð¸cÑka,Ð¿Ð¸cÑ,Ð²arÐ¸Ð½,cÑkyÐ½,cÑÑkyÐ½,cÑy,cÑÑ,ccÑk,Ð»ox,Ð»oÑap,roÐ²Ð½o,raÐ²Ð½o,Ð´epÑÐ¼o,yeÐ±k,yeÐ±ok,yeÐ±Ð¸,xep,xpeÐ½,xyÐ¸,xyÐ»Ð¸,Ð¿Ð¸Ð·Ð´eÑ,cpaÐ½Ñ,cpaÑ,cyka,Ð¿Ð¸Ð·Ð´a,Ð¿Ð¸cÐ´a,Ð¿yÑÐ¸Ð½,pocÐ¸Ñ", PROFANE_SYMS = "å\nð\nð\nð\nð¥\nð¤®\nâ®", GAP_FILTER = new RegExp("[^\\p{L}0135$Â§!â¼ââï¸ï¹ï¼|Â¥ÃËËË¥Ë©ËªË¯Ë°Ë³Ë¹-Ë¼Ë¾×Ù¡Ù¥Ù§Û±ÛµÛ·ßà¥¦à§¦à©¦à«¦à­¦à¯¦à°à±¦à²à³¦à´àµ¦à¶à¹à»áá­á®â®â â¤â©â¬-â°â´â¹â¼-â¾â£â¨âªâ¤âââ¿â³â´âºâ½â-â©â³ââ¤«â¤¬â¨¯ãï¿¥ï¿¨ðµð ð¢ðð£ ð£¥ð£¦ð£©ð£¬ð£¯ð£²ððððªððððð¢ð£ð¬ð­ð¶ð·ð£ððððððððððððððððð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨ð©ð°ð±ð²ð³ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ððððððððððððððððððððððððððð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨ð©ð°ð±ð²ð³ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ðððððððððððð¨ð¯°ð¯±]", "u"), PROFANE_FILTERS = Array.of(new RegExp(PROFANE_WORDS.split(",").sort(function(e, t) {
return t.length - e.length;
}).map(function(e) {
return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&").split("").map(function(e, t, n) {
return ({
i: "[il]"
}[e] || e) + (0 === t || t === n.length - 1 ? "" : "+");
}).join("");
}).join("|") + "|" + PROFANE_SYMS.split("\n").join("|"), "igu"), new RegExp(PROFANE_WORDS2.split(",").sort(function(e, t) {
return t.length - e.length;
}).join("|"), "igu")), SYM_MAPS = function(e) {
for (var t = new Array(), n = 0; n < 2; ++n) {
for (var r = ("A:1f110:1f130:1f150:1f170:24b6:ff21:1d400:1d434:1d468:1d49c:1d4d0:1d504:1d538:1d56c:1d5a0:1d5d4:1d608:1d63c:1d670:0391:1d6a8:1d6e2:1d71c:1d756:1d790:0410:13aa:15c5:a4ee:16f40:102a0:1d2c:1d00:01cd:01de:01e0:01fa:0200:0202:0226:023a;B:1f111:1f131:1f151:1f171:24b7:ff22:212c:1d401:1d435:1d469:1d4d1:1d505:1d539:1d56d:1d5a1:1d5d5:1d609:1d63d:1d671:a7b4:0392:1d6a9:1d6e3:1d71d:1d757:1d791:0412:13f4:15f7:a4d0:10282:102a1:10301:1d2e:1d2f:1d03:0402:0299:0181:0183:0243;C:1f112:1f132:1f152:1f172:24b8:1f74c:118f2:118e9:ff23:216d:2102:212d:1d402:1d436:1d46a:1d49e:1d4d2:1d56e:1d5a2:1d5d6:1d60a:1d63e:1d672:03f9:2ca4:0421:13df:a4da:102a2:10302:10415:1051c:1d04:0297:0187:023b;D:1f113:1f133:1f153:1f173:24b9:216e:2145:1d403:1d437:1d46b:1d49f:1d4d3:1d507:1d53b:1d56f:1d5a3:1d5d7:1d60b:1d63f:1d673:13a0:15de:15ea:a4d3:1d30:1d05:1d06:0189:018a;E:1f114:1f134:1f154:1f174:24ba:22ff:ff25:2130:1d404:1d438:1d46c:1d4d4:1d508:1d53c:1d570:1d5a4:1d5d8:1d60c:1d640:1d674:0395:1d6ac:1d6e6:1d720:1d75a:1d794:0415:2d39:13ac:a4f0:118a6:118ae:10286:1d31:1d32:1d07:1d08:0400:0401:0404:018e:01b8:01b9:0204:0206:0228:0246;F:1f115:1f135:1f155:1f175:24bb:1d213:2131:1d405:1d439:1d46d:1d4d5:1d509:1d53d:1d571:1d5a5:1d5d9:1d60d:1d641:1d675:a798:03dc:1d7ca:15b4:a4dd:118c2:118a2:10287:102a5:10525:0492:0191;G:1f116:1f136:1f156:1f176:24bc:1d406:1d43a:1d46e:1d4a2:1d4d6:1d50a:1d53e:1d572:1d5a6:1d5da:1d60e:1d642:1d676:050c:13c0:13f3:a4d6:1d33:0262:029b:0193:01e4:01d6:01f4;H:1f117:1f137:1f157:1f177:24bd:ff28:210b:210c:210d:1d407:1d43b:1d46f:1d4d7:1d573:1d5a7:1d5db:1d60f:1d643:1d677:0397:1d6ae:1d6e8:1d722:1d75c:1d796:2c8e:041d:13bb:157c:a4e7:102cf:1d34:1d78:029c:021e;I:1f118:1f138:1f158:1f178:24be:1d35:1d09:0197:01cf:0208:020a;J:1f119:1f139:1f159:1f179:24bf:ff2a:1d409:1d43d:1d471:1d4a5:1d4d9:1d50d:1d541:1d575:1d5a9:1d5dd:1d611:1d645:1d679:a7b2:037f:0408:13ab:148d:a4d9:1d36:1d0a:0248;K:1f11a:1f13a:1f15a:1f17a:24c0:212a:ff2b:1d40a:1d43e:1d472:1d4a6:1d4da:1d50e:1d542:1d576:1d5aa:1d5de:1d612:1d646:1d67a:039a:1d6b1:1d6eb:1d725:1d75f:1d799:2c94:041a:13e6:16d5:a4d7:10518:1d37:1d0d:0198:01e8;L:1f11b:1f13b:1f15b:1f17b:24c1:1d22a:216c:2112:1d40b:1d43f:1d473:1d4db:1d50f:1d543:1d577:1d5ab:1d5df:1d613:1d647:1d67b:2cd0:13de:14aa:a4e1:16f16:118a3:118b2:1041b:10526:1d38:1d0c:02e5:02e9:02ea:02f9:02fa:02fb:02fc:02fe:029f:023d;M:1f11c:1f13c:1f15c:1f17c:24c2:ff2d:216f:2133:1d40c:1d440:1d474:1d4dc:1d510:1d544:1d578:1d5ac:1d5e0:1d614:1d648:1d67c:039c:1d6b3:1d6ed:1d727:1d761:1d79b:03fa:2c98:041c:13b7:15f0:16d6:a4df:102b0:10311:1d0d:1d39;N:1f11d:1f13d:1f15d:1f17d:24c3:ff2e:2115:1d40d:1d441:1d475:1d4a9:1d4dd:1d511:1d579:1d5ad:1d5e1:1d615:1d649:1d67d:039d:1d6b4:1d6ee:1d728:1d762:1d79c:2c9a:a4e0:10513:1d0e:1d3a:1d3b:0274:019d:01f8;O:1f11e:1f13e:1f15e:1f17e:24c4:30:07c0:09e6:0b66:3007:114d0:118e0:1d7ce:1d7d8:1d7e2:1d7ec:1d7f6:1fbf0:ff2f:1d40e:1d442:1d476:1d4aa:1d4de:1d512:1d546:1d57a:1d5ae:1d5e2:1d616:1d64a:1d67e:039f:1d6b6:1d6f0:1d72a:1d764:1d79e:2c9e:041e:0555:2d54:12d0:0b20:104c2:a4f3:118b5:10292:102ab:10404:10516:1d0f:1d10:1d3c:0278:0298:019f:01a0:01d1:01ea:01ec:01fe:020c:020e:022a:022c:022e:0230;P:1f11f:1f13f:1f15f:1f17f:24c5:ff30:2119:1d40f:1d443:1d477:1d4ab:1d4df:1d513:1d57b:1d5af:1d5e3:1d617:1d64b:1d67f:03a1:1d6b8:1d6f2:1d72c:1d766:1d7a0:2ca2:0420:13e2:146d:a4d1:10295:1d18:1d29:1d3e:01a4;Q:1f120:1f140:1f160:1f180:24c6:211a:1d410:1d444:1d478:1d4ac:1d4e0:1d514:1d57c:1d5b0:1d5e4:1d618:1d64c:1d680:2d55;R:1f121:1f141:1f161:1f181:24c7:1d216:211b:211c:211d:1d411:1d445:1d479:1d4e1:1d57d:1d5b1:1d5e5:1d619:1d64d:1d681:01a6:13a1:13d2:104b4:1587:a4e3:16f35:1d19:1d1a:1d3f:02b6:0280:0281:0210:0212:024c;S:1f122:1f142:1f162:1f182:24c8:ff33:1d412:1d446:1d47a:1d4ae:1d4e2:1d516:1d54a:1d57e:1d5b2:1d5e6:1d61a:1d64e:1d682:0405:054f:13d5:13da:a4e2:16f3a:10296:10420:0282:01a7:0218:24:a7;T:1f123:1f143:1f163:1f183:24c9:22a4:27d9:1f768:ff34:1d413:1d447:1d47b:1d4af:1d4e3:1d517:1d54b:1d57f:1d5b3:1d5e7:1d61b:1d64f:1d683:03a4:1d6bb:1d6f5:1d72f:1d769:1d7a3:2ca6:0422:13a2:a4d4:16f0a:118bc:10297:102b1:10315:1d1b:1d40:01ac:01ae:021a:023e;U:1f124:1f144:1f164:1f184:24ca:222a:22c3:1d414:1d448:1d47c:1d4b0:1d4e4:1d518:1d54c:1d580:1d5b4:1d5e8:1d61c:1d650:1d684:054d:1200:104ce:144c:a4f4:16f42:118b8:1d1c:1d1d:1d1e:1d41:01af:01b1:01b2:01d3:01d6:01d7:01d9:01db:0214:0216:0244;V:1f125:1f145:1f165:1f185:24cb:1d20d:0667:06f7:2164:1d415:1d449:1d47d:1d4b1:1d4e5:1d519:1d54d:1d581:1d5b5:1d5e9:1d61d:1d651:1d685:0474:2d38:13d9:142f:a6df:a4e6:16f08:118a0:1051d:1d20:0245;W:1f126:1f146:1f166:1f186:24cc:118ef:118e6:1d416:1d44a:1d47e:1d4b2:1d4e6:1d51a:1d54e:1d582:1d5b6:1d5ea:1d61e:1d652:1d686:051c:13b3:13d4:a4ea:1d21:1d42;X:1f127:1f147:1f167:1f187:24cd:166d:2573:10322:118ec:ff38:2169:1d417:1d44b:1d47f:1d4b3:1d4e7:1d51b:1d54f:1d583:1d5b7:1d5eb:1d61f:1d653:1d687:a7b3:03a7:1d6be:1d6f8:1d732:1d76c:1d7a6:2cac:0425:2d5d:16b7:a4eb:10290:102b4:10317:10527;Y:1f128:1f148:1f168:1f188:24ce:ff39:1d418:1d44c:1d480:1d4b4:1d4e8:1d51c:1d550:1d584:1d5b8:1d5ec:1d620:1d654:1d688:03a5:03d2:1d6bc:1d6f6:1d730:1d76a:1d7a4:2ca8:0423:04ae:13a9:13bd:a4ec:16f43:118a4:102b2:a5:ffe5:01b3:0232:024e;Z:1f129:1f149:1f169:1f189:24cf:102f5:118e5:ff3a:2124:2128:1d419:1d44d:1d481:1d4b5:1d4e9:1d585:1d5b9:1d5ed:1d621:1d655:1d689:0396:1d6ad:1d6e7:1d721:1d75b:1d795:13c3:a4dc:118a9:1d22:01b5:0224:0240;a:24d0:249c:237a:ff41:1d41a:1d44e:1d482:1d4b6:1d4ea:1d51e:1d552:1d586:1d5ba:1d5ee:1d622:1d656:1d68a:0251:03b1:1d6c2:1d6fc:1d736:1d770:1d7aa:0430:1d43:1d44:1d45:1d46:2090:0250:0252:01ce:01df:01e1:01fb:0201:0203:0227;b:24d1:249d:1d41b:1d44f:1d483:1d4b7:1d4eb:1d51f:1d553:1d587:1d5bb:1d5ef:1d623:1d657:1d68b:0184:042c:13cf:1472:15af:1d47:1d5d:1d66:1d6c:0253:025e:0180:0185;c:24d2:249e:ff43:217d:1d41c:1d450:1d484:1d4b8:1d4ec:1d520:1d554:1d588:1d5bc:1d5f0:1d624:1d658:1d68c:1d04:03f2:2ca5:0441:abaf:1043d:0254:0255:0188:023c;d:24d3:249f:217e:2146:1d41d:1d451:1d485:1d4b9:1d4ed:1d521:1d555:1d589:1d5bd:1d5f1:1d625:1d659:1d68d:0501:13e7:146f:a4d2:1d48:1d5f:1d6d:0256:0257:02a0:018c:0221;e:24d4:24a0:33:212e:ff45:212f:2147:1d41e:1d452:1d486:1d4ee:1d522:1d556:1d58a:1d5be:1d5f2:1d626:1d65a:1d68e:ab32:0435:04bd:1d49:1d4a:1d4b:1d4c:2091:0258:0259:025a:025b:025c:025d:0292:0293:029a:018f:0190:01dd:0205:0207:0229:0247;f:24d5:24a1:1d41f:1d453:1d487:1d4bb:1d4ef:1d523:1d557:1d58b:1d5bf:1d5f3:1d627:1d65b:1d68f:ab35:a799:017f:1e9d:0584:1d6e:1d73:0493:0284:0192:01ad;g:24d6:24a2:ff47:210a:1d420:1d454:1d488:1d4f0:1d524:1d558:1d58c:1d5c0:1d5f4:1d628:1d65c:1d690:0261:1d83:018d:0581:1d4d:1d77:0260:01e5:01d7:01f5;h:24d7:24a3:ff48:210e:1d421:1d489:1d4bd:1d4f1:1d525:1d559:1d58d:1d5c1:1d5f5:1d629:1d65d:1d691:04bb:0570:13c2:2095:02b0:02b1:0265:0266:0267:02ae:02af:021f;i:24d8:24a4:31:02db:2373:ff49:2170:2139:2148:1d422:1d456:1d48a:1d4be:1d4f2:1d526:1d55a:1d58e:1d5c2:1d5f6:1d62a:1d65e:1d692:0131:1d6a4:026a:0269:03b9:1fbe:037a:1d6ca:1d704:1d73e:1d778:1d7b2:0456:a647:04cf:ab75:13a5:118c3:1d62:1d7c:2071:0268:01d0:0209:020b:21:203c:2048:2049:fe15:fe57:ff01;j:24d9:24a5:ff4a:2149:1d423:1d457:1d48b:1d4bf:1d4f3:1d527:1d55b:1d58f:1d5c3:1d5f7:1d62b:1d65f:1d693:03f3:0458:02b2:029d:01f0:0237:0249;k:24da:24a6:43a:1d424:1d458:1d48c:1d4c0:1d4f4:1d528:1d55c:1d590:1d5c4:1d5f8:1d62c:1d660:1d694:1d4f:2096:029e:0199:01e9;l:24db:24a7:05c0:7c:2223:23fd:ffe8:31:0661:06f1:10320:1e8c7:1d7cf:1d7d9:1d7e3:1d7ed:1d7f7:1fbf1:49:ff29:2160:2110:2111:1d408:1d43c:1d470:1d4d8:1d540:1d574:1d5a8:1d5dc:1d610:1d644:1d678:0196:ff4c:217c:2113:1d425:1d459:1d48d:1d4c1:1d4f5:1d529:1d55d:1d591:1d5c5:1d5f9:1d62d:1d661:1d695:01c0:0399:1d6b0:1d6ea:1d724:1d75e:1d798:2c92:0406:04c0:05d5:05df:0627:1ee00:1ee80:fe8e:fe8d:07ca:2d4f:16c1:a4f2:16f28:1028a:10309:1d4e:2097:02e1:026b:026c:026d:0283:0285:0286:019a:01aa:01c2:01c3:0234;m:24dd:24a9:1d50:1d6f:2098:0270:0271:019c;n:24dc:24a8:1d427:1d45b:1d48f:1d4c3:1d4f7:1d52b:1d55f:1d593:1d5c7:1d5fb:1d62f:1d663:1d697:0578:057c:1d51:1d70:207f:2099:0272:0273:0289:019e:01f9:0220:0235;o:24de:24aa:30:0c02:0c82:0d02:0d82:0966:0a66:0ae6:0be6:0c66:0ce6:0d66:0e50:0ed0:1040:0665:06f5:ff4f:2134:1d428:1d45c:1d490:1d4f8:1d52c:1d560:1d594:1d5c8:1d5fc:1d630:1d664:1d698:1d0f:1d11:ab3d:03bf:1d6d0:1d70a:1d744:1d77e:1d7b8:03c3:1d6d4:1d70e:1d748:1d782:1d7bc:2c9f:043e:10ff:0585:05e1:0647:1ee24:1ee64:1ee84:feeb:feec:feea:fee9:06be:fbac:fbad:fbab:fbaa:06c1:fba8:fba9:fba7:fba6:06d5:0d20:101d:104ea:118c8:118d7:1042c:1d11:1d12:1d13:1d52:1d53:2092:2094:02da:02f3:0275:01a1:01d2:01eb:01ed:020d:020f:022b:022d:022f:0231;p:24df:24ab:2374:ff50:1d429:1d45d:1d491:1d4c5:1d4f9:1d52d:1d561:1d595:1d5c9:1d5fd:1d631:1d665:1d699:03c1:03f1:1d6d2:1d6e0:1d70c:1d71a:1d746:1d754:1d780:1d78e:1d7ba:1d7c8:2ca3:0440:1d56:1d68:1d71:1d7d:209a:01a5:01bf:01f7;q:24e0:24ac:1d42a:1d45e:1d492:1d4c6:1d4fa:1d52e:1d562:1d596:1d5ca:1d5fe:1d632:1d666:1d69a:051b:0563:0566:024a:024b;r:24e1:24ad:1d42b:1d45f:1d493:1d4c7:1d4fb:1d52f:1d563:1d597:1d5cb:1d5ff:1d633:1d667:1d69b:ab47:ab48:1d26:2c85:0433:ab81:1d26:1d63:1d72:0403:02b3:02b4:02b5:0279:027a:027b:027c:027d:027e:027f:0211:0213:024d;s:24e2:24ae:35:ff53:1d42c:1d460:1d494:1d4c8:1d4fc:1d530:1d564:1d598:1d5cc:1d600:1d634:1d668:1d69c:a731:01bd:0455:abaa:118c1:10448:1d74:209b:02e2:01a8:0219:023f;t:24e3:24af:1d42d:1d461:1d495:1d4c9:1d4fd:1d531:1d565:1d599:1d5cd:1d601:1d635:1d669:1d69d:1d57:1d75:209c:025f:0287:0288:01ab:01be:021b:0236;u:24e4:24b0:1d42e:1d462:1d496:1d4ca:1d4fe:1d532:1d566:1d59a:1d5ce:1d602:1d636:1d66a:1d69e:a79f:1d1c:ab4e:ab52:028b:03c5:1d6d6:1d710:1d74a:1d784:1d7be:057d:104f6:118d8:1d58:1d59:1d64:1d7e:1d7f:028a:01b0:01d4:01d6:01d8:01da:01dc:0215:0217;v:24e5:24b1:2228:22c1:ff56:2174:1d42f:1d463:1d497:1d4cb:1d4ff:1d533:1d567:1d59b:1d5cf:1d603:1d637:1d66b:1d69f:1d20:03bd:1d6ce:1d708:1d742:1d77c:1d7b6:0475:05d8:11706:aba9:118c0:1d5b:1d65:02ec:02ef:02f0:028c;w:24e6:24b2:026f:1d430:1d464:1d498:1d4cc:1d500:1d534:1d568:1d59c:1d5d0:1d604:1d638:1d66c:1d6a0:1d21:0461:051d:0561:1170a:1170e:1170f:ab83:02b7:028d:02ac;x:24e7:24b3:166e:d7:292b:292c:2a2f:ff58:2179:1d431:1d465:1d499:1d4cd:1d501:1d535:1d569:1d59d:1d5d1:1d605:1d639:1d66d:1d6a1:0445:1541:157d:1d61:1d6a:2093:02e3;y:24e8:24b4:0263:1d8c:ff59:1d432:1d466:1d49a:1d4ce:1d502:1d536:1d56a:1d59e:1d5d2:1d606:1d63a:1d66e:1d6a2:028f:1eff:ab5a:03b3:213d:1d6c4:1d6fe:1d738:1d772:1d7ac:0443:04af:10e7:118dc:1d5e:1d67:02b8:028e:01b4:0233:024f;z:24e9:24b5:1d433:1d467:1d49b:1d4cf:1d503:1d537:1d56b:1d59f:1d5d3:1d607:1d63b:1d66f:1d6a3:1d22:ab93:118c4:1d76:0290:0291:01b6:0225" + (0 === n ? ";u:446;U:426" : "")).split(";").map(function(e) {
return e.split(":");
}), i = new Map(), a = 0; a < r.length; ++a) for (var o = r[a][0], s = 1; s < r[a].length; ++s) i.set(String.fromCodePoint(Number("0x" + r[a][s])), o);
t.push(i);
}
return t;
}(), CHARS_ORIG = new Array();

function _fp_replace_fn1(e) {
return PROFANE_SYMS.includes(e[0]) ? "*" : e[0] + (e.length > 4 ? "*".repeat(e.length - 2) + e[e.length - 1] : "*".repeat(e.length - 1));
}

function _fp_replace_fn2(e) {
return e[0] + (e.length > 4 ? "*".repeat(e.length - 2) + e[e.length - 1] : "*".repeat(e.length - 1));
}

function _filter_profanity(e, t, n, r) {
for (var i = Array.from("".normalize ? e.normalize("NFD") : e), a = "", o = 0, s = 0; o < i.length; ++o) !PROFANE_SYMS.includes(i[o]) && i[o].match(GAP_FILTER) ? ++s : (a += n.get(CHARS_ORIG[o] = i[o]) || i[o], 
i[o] = null);
for (var c = Array.from(a.replace(t, r).replace(t, r)), l = (o = 0, 0), u = ""; o < s + c.length; ++o) u += i[o] || ("*" === c[l++] ? "*" : CHARS_ORIG[o]) || "";
return u;
}

function filter_profanity(e) {
return _filter_profanity(_filter_profanity(e, PROFANE_FILTERS[0], SYM_MAPS[0], _fp_replace_fn1), PROFANE_FILTERS[1], SYM_MAPS[1], _fp_replace_fn2);
}

function $0(e) {
var t = "} * esle { 4cev ))0.1 0.1 * ,a.rlc_v(nim * )(niam ,)0.001(3cev(4cev noitisoP_lg noitisoP_lg / phgih egnar_vu_v - diov ;vu_v ;0.8 pmuidem )(niam mrofinu ;)0.1 pwol == phgih 0.2 xirtaMweiVledom gniyrav noitisoP_lg ;egnar_vu xam_vu )y.mt td { * ;a.rlc_v 2cev ))2td(roolf * mrofinu 2cev ,tinu_rep_sces_mt * ,noitisop(4cev * etubirtta ffid_mt phgih ,1c pwol ;sop_xet_v ;2c phgih etubirtta etubirtta } drooCtnioP_lg 4cev diov + - mrofinu rlc_v { ;]1[egnar_vu_v*)]0[egnar_vu_v ,y.sezis phgih ;)0.1 } ,pmt(tod noitisoP_lg )0.0 ,)0.001(3cev(4cev vu_v gniyrav rlc_v ;a_v diov mrofinu = )0.0 ;sezis pwol diov tsnoc * 4cev * ;)z.noitisop 3cev 5.0 } > ;p2w xirtaMnoitcejorp 2td((soc - pwol taolf } taolf 52.0( * wzy.lev 4cev phgih x.sezis( =- diov xam_vu * 2cev xirtaMweiVledom * fi ;rlc_v lum_vu ;)lum_vu ;rlc_v mrofinu )(niam taolf roloCgarF_lg = )(niam ;lum_vu * eziStnioP_lg phgih * pwol { )(niam 0.4 )lert ,x.sezis(xim ;lum_vu * ;2c gniyrav / ]1[]1[xirtaMweiVledom 3cev gniyrav { vu_v phgih taolf = taolf phgih taolf } taolf - } 4cev gniyrav 0.2 - = )0.0 ;)0.1 ,2c esle pwol ;)0.1 = - 0.1( * ;0.0 * * * vu + ;)lert ;rlc_v pmuidem IP2_ = gniyrav gniyrav 4cev && { phgih )(niam * ;rlc_v taolf * ;x.mt pwol ;lum_vu } - ;)z.sezis ,noitisop(4cev ;lev_sah gniyrav - =< gniyrav noitisop taolf ,w.mt ,w.mt 0.2( phgih ;ffida 3cev y.mt(taolf pwol roloCgarF_lg gniyrav noitisoP_lg a.roloCgarF_lg taolf 0.0 = ]1[]1[xirtaMweiVledom etubirtta = 0.4 - { gniyrav ,xet(D2erutxet * 2cev ,sop(4cev { ;vu 2cev pmt = gniyrav etubirtta = * )(niam = ,a.rlc_v(nim etubirtta pwol * phgih )x.lev(sba gniyrav ,)x.sezis 0.1 ;lum_vu lum_vu a.roloCgarF_lg / ;lev gniyrav * gniyrav )yx.sop etubirtta ;a_v phgih xirtaMweiVledom taolf = = lum_vu x.sezis ;)0.1 ,bgr.atadt(4cev z.mt 2td((soc ;lum_vu xirtaMnoitcejorp pwol { } gniyrav diov = && + ;vu_v xam_vu( * ,2c 5.0 ;))lum_vu )0.0 + 4cev { 2cev - = ffid_mt( = = )0.0 ,)elgna(nis ))2td(roolf diov / diov ,y.sezis = ;)5.0(2cev pmuidem ,)x.sezis ;1c ;sezis xam_vu 0.2 = * ;)z.sezis = 0.1( taolf vu_v yx.noitisop(4cev ,1c(xim * - * ;))lum_vu noitisoP_lg etubirtta )0.0 / x.sezis( + ,)IP2_ = xirtaMweiVledom * 52.0( - ;vu_v = xirtaMweiVledom ;rlc_v 4cev gniyrav ;vu_v mrofinu ,bgr.rlc_v(4cev = ,bgr.rlc_v(4cev = 4cev etubirtta )0.0 ;))lum_vu ;rlc xam_vu eziStnioP_lg * ,pmt(tod = = = esle gniyrav * 0.4( )0.0 5.0 ;xet = ,1c phgih { xirtaMnoitcejorp taolf * 0.0 gniyrav etubirtta ;p2w } * diov 4cev ;0.0 + IP2_ 4cev 0.2( = ;vu_v = * 0.1( roloCgarF_lg vu { = } rlc_v ;mt = eziStnioP_lg 2cev ;)lert xirtaMnoitcejorp z.mt etubirtta gniyrav phgih ,a.rlc_v(nim 0.4 ,vu_v(tod = xam_vu( taolf ;)z.sezis esle } { * ,vu_v(tod pmt pmuidem ;)0.1 = td * = { diov = gniyrav - 4cev ;1c phgih 0.1( 0.2( * fi { = gniyrav + diov > etubirtta ;lum_vu * y.mt(taolf pmuidem - ,z.noitisop ;0.0 taolf taolf = ,tinu_rep_sces_mt taolf ;sezis ,bgr.rlc_v(4cev ))vu_v * = gniyrav etubirtta roloCgarF_lg taolf = * fi { > = } = x.sezis( gniyrav ,2mt 0.1 yx.noitisop(3cev pmuidem lum_vu tam_tor_xet( wz.fnoc_xet } ffid_mt 4cev 52.0( - * vu_v ;lev { 52.0( = D2relpmas y.mt(taolf ;lev_sah * xam_vu )0.1(nata + = ,sop(4cev lum_vu ))pmt - > = gniyrav == 3cev taolf = 4cev = ))0.1 ,p2w ;rlc_v td - ffid_mt( ;)z.sezis ))0.1 ,)IP2_ gniyrav 4cev xirtaMnoitcejorp * vu ;)0.0 elgna )(niam } / } a_v ,sop(4cev )(niam mrofinu ;)0.1 pwol vu(3cev + )tinu_rep_sces_mt lev_sah( drooCtnioP_lg ;)0.1(2cev - etubirtta gniyrav ;won_mt ;)0.1 etubirtta lum_vu ))vu_v noitisoP_lg ;IP2_ ;rlc_v )x.lev(ngis ffid_mt ,noitisop(4cev 2cev = taolf ))vu_v noitisop > 4cev = ;egnar_vu_v / gniyrav xam_vu( ffid_mt(taolf ;sop_xet_v taolf * ;1c * xam_vu gniyrav phgih * = pmuidem taolf )y.mt ,1c(xim + pwol taolf )0.0 ;a_v * 2cev ;vu_v = ffid_mt(taolf { )0.0 - + ;)0.1 ;rlc_v rlc_v = = - * lev_sah( + lert fi phgih ,bgr.rlc_v(4cev ,won_mt 2td 0.1 xam_vu 0.1( 4cev xam_vu( * taolf ;a.rlc_v ;sezis = * 0.4( phgih ,))elgna(nis pmuidem phgih - ;vu_v ;yx.fnoc_xet ,a.rlc_v(nim ))pmt sop gniyrav ,)0.001(3cev(4cev 4cev 2cev } ;mt { y.sezis ;))0.1 4cev ,bgr.rlc_v(4cev - )(niam / + ;sezis )0.0 )0.0 ;1c ;egnar_vu = etubirtta taolf ,)elgna(soc(2cev * ,)0.001(3cev(4cev ;rlc_v * ,x.sezis(xim 2cev sop_xet_v = + ;vu 52.0( = = 4cev + ;)5.0(2cev 4cev = ;rlc = 3cev + * xam_vu ;)sop_xet_v won_mt > 2cev * ;a.rlc_v etubirtta } } ;a.rlc_v { ,)0.001(3cev(4cev rlc_v phgih * ))0.1 xam_vu( roloCgarF_lg phgih )(niam )(niam phgih 2cev gniyrav * = ;2mt lert 4cev * taolf - eziStnioP_lg 4cev ;)0.0 + * ffid_mt xam_vu y.mt(taolf ;))lum_vu 0.4 diov ;rlc_v ;egnar_vu_v lum_vu } pmuidem ))0.1 * esle xirtaMnoitcejorp =< * ;vu ;tam_tor_xet ;lum_vu ;lum_vu )(niam ffida(taolf ;1c ;lum_vu * * > ;0.8 )0.1(nata ,2mt gniyrav td 0.1 sop > 3cev } * 5.0 * ffid_mt ffida td 0.4 - = td - - taolf gniyrav )x.lev(ngis 0.4( / elgna 2cev )x.lev(sba y.sezis ,pmt(nim*a.rlc_v ;)0.1 ;0.0 )(niam noitisoP_lg * 0.1 - = tsnoc - ;rlc > ;vu_v pmt diov } won_mt ffid_mt ,)elgna(soc(3cev { 0.4( * xirtaMnoitcejorp ,vu_v(tod ;)0.1 ;fnoc_xet etubirtta 3cev noitisoP_lg = xirtaMweiVledom * wzy.lev ,vu_v(tod(trqs( ;rlc taolf taolf ;rlc_v { = rlc_v > ;rlc_v roloCgarF_lg * x.sezis( fi ;x.mt ;1c ;a_v phgih 0.4( taolf { diov ;lum_vu ;)z.sezis )tinu_rep_sces_mt taolf } * roloCgarF_lg ;p2w 2cev = phgih 2td ;)0.1 noitisoP_lg 4cev gniyrav ,won_mt { 2tam noitisoP_lg atadt ;IP2_ 3cev } ))vu_v - = x.sezis( xirtaMweiVledom / - ))lert * gniyrav gniyrav xam_vu ;rlc_v = noitisoP_lg sop - taolf ;2mt etubirtta".split("").reverse().join("").split(" ");
return e.map(function(e) {
return t[e];
}).join(" ");
}

!function() {
"use strict";
function e(e) {
if (!e) for (;;) ;
}
function t(e, t, n) {
if (-1 === e.count) e.offset = t, e.count = n; else {
var r = e.offset + e.count;
e.offset > t && (e.offset = t), e.count = (t + n > r ? t + n : r) - e.offset;
}
}
function n(e, n, r) {
var i = e.array;
i[r] !== n && (i[r] = n, t(e.updateRange, r, 1), e.needsUpdate = !0);
}
function r(e, n, r) {
var i = e.array;
i[r] !== n && (i[r] = n, t(e.updateRange, r, 1), e.needsUpdate = !0);
}
function i(e, n, r) {
var i = e.array;
i[r] !== n && (i[r] = n, t(e.updateRange, r, 1), e.needsUpdate = !0);
}
function a(e, n, r) {
var i = e.array;
i[r] !== n && (i[r] = n, t(e.updateRange, r, 1), e.needsUpdate = !0);
}
function o(e, t, n, r, i, a) {
var o = this;
$3.Object3D.call(o), o.$86 = !!e, o.$87 = t, o.$88 = Math.min(n, 16777215), o.$89 = i || 0, 
o.$8a = a || k;
for (var s = 0; s < r; ++s) {
var c = new d(o, s);
o.add(c);
}
}
function s() {
var e = this;
e.$8j = e.$8l = null, e.$8k = e.$8m = 0;
}
window.GEN_TMSP = "644FBB8C", o.prototype = new $3.Object3D(), o.prototype.constructor = o, 
o.prototype.$8b = function(e) {
var t = this.$87.uniforms.tm_now;
t && (t.value = e);
}, o.prototype.$8c = function() {
return this.$87.uniforms.tm_now.value;
}, o.prototype.$8d = function() {
for (var e = 0, t = this.children, n = t.length; e < n; ++e) t[e].$9q();
}, o.prototype.$8e = function(e, t, n) {
for (var r, i, a = this, o = a.children, s = o.length, l = n === c ? 0 : n.$8j.$8v, u = n === c ? 0 : 1 + (n.$8k >>> n.$8j.$99); l < s && !((i = (r = o[l]).$9r(u)) >= 0); ) ++l, 
u = 0;
return l === s && (a.add(r = new d(a, s)), i = r.$9r(0)), r.$9p(i, e), t && (t.$8j = r, 
t.$8k = i << r.$99 | r.$98[i]), t;
}, o.prototype.$8f = function() {
for (var e = 0, t = 0, n = this.children, r = n.length; t < r; ++t) e += n[t].$9k;
return e;
}, o.prototype.clear = function() {
for (var e = 0, t = this.children, n = t.length; e < n; ++e) t[e].clear();
}, o.prototype.$8h = function() {
for (var e = 0, t = this.children, n = t.length; e < n; ++e) t[e].$9u();
}, o.prototype.$8i = function() {
for (var e = 0, t = this.children, n = t.length; e < n; ++e) t[e].$8i();
}, s.prototype.$8j, s.prototype.$8k, s.prototype.$8l, s.prototype.$8m, s.prototype.$8n = function() {
var e = this;
return e.$8j = e.$8l = null, e.$8k = e.$8m = 0, e;
}, s.prototype.$8o = function(e, t) {
return !!this.$8j && (this.$8j.$8o(this.$8k, e, t), !0);
}, s.prototype.$8p = function(e, t) {
return this.$8j ? this.$8j.$8p(this.$8k, e, t) : null;
}, s.prototype.$8q = function() {
this.$8j && (this.$8j.$8q(this.$8k), this.$8n());
}, s.prototype.$8r = function(e) {
if (this.$8j.$8u === e.$8j.$8u) {
var t = this.$8j.$8v, n = e.$8j.$8v;
return t < n || t === n && this.$8k >>> this.$8j.$99 < e.$8k >>> e.$8j.$99;
}
return null;
};
var c = new s(), l = new s();
function u(e, t) {
var n = 1 + (e - 1 >>> 5) >>> 0, r = t && t.length === n ? t : new Uint32Array(n);
return r.fill(4294967295), e !== n << 5 && (r[n - 1] = (1 << 32 - ((n << 5) - e)) - 1), 
r;
}
var h = new $3.Sphere(new $3.Vector3(), Number.MAX_VALUE);
function d(e, t) {
var o = this, s = e.$86, c = s ? new $3.Mesh(new $3.InstancedBufferGmtr(), e.$87) : new $3.Points(new $3.BufferGmtr(), e.$87);
(p = c.geometry).boundingSphere = h, $3.Object3D.call(o), o.add(c), o.$9l = c, o.$8v = t, 
o.$9k = -0, o.$8x = -0, o.$8u = e, o.$97 = u(e.$88), o.$96 = o.$97[o.$97.length - 1], 
o.$95 = -0, o.$6 = s ? i : n, o.$7 = s ? a : r, o.$9m = o.$9n = 0, c.renderOrder = e.$89;
var l = o.$8u.$8a, d = {
position: null,
vel: null,
sizes: null,
c1: null,
c2: null,
tm: null,
tm2: null
};
l & M && (d.position = [ Float32Array, 3 ]), l & (P | S) && (d.vel = [ Float32Array, o.$9o = (l & P ? 3 : 0) + (l & S ? 1 : 0) ]), 
l & (A | T | w) && (d.sizes = [ Float32Array, 3 ]), l & (v | m) && (d.c1 = [ Uint8Array, o.$9m = l & v ? 4 : 1, !0 ]), 
l & (y | g) && (d.c2 = [ Uint8Array, o.$9n = l & y ? 4 : 1, !0 ]), l & (C | E | L | _ | x) && e.$87.uniforms.tm_now && (d.tm = [ Float32Array, 4 ]), 
l & b && (d.tm2 = [ Float32Array, 1 ]);
var p, f = Object.keys(d), $ = "position,vel,sizes,c1,c2,tm,tm2".split(","), k = Uint8Array;
for (var O in f) if (f.hasOwnProperty(O)) {
var D = f[O], N = d[D];
if (p.deleteAttribute(D), N) {
var I = s ? new $3.InstancedBufferAttribute(new N[0](N[1] * o.$8u.$88), N[1], N[2], 1) : new $3.BufferAttribute(new N[0](N[1] * o.$8u.$88), N[1], N[2]);
I.setUsage($3.DynamicDrawUsage), I.needsUpdate = !0, p.setAttribute(D, I);
}
}
if (o.$8y = p.getAttribute($[0]), o.$8z = p.getAttribute($[1]), o.$90 = p.getAttribute($[2]), 
o.$91 = p.getAttribute($[3]), o.$92 = p.getAttribute($[4]), o.$93 = p.getAttribute($[5]), 
o.$94 = p.getAttribute($[6]), o.$9b = o.$8y && o.$8y.array, o.$9c = o.$8z && o.$8z.array, 
o.$9d = o.$90 && o.$90.array, o.$9e = o.$91 && o.$91.array, o.$9f = o.$92 && o.$92.array, 
o.$9g = o.$93 && o.$93.array, o.$9h = o.$94 && o.$94.array, o.$9i = o.$9e && new DataView(o.$9e.buffer, o.$9e.byteOffset, o.$9e.length * o.$9e.BYTES_PER_ELEMENT), 
o.$9j = o.$9f && new DataView(o.$9f.buffer, o.$9f.byteOffset, o.$9f.length * o.$9f.BYTES_PER_ELEMENT), 
o.$9g) {
O = 0;
for (var R = 1, j = o.$9g; O < o.$8u.$88; ++O, R += d.tm[1]) j[R] = -1;
}
(o.$98 = new k(o.$8u.$88), o.$99 = 8 * o.$98.BYTES_PER_ELEMENT, o.$9a = (1 << o.$99) - 1, 
s) && ((p = c.geometry).setAttribute("uv", o.$8t), p.setIndex(o.$8s));
c.onBeforeRender = o.$9t.bind(o);
}
d.prototype = new $3.Object3D(), d.prototype.constructor = d, d.prototype.$8s = new $3.BufferAttribute(new Uint8Array([ 0, 1, 2, 1, 3, 2 ]), 1), 
d.prototype.$8t = new $3.BufferAttribute(new Float32Array([ .5, .5, -.5, .5, .5, -.5, -.5, -.5 ]), 2), 
d.prototype.$9p = function(e, n) {
var r = this, i = r.$8u, a = 3 * e | 0, o = e << 2, s = Number.MAX_VALUE, c = n.$9z === s ? 4294967295 : n.$9z;
if (r.$9b) {
if (null === n.$9v) r.$9b[a] = r.$9b[a + 1] = r.$9b[a + 2] = 0; else {
var l = n.$9v;
r.$9b[a] = l[0], r.$9b[a + 1] = l[1], r.$9b[a + 2] = l[2];
}
t(r.$8y.updateRange, a, 3), r.$8y.needsUpdate = !0;
}
if (r.$9c) {
var u = e * r.$9o;
if (i.$8a & S && (r.$9c[u++] = n.$aa === s ? 0 : n.$aa), i.$8a & P) if (null === n.$9y) r.$9c[u] = r.$9c[u + 1] = r.$9c[u + 2] = 0; else {
var h = n.$9y;
r.$9c[u] = h[0], r.$9c[u + 1] = h[1], r.$9c[u + 2] = h[2];
}
t(r.$8z.updateRange, e * r.$9o, r.$9o), r.$8z.needsUpdate = !0;
}
r.$9d && (r.$9d[a] = n.$9w === s ? 1 : n.$9w, r.$9d[a + 1] = n.$9x === s ? r.$9d[a] : n.$9x, 
n.$a8 === s ? r.$9d[a + 2] = .1 : (r.$9d[a + 2] = n.$a8, r.$9d[a + 2] < 1e-6 ? r.$9d[a + 2] = 1e-6 : r.$9d[a + 2] > 1 - 1e-6 && (r.$9d[a + 2] = 1 - 1e-6)), 
t(r.$90.updateRange, a, 3), r.$90.needsUpdate = !0), r.$91 && (1 === r.$9m ? (r.$9e[e] = n.$a1 === s ? 255 : n.$a1, 
t(r.$91.updateRange, e, 1)) : (r.$9i.setUint32(o, c), t(r.$91.updateRange, o, 4)), 
r.$91.needsUpdate = !0), r.$92 && (1 === r.$9n ? (r.$9f[e] = n.$a2 === s ? 255 : n.$a2, 
t(r.$92.updateRange, e, 1)) : (r.$9j.setUint32(o, n.$a0 === s ? c : n.$a0), t(r.$92.updateRange, o, 4)), 
r.$92.needsUpdate = !0), r.$9g && (r.$9g[o] = n.$a5 === s ? 0 : n.$a5, r.$9g[o + 1] = n.$a4 === s ? 0 : n.$a4, 
r.$9g[o + 2] = n.$a9 === s ? 1 : 0 === n.$a9 ? 0 : 1 / n.$a9, r.$9g[o + 3] = n.$a3 === s ? 1 : n.$a3, 
t(r.$93.updateRange, o, 4), r.$93.needsUpdate = !0), r.$9h && (r.$9h[e] = n.$a7 === s ? 0 : n.$a7, 
t(r.$94.updateRange, e, 1), r.$94.needsUpdate = !0), ++r.$98[e];
}, d.prototype.$8p = function(t, n, r) {
var i, a = this, o = (a.$8u, t >>> a.$99), s = 3 * o >>> 0, c = o << 2, l = 0 | r;
if (e(a.$98[o] === (t & a.$9a)), 255 & l && (15 & l && (3 & l && (1 & l && (n.$a1 = a.$9e[(o + 1) * a.$9m - 1]), 
2 & l && (n.$a2 = a.$9f[(o + 1) * a.$9n - 1])), 12 & l && (4 & l && (n.$9z = a.$9i.getUint32(c)), 
8 & l && (n.$a0 = a.$9j.getUint32(c)))), 240 & l && (48 & l && (16 & l && (n.$a7 = a.$94[o]), 
32 & l && (n.$a3 = a.$9g[c + 3])), 192 & l && (64 & l && (n.$a8 = a.$9d[s + 2]), 
128 & l)))) {
var u = a.$9g[c + 2];
n.$a9 = 0 === u ? 0 : 1 / u;
}
if (65280 & l) {
if (3840 & l) {
if (768 & l) {
if (256 & l) if (i = n.$9v) i[0] = a.$9b[s], i[1] = a.$9b[s + 1], i[2] = a.$9b[s + 2]; else {
var h = n.$9v = new Float32Array(3);
h[0] = a.$9b[s], h[1] = a.$9b[s + 1], h[2] = a.$9b[s + 2];
}
512 & l && (n.$aa = a.$9c[o * a.$9o]);
}
3072 & l && (1024 & l && (n.$9w = a.$9d[s]), 2048 & l && (n.$9x = a.$9d[s + 1]));
}
if (61440 & l && (12288 & l && (4096 & l && (n.$a4 = a.$9g[c + 1]), 8192 & l && (n.$a5 = a.$9g[c])), 
49152 & l && (16384 & l && (e(a.$9g[c + 1] > 0), n.$a6 = a.$9g[c + 1] - a.$9g[c]), 
32768 & l))) {
var d = (o + 1) * a.$9o - 3;
(i = n.$9y || (n.$9y = new Float32Array(3)))[0] = a.$9c[d], i[1] = a.$9c[d + 1], 
i[2] = a.$9c[d + 2];
}
}
return n;
}, d.prototype.$8o = function(n, r, i) {
var a, o = this, s = n >>> o.$99, c = 3 * s >>> 0, l = 0 | i, u = s << 2;
if (e(o.$98[s] === (n & o.$9a)), 255 & l && (15 & l && (12 & l && (4 & l && (o.$9i.setUint32(u, r.$9z), 
t(o.$91.updateRange, u, 4), o.$91.needsUpdate = !0), 8 & l && (o.$9j.setUint32(u, r.$a0), 
t(o.$92.updateRange, u, 4), o.$92.needsUpdate = !0)), 3 & l && (1 & l && o.$6(o.$91, r.$a1, (s + 1) * o.$9m - 1), 
2 & l && o.$6(o.$92, r.$a2, (s + 1) * o.$9n - 1))), 240 & l && (48 & l && (16 & l && o.$7(o.$94, r.$a7, s), 
32 & l && o.$7(o.$93, r.$a3, u + 3)), 192 & l && (64 & l && o.$7(o.$90, r.$a8, c + 2), 
128 & l && (a = r.$a9, o.$7(o.$93, 0 === a ? 0 : 1 / a, u + 2))))), 65280 & l) {
if (3840 & l) {
if (768 & l) {
if (256 & l) {
var h = r.$9v;
o.$9b[c] = h[0], o.$9b[c + 1] = h[1], o.$9b[c + 2] = h[2], t(o.$8y.updateRange, c, 3), 
o.$8y.needsUpdate = !0;
}
512 & l && o.$7(o.$8z, r.$aa, s * o.$9o);
}
3072 & l && (1024 & l && o.$7(o.$90, r.$9w, c), 2048 & l && o.$7(o.$90, r.$9x, c + 1));
}
if (61440 & l && (12288 & l && (4096 & l && o.$7(o.$93, r.$a4, u + 1), 8192 & l && o.$7(o.$93, r.$a5, u)), 
49152 & l)) {
if (16384 & l) {
var d = o.$9g[u];
e(r.$a6 > d), o.$7(o.$93, r.$a6 - d, u + 1);
}
if (32768 & l) {
var p = r.$9y, f = (s + 1) * o.$9o - 3;
o.$9c[f] = p[0], o.$9c[f + 1] = p[1], o.$9c[f + 2] = p[2], t(o.$8z.updateRange, f, 3), 
o.$8z.needsUpdate = !0;
}
}
}
}, d.prototype.$8q = function(t) {
var n = this, r = t >>> n.$99, i = 1 + (r << 2);
n.$98[r] === (t & n.$9a) && (e(!(n.$97[r >>> 5] & 1 << (31 & r))), n.$97[r >>> 5] |= 1 << (31 & r), 
n.$9s(-1), ++n.$98[r], n.$9g && n.$9g[i] >= 0 && n.$7(n.$93, -1, i), n.$9d && n.$7(n.$90, 0, 3 * r));
}, d.prototype.$9q = function() {
var e = this, t = -1;
if (!e.$9g || 0 === e.$9k) return t;
var n = e.$8u.$8c();
if (e.$95 < n) {
for (var r = e.$9g, i = e.$97, a = 0, o = 0, s = 1, c = r.length, l = e.$8u.$88 >>> 5 << 7; s < l; ++a) if (4294967295 !== i[a]) {
for (var u = 1; u; u <<= 1, s += 4, ++o) if (!(i[a] & u) && r[s] > 0 && r[s - 1] + r[s] <= n && (r[s] = -1, 
i[a] |= u, e.$9s(-1), ++e.$98[o], t = o, 4294967295 === i[a])) {
var h = 32 - f(u);
s += 4 * h, o += h;
break;
}
} else s += 128, o += 32;
if (a < i.length && i[a] !== e.$96) for (u = 1; s < c && !(!(i[a] & u) && r[s] > 0 && r[s - 1] + r[s] <= n && (r[s] = -1, 
i[a] |= u, e.$9s(-1), ++e.$98[o], t = o, i[a] === e.$96)); u <<= 1, s += 4, ++o) ;
e.$95 = n;
}
return t;
};
var p, f = (p = new Uint8Array([ 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 ]), 
function(e) {
return p[125613361 * (e & -e) >>> 27];
});
d.prototype.$9r = function(t) {
var n = this, r = -1, i = n.$97;
if (n.$9k === n.$8u.$88) {
if ((r = n.$9q()) < 0) return -1;
if (t && r < t) return n.$9r(t);
} else {
var a = (t || n.$8x) >>> 5, o = 4294967295 << (31 & (t || n.$8x)), s = a, c = i.length;
if (s < c && 0 == (i[s] & o)) for (++s, o = 4294967295; s < c && 0 === i[s]; ) ++s;
if (s === c) {
if (t) return -1;
for (s = 0; s < a && 0 === i[s]; ) ++s;
}
r = (s << 5) + f(i[s] & o);
}
return i[r >>> 5] &= ~(1 << (31 & r)), n.$8x = (r + 1) * (r < n.$8u.$88 - 1), n.$9s(1), 
e(!t || r >= t), r;
}, d.prototype.$9s = function(e) {
var t = this;
t.$9k += e, t.$8u.$86, t.$9l.visible = t.$9k > 0;
}, d.prototype.$9t = function() {
var e = this, t = 0, n = 0;
if (e.$9k > 0) {
var r = e.$97;
for (n = r.length - 1; 4294967295 === r[t++]; ) ;
if (--t, r[n] === this.$96 && n > 0) for (;4294967295 === r[--n]; ) ;
t <<= 5, n = Math.min(e.$8u.$88, n + 1 << 5) - t;
}
e.$8u.$86 ? e.$9l.geometry.instanceCount = t + n : e.$9l.geometry.setDrawRange(t, n);
}, d.prototype.clear = function() {
var e = this;
e.$97 = u(e.$8u.$88, e.$97), e.$96 = e.$97[e.$97.length - 1], e.$95 = e.$8u.$8c();
for (var n = 0, r = e.$98.length; n < r; ++n) e.$98[n] = 0;
if (e.$8x = 0, e.$9s(-e.$9k), e.$9g) {
var i = e.$9g;
for (n = 0; n < i.length; n += 4) i[n] = -1;
t(e.$93.updateRange, 0, e.$9g.length), e.$93.needsUpdate = !0;
}
e.$9d && (e.$9d.fill(0), t(e.$90.updateRange, 0, e.$9d.length), e.$90.needsUpdate = !0);
}, d.prototype.$9u = function() {
this.$8x = 0;
}, d.prototype.$8i = function() {};
var m = 1, g = 2, v = 4, y = 8, b = 16, x = 32, w = 64, _ = 128, M = 256, S = 512, A = 1024, T = 2048, L = 4096, C = 8192, E = 16384, P = 32768, k = 65535;
function O() {
this.$8n();
}
function D(e, t, n, r) {
var i = this;
i.tm_now = null == e ? null : {
type: "f",
value: e
}, i.tm_secs_per_unit = null == t ? null : {
type: "f",
value: t
}, i.w2p = null == n ? null : {
type: "f",
value: n
}, i.has_vel = null == r ? null : {
type: "f",
value: r
};
}
O.prototype.$8n = function() {
var e = this;
return e.$a1 = e.$a2 = e.$9z = e.$a0 = e.$a7 = e.$a3 = e.$a8 = e.$a9 = e.$aa = e.$9w = e.$9x = e.$a4 = e.$a5 = e.$a6 = Number.MAX_VALUE, 
e.$9v = e.$9y = null, e;
};
var N, I, R, j, U, B, z, F, G = (N = {
tm_now: -0,
tm_secs_per_unit: 1,
w2p: 1 - 1e-16,
has_vel: 1
}, I = $0([ 868, 876, 790, 267, 847, 366, 688, 843, 876, 887, 631, 843, 876, 799, 807, 843, 866, 887, 840, 837, 843, 876, 887, 485, 843, 876, 790, 169, 861, 887, 773, 861, 790, 763, 804, 876, 790, 708, 809, 383, 890, 871, 873, 881, 888, 876, 790, 842, 809, 194, 874, 695, 774, 782, 829, 236, 796, 668, 703, 675, 865, 817, 829, 675, 796, 817, 890, 309, 890, 590, 874, 857, 685, 817, 796, 817, 888, 876, 790, 856, 809, 842, 890, 615, 874, 406, 266, 809, 856, 890, 681, 271, 809, 798, 874, 798, 890, 793, 874, 851, 890, 553, 352, 809, 856, 890, 324, 890, 326, 876, 799, 244, 809, 683, 829, 785, 890, 338, 890, 842, 890, 339, 829, 639, 890, 80, 586, 353, 879, 809, 794, 890, 862, 890, 656, 867, 826, 809, 564, 725, 711, 870, 790, 858, 809, 885, 877, 719, 874, 690, 772, 809, 520, 829, 755, 877, 602, 890, 858, 874, 886, 890, 853, 761, 809, 747, 890, 753, 823, 754, 890, 863, 890, 795, 891, 889, 888, 879, 809, 880, 867, 772, 809, 717, 761, 809, 717, 891, 891 ]), 
R = $0([ 861, 887, 773, 861, 790, 763, 873, 881, 888, 866, 852, 652, 809, 832, 874, 579, 766, 809, 539, 883, 787, 874, 819, 378, 890, 598, 891 ]), 
j = {
uniforms: new D(N.tm_now, N.tm_secs_per_unit, N.w2p, N.has_vel),
vertexShader: I,
fragmentShader: R,
transparent: !0,
depthWrite: !1,
blending: $3.CustomBlending
}, U = $0([ 868, 876, 790, 267, 847, 688, 843, 876, 887, 631, 843, 876, 799, 807, 843, 866, 887, 840, 837, 843, 876, 887, 485, 843, 876, 790, 169, 861, 887, 773, 861, 852, 872, 861, 790, 763, 804, 876, 790, 708, 809, 383, 890, 871, 873, 881, 888, 876, 790, 842, 809, 194, 874, 695, 774, 782, 829, 236, 796, 668, 703, 675, 865, 817, 829, 675, 796, 817, 890, 309, 890, 590, 874, 857, 685, 817, 796, 817, 888, 876, 790, 856, 809, 842, 890, 615, 874, 406, 266, 809, 856, 890, 681, 271, 809, 798, 874, 798, 890, 793, 874, 851, 890, 553, 352, 809, 856, 890, 324, 890, 326, 876, 799, 244, 809, 683, 829, 785, 890, 338, 890, 842, 890, 339, 829, 341, 890, 679, 890, 753, 823, 12, 829, 639, 890, 220, 252, 353, 879, 809, 794, 890, 862, 890, 656, 867, 826, 809, 564, 725, 711, 815, 809, 654, 870, 790, 858, 809, 885, 877, 719, 874, 690, 772, 809, 520, 829, 755, 877, 602, 890, 858, 874, 886, 890, 853, 891, 889, 888, 879, 809, 880, 867, 891, 891 ]), 
B = $0([ 861, 887, 773, 861, 852, 872, 861, 790, 763, 873, 881, 888, 766, 809, 539, 883, 787, 874, 473, 423, 890, 598, 891 ]), 
z = {
uniforms: new D(N.tm_now, N.tm_secs_per_unit, null, N.has_vel),
vertexShader: U,
fragmentShader: B,
transparent: !0,
depthWrite: !1,
blending: $3.CustomBlending
}, F = [ new $3.ShaderMtrl(j), new $3.ShaderMtrl(z) ], function(e, t, n, r, i, a, s, c, l, u) {
return u = u || k, t || ((t = F[e ? 1 : 0].clone()).setValues(s), t.uniforms.tm_now.value = i || N.tm_now, 
t.uniforms.tm_secs_per_unit.value = a || N.tm_secs_per_unit, t.uniforms.w2p && (t.uniforms.w2p.value = l || N.w2p), 
t.uniforms.has_vel.value = u & P ? 1 : 0), new o(e, t, n, r, c, u);
});
var V, W, q, H, X, Y = function() {
var e = {
w2p: 1 - 1e-16
}, t = $0([ 868, 876, 790, 795, 843, 876, 799, 807, 843, 866, 887, 576, 861, 887, 773, 861, 790, 763, 873, 881, 888, 774, 782, 796, 817, 888, 879, 809, 794, 890, 862, 890, 845, 867, 826, 809, 576, 870, 790, 858, 809, 885, 877, 719, 874, 690, 772, 809, 520, 829, 755, 877, 602, 890, 858, 874, 886, 890, 853, 761, 809, 747, 890, 618, 890, 863, 890, 795, 891, 889, 888, 879, 809, 880, 867, 772, 809, 717, 761, 809, 717, 891, 891 ]), n = $0([ 861, 887, 773, 861, 790, 763, 873, 881, 888, 866, 852, 652, 809, 832, 874, 579, 766, 809, 539, 883, 787, 874, 819, 378, 890, 598, 891 ]), r = {
uniforms: new D(null, null, e.w2p),
vertexShader: t,
fragmentShader: n,
transparent: !0,
depthWrite: !1,
blending: $3.CustomBlending
}, i = $0([ 843, 876, 799, 807, 843, 866, 887, 576, 861, 887, 773, 861, 852, 872, 861, 790, 763, 873, 881, 888, 774, 782, 796, 817, 888, 879, 809, 794, 890, 862, 890, 565, 829, 713, 890, 679, 890, 637, 432, 867, 826, 809, 576, 815, 809, 654, 870, 790, 858, 809, 885, 877, 719, 874, 690, 772, 809, 520, 829, 755, 877, 602, 890, 858, 874, 886, 890, 853, 891, 889, 888, 879, 809, 880, 867, 891, 891 ]), a = $0([ 861, 887, 773, 861, 852, 872, 861, 790, 763, 873, 881, 888, 766, 809, 539, 883, 787, 874, 473, 423, 890, 598, 891 ]), s = {
uniforms: new D(null, null, null),
vertexShader: i,
fragmentShader: a,
transparent: !0,
depthWrite: !1,
blending: $3.CustomBlending
}, c = [ new $3.ShaderMtrl(r), new $3.ShaderMtrl(s) ];
return function(t, n, r, i, a, s, l) {
return n || ((n = c[t ? 1 : 0].clone()).setValues(a), n.uniforms.w2p && (n.uniforms.w2p.value = l || e.w2p)), 
new o(t, n, r, i, s, M | A | w | v);
};
}(), J = [ 100, 500 ];
function Z(e, t, n) {
"..." === t.substring(Math.max(0, t.length - 3), t.length) ? (t = t.substring(0, t.length - 3) + '<span class="msg-text-ellipsis"><span>.</span><span>.</span><span>.</span></span>', 
V = setTimeout(function() {
!function e(t, n) {
V = null;
var r = document.getElementById(t), i = r.getElementsByClassName("msg-text-ellipsis")[0];
if (i) if ("none" === r.style.display || "hidden" === r.style.visibility) for (var a = 0; a < 3; ++a) i.children[a].style.opacity = ""; else {
for (a = 0; a < 3; ++a) i.children[a].style.opacity = a < Math.abs(n) ? "" : 0;
V = setTimeout(function() {
e(t, n = 3 === n ? -2 : n + 1);
}, J[Number(n >= 0)]);
}
}(e, 0);
}, J[1])) : V && clearTimeout(V);
var r = document.getElementById(e), i = r.getElementsByClassName("msg-link")[0];
r.getElementsByClassName("msg-text")[0].innerHTML = t, n ? (i.innerHTML = n[0], 
i.href = n[1], i.style.display = "") : i && (i.innerHTML = "", i.href = "javascript:void(0);", 
i.style.display = "none");
}
Array.prototype.fill || (Array.prototype.fill = function(e) {
if (null == this) throw new TypeError("Array.prototype.fill: this is null or not defined");
for (var t = this.length, n = arguments[1] >> 0, r = n < 0 ? Math.max(t + n, 0) : Math.min(n, t), i = arguments[2], a = null == i ? t : i >> 0, o = a < 0 ? Math.max(t + a, 0) : Math.min(a, t); r < o; ) this[r++] = e;
return this;
}), Uint8Array.prototype.fill || (Uint8Array.prototype.fill = Array.prototype.fill), 
Int32Array.prototype.fill || (Int32Array.prototype.fill = Array.prototype.fill), 
Float32Array.prototype.fill || (Float32Array.prototype.fill = Array.prototype.fill), 
Float64Array.prototype.fill || (Float64Array.prototype.fill = Array.prototype.fill), 
Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", {
value: function(e, t) {
return new Uint8Array(Array.prototype.slice.call(this, e, t));
}
}), Uint16Array.prototype.slice || Object.defineProperty(Uint16Array.prototype, "slice", {
value: function(e, t) {
return new Uint16Array(Array.prototype.slice.call(this, e, t));
}
}), Uint32Array.prototype.slice || Object.defineProperty(Uint32Array.prototype, "slice", {
value: function(e, t) {
return new Uint32Array(Array.prototype.slice.call(this, e, t));
}
}), String.prototype.startsWith || (String.prototype.startsWith = function(e, t) {
return this.substr(!t || t < 0 ? 0 : +t, e.length) === e;
}), String.prototype.endsWith || (String.prototype.endsWith = function(e, t) {
return (void 0 === t || t > this.length) && (t = this.length), this.substring(t - e.length, t) === e;
}), Array.of || (Array.of = function() {
return Array.prototype.slice.call(arguments);
}), Float32Array.of || (Float32Array.of = function() {
return new Float32Array(arguments);
}), Float64Array.of || (Float64Array.of = function() {
return new Float64Array(arguments);
}), Uint8Array.of || (Uint8Array.of = function() {
return new Uint8Array(arguments);
}), Uint32Array.of || (Uint32Array.of = function() {
return new Uint32Array(arguments);
}), Int32Array.of || (Int32Array.of = function() {
return new Int32Array(arguments);
}), Int16Array.of || (Int16Array.of = function() {
return new Int16Array(arguments);
}), Array.prototype.copyWithin || (Array.prototype.copyWithin = function(e, t, n) {
if (null == this) throw new TypeError("Array.prototype.copyWithin: this is null or not defined");
var r = Object(this), i = r.length >>> 0, a = e >> 0, o = a < 0 ? Math.max(i + a, 0) : Math.min(a, i), s = t >> 0, c = s < 0 ? Math.max(i + s, 0) : Math.min(s, i), l = void 0 === n ? i : n >> 0, u = l < 0 ? Math.max(i + l, 0) : Math.min(l, i), h = Math.min(u - c, i - o), d = 1;
for (c < o && o < c + h && (d = -1, c += h - 1, o += h - 1); h > 0; ) c in r ? r[o] = r[c] : delete r[o], 
c += d, o += d, h--;
return r;
}, Array.isArray || (Array.isArray = function(e) {
return "[object Array]" === Object.prototype.toString.call(e);
})), Int32Array.prototype.copyWithin || (Int32Array.prototype.copyWithin = Array.prototype.copyWithin), 
Object.keys || (Object.keys = (W = Object.prototype.hasOwnProperty, q = !{
toString: null
}.propertyIsEnumerable("toString"), X = (H = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ]).length, 
function(e) {
if ("function" != typeof e && ("object" != typeof e || null === e)) throw new TypeError("Object.keys called on non-object");
var t, n, r = new Array();
for (t in e) W.call(e, t) && r.push(t);
if (q) for (n = 0; n < X; n++) W.call(e, H[n]) && r.push(H[n]);
return r;
}));
var K = {
$bp: function(e, t, n, r) {
e && (e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent ? e.attachEvent("on" + t, n) : e["on" + t] = n);
},
$bq: function(e, t, n, r) {
e && (e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent ? e.detachEvent("on" + t, n) : e["on" + t] = null);
}
}, Q = {
$br: function(e, t, n) {
return Cookies.set(e, t, n);
},
$bs: function(e, t) {
return Cookies.get(e, t);
},
$bt: function(e, t) {
return Cookies.remove(e, t);
}
};
!function() {
if (Q.$br("test", "123"), "123" !== Q.$bs("test")) {
vr("cookies blocked");
try {
var e = window.localStorage;
} catch (t) {
e = null;
}
if (e) Q = {
$br: function(t, n) {
return e.setItem(t, n);
},
$bs: function(t) {
return e.getItem(t);
},
$bt: function(t) {
return e.removeItem(t);
}
}; else {
vr("localStorage not available");
var t = new Map();
Q = {
$br: function(e, n) {
return t.set(e, n);
},
$bs: function(e) {
return t.get(e);
},
$bt: function(e) {
return t.delete(e);
}
};
}
} else Q.$bt("test");
}();
var ee = {
$ab: new Float64Array(3),
$8n: function(e) {
var t = ee.$ab;
t[0] = 0, t[1] = e, t[2] = 0;
},
$ct: function(e) {
var t = ee.$ab;
if (t[0]) {
var n = (e - t[0]) / t[1];
Math.round(n);
n < 2 && t[2] > 1e3 / t[1] && (t[1] += (e - t[0] - t[1]) / 10), t[0] = e, t[2] = Math.min(t[2] + 1, 1e3);
} else t[0] = e, t[2] = 1;
},
$c4: function(e) {
var t = ee.$ab, n = 1e3 / Ze;
return t[0] + Math.max(1, Math.floor((e - t[0]) / n)) * n;
}
}, te = {
$ab: null,
$ac: 0,
$ai: null,
$ad: 0,
$8n: function() {
te.$ab = new Array(5e4);
for (var e = 0; e < te.$ab.length; ++e) te.$ab[e] = new Array(7);
te.$ac = 0, te.$ai = new Array(), te.$ad = 0;
},
$ah: function(e) {
return e === (0 | e) ? e : Number(e).toFixed(3);
},
$aj: function(e) {
var t = te, n = t.$ab, r = "]";
e = Math.min(e, t.$ac, n.length);
for (var i = (t.$ac - 1) % n.length; e > 0 && i >= 0; --e, --i) r = ",[" + (n[i].findLastIndex ? n[i].slice(0, n[i].findLastIndex(Ls) + 1) : n[i]) + "]" + r;
for (i = n.length - 1; e > 0; --e, --i) r = ",[" + (n[i].findLastIndex ? n[i].slice(0, n[i].findLastIndex(Ls) + 1) : n[i]) + "]" + r;
return "[" + r.slice(t.$ac ? 1 : 0);
},
$ae: function(e, t, n, r, i, a) {
var o = te, s = o.$ab[o.$ac++ % o.$ab.length];
if (s[0] = a ? "ub" : "u", s[1] = e, s[2] = o.$ah(t), s[3] = n ? o.$ah(n) : 0, s[4] = o.$ah(r), 
s[5] = i ? 1 : 0, s[6] = o.$ah(Zc().$n0), !a && e > 0) if (i) {
if (o.$ad) {
var c = o.$ai[o.$ai.length - 1];
if (c[1] = e - c[0], o.$ai.length > 8) for (var l = o.$ai.length - 1, u = -1, h = 0; l > 0; --l) o.$ai[l][1] >= 4 && (0 === h ? (u = l, 
h = 1) : o.$ai[u][0] - o.$ai[l][0] > 800 * Ze / 1e3 && (u = l, ++h));
o.$ad = 0;
}
} else 1 == ++o.$ad && (o.$ai.push([ e, 0 ]), o.$ai.length > 1e3 && o.$ai.shift());
},
$af: function(e, t, n, r, i, a) {
var o = te, s = o.$ab[o.$ac++ % o.$ab.length];
s[0] = i ? "rb" : "r", s[1] = e, s[2] = o.$ah(t), s[3] = o.$ah(n - t), s[4] = o.$ah(r - t), 
s[5] = o.$ah(ee.$ab[1]), s[6] = a;
},
$ag: function(e, t, n, r, i, a, o) {
var s = te, c = s.$ab[s.$ac++ % s.$ab.length];
c[0] = o ? "mrb" : "mr", c[1] = e, c[2] = s.$ah(t), c[3] = a, c[4] = n, n >= 0 ? (c[5] = r, 
c[6] = i) : c[5] = c[6] = 0;
},
$al: function(e, t, n, r) {
var i = te, a = i.$ab[i.$ac++ % i.$ab.length];
a[0] = r ? "msb" : "ms", a[1] = e, a[2] = i.$ah(t), a[3] = n, a[4] = a[5] = a[6] = 0;
},
$am: function(e, t, n, r, i, a, o, s) {
var c = te, l = c.$ab[c.$ac++ % c.$ab.length];
l[0] = e ? s ? "fb1" : "fb0" : s ? "f1" : "f0", l[1] = t, l[2] = c.$ah(o + n), l[3] = c.$ah(o + i), 
l[4] = c.$ah(o + a), l[5] = c.$ah(n - r), l[6] = 0;
},
$ak: function(e, t, n, r, i, a) {
var o = te, s = o.$ab[o.$ac++ % o.$ab.length];
s[0] = "pf", s[1] = e, s[2] = 0 | t[0], s[3] = 0 | n[0], s[4] = o.$ah(r), s[5] = o.$ah(i), 
s[6] = o.$ah(a);
},
$an: function(e, t) {
var n = te, r = n.$ab[n.$ac++ % n.$ab.length];
r[0] = "rts", r[1] = e, r[2] = t, r[3] = r[4] = r[5] = r[6] = 0;
}
};
function ne() {}
(te = {
$ab: null,
$ac: 0,
$ai: null,
$ad: 0,
$8n: Ls,
$ah: Ls,
$aj: Ls,
$ae: Ls,
$af: Ls,
$ag: Ls,
$al: Ls,
$am: Ls,
$ak: Ls,
$an: Ls
}).$8n(), window.foobar = function() {
console.log(te.$aj(te.$ac));
};
var re = gtag;
function ie() {
var e = Zc();
re("event", "reload", {
event_label: (e ? (e.$ju ? e.$ju : "") + "," + (e.$n0 ? "1" : "0") + "," + e.$jk + "," + (e.$k5 ? e.$k5.$cj.substr(6, 3) : "") : "") + "," + window.location.href
});
var t = GLOB[gn[16]]();
if (t.last_ws = "", Oa()[2] && (t.last_nick = ""), GLOB[gn[17]](t), window.history.go) window.history.go(0); else {
var n = window.location.href;
window.location.href = n.endsWith("noads") ? n.substr(0, n.length - 6) : n;
}
}
function ae(e) {
var t = he.indexOf(e);
t >= 0 && he.splice(t, 1);
}
function oe() {
try {
return window.self !== window.top;
} catch (e) {
return !0;
}
}
function se(e) {
return document.getElementById(e);
}
var ce = 5, le = 2e3, ue = new Array(), he = new Array();
function de(e, t) {
if (e.search(new RegExp("Script error")) < 0 && (ce-- > 0 || t)) {
var n = $.get("/log/" + window.GEN_TMSP + e + "/" + CLIENT + "/" + COUNTRY_CODE + "/" + (Dn ? 1 : 0), function() {
ae(n);
}).fail(function() {
ae(n);
});
he.push(n);
}
}
window.onerror = function(e, t, n, r, i) {
console.error("window.onerror:" + t + ":l" + n + ":c" + r + " msg='" + e + "' err='" + i + "'"), 
e.match(new RegExp("SyntaxError: Unexpected token '<'")) ? t.startsWith(window.location.href) && de(("/" + t + ":l" + n + ":c" + r + " msg='" + e + "' err='" + i + "' " + window.ADS_BLOCKED).slice(0, le)) : (de(("/" + t + ":l" + n + ":c" + r + " msg='" + e + "' err='" + i + "' " + window.ADS_BLOCKED).slice(0, le)), 
e.match(new RegExp("uncaught exception: out of memory")) && ie());
};
var pe = new Uint16Array(3);
function fe(e, t) {
var n, r, i, a = (e >>> 16 & 255) / 255, o = (e >>> 8 & 255) / 255, s = (255 & e) / 255, c = Math.max(a, o, s), l = c - Math.min(a, o, s);
return n = 0 === l ? 0 : c === a ? (o - s) / l % 6 : c === o ? (s - a) / l + 2 : (a - o) / l + 4, 
(n *= 60) < 0 && (n += 360), r = 0 === (i = c) ? 0 : l / i, r *= 100, i *= 100, 
t || (t = new Uint16Array(3)), t[0] = n, t[1] = r, t[2] = i, t;
}
function me(e) {
var t = .01 * e[1], n = .01 * e[2], r = n * t, i = n - r, a = e[0] / 60, o = r * (1 - Math.abs(a % 2 - 1)), s = 0, c = 0, l = 0;
return a >= 0 && a < 1 ? (s = r, c = o) : a >= 1 && a < 2 ? (s = o, c = r) : a >= 2 && a < 3 ? (c = r, 
l = o) : a >= 3 && a < 4 ? (c = o, l = r) : a >= 4 && a < 5 ? (s = o, l = r) : (s = r, 
l = o), 255 * (s + i) << 16 | 255 * (c + i) << 8 | 255 * (l + i);
}
var ge, ve, ye = function(e, t) {
return (t = t || new Uint8Array(4))[0] = e >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, 
t[3] = 255 & e, t;
}, $e = (ge = new Uint32Array(2), ve = new Uint8Array(ge.buffer), function(e, t, n) {
return ge[0] = e, ge[1] = t, ve[0] += n * (ve[4] - ve[0]), ve[1] += n * (ve[5] - ve[1]), 
ve[2] += n * (ve[6] - ve[2]), ve[3] += n * (ve[7] - ve[3]), ge[0];
});
function be(e, t, n) {
var r = this;
e = e || 256;
r.$as = ii(), r.$at = 0, r.$av = n, r.$au = e;
for (var i = 0; i < e; ++i) r.$as.push(n());
for (;i < t; ++i) r.$as.push(null);
}
be.prototype.$ao = function() {
var t = this, n = t.$as;
t.$at < t.$au ? e(n.slice(t.$at, t.$au).every(function(e) {
return e;
})) : t.$at > t.$au && (e(n.slice(0, t.$au).every(function(e) {
return e;
})), e(n.slice(t.$at, t.$as.length).every(function(e) {
return e;
})));
}, be.prototype.$ap = function(t) {
e(t);
var n = this, r = n.$as, i = n.$au * (n.$au < r.length), a = i + 1;
a !== n.$at && (n.$au = a), r[i] = t;
}, be.prototype.$aq = function() {
var t = this, n = t.$as;
if (t.$at !== t.$au) {
var r = n[t.$at];
return e(r), n[t.$at++] = void 0, t.$at === n.length && (t.$au === t.$at && (t.$au = 0), 
t.$at = 0), r;
}
}, be.prototype.$ar = function() {
var e = this.$aq();
return e || this.$av();
};
var xe = Math.random, we = Math.sqrt, _e = Math.max, Me = Math.min, Se = Math.cos, Ae = Math.sin, Te = Math.acos, Le = Math.asin, Ce = Math.atan2, Ee = Math.log2, Pe = Math.abs, ke = Math.pow, Oe = Math.exp, De = Math.floor, Ne = Math.ceil, Ie = Math.round, Re = Math.PI, je = Math.sign, Ue = .5 * Re, Be = 2 * Re, ze = 1 / Be, Fe = 75;
!window.GEN_TMSP && (window.GEN_TMSP = "76543210"), vr("Client version: " + Fe + ":" + window.GEN_TMSP);
var Ge, Ve, We = [ "normal", "high" ], qe = 4294967296, He = we(2), Xe = qe - 1, Ye = we(3), Je = (we(.75), 
new $3.Vector3(0, 0, 1)), Ze = 60, Ke = 1e3 / Ze, Qe = !0, et = 1, tt = 5 / (1e3 / Ze * 10), nt = 1, rt = 2, it = 200, at = 1300, ot = 500 / at, st = [ .3, .5 ], ct = 1.25 * Math.max(rt, 1.4), lt = 2e3, ut = .2, ht = .3, dt = ht + .001, pt = .5, ft = pt - .001, mt = pt + .001, gt = .6, vt = .701, yt = 1e4, $t = 8, bt = 16, xt = 32, wt = 64, _t = 1, Mt = 1, St = 1, At = 1, Tt = 2, Lt = 2, Ct = 1, Et = 2, Pt = 4, kt = 4, Ot = 8, Dt = 4, Nt = 2, It = 1, Rt = 2, jt = 1, Ut = 2, Bt = 4, zt = 4, Ft = It + Nt, Gt = 4, Vt = 0, Wt = 1, qt = 2, Ht = 3, Xt = 4, Yt = 0, Jt = 1, Zt = 3, Kt = 4, Qt = 5, en = 20, tn = 12, nn = 4, rn = nn * nn, an = 1, on = .001 / an, sn = 1e3 * an, cn = 1 / an, ln = [ 8, 64 ], un = [ .8, .7 ], hn = [ .2, .17 / .7 ], dn = function(e) {
return [ 0, e[0], [ e[0], 16777215 ], e[1], e[2], fe(e[0])[0] ];
}, pn = [ {
$aw: [ 6356991, 16777024 ].map(function(e) {
return [ (e << 8 | 255) >>> 0, (function(e) {
var t = fe(e);
return me(t = function(e, t) {
return [ e[0], e[1], 100 * t | 0 ];
}(t, Ur(.01 * t[2], 0, .25)));
}(e) << 8 | 255) >>> 0, 4294967295, 4294967295 ];
}),
$ax: [ 0 ],
$ay: [ 0, 865367, 1578, 10539263 ],
$az: 12640511,
$b0: [ 8438015, 12640511 ],
$b2: 404096,
$b3: 2160132064,
$b4: [ 14741503, 14741503 ],
$b1: [ 8438015, 8438015 ],
$b6: [ 16736336, 16744592, 16760896, 16776992, 16777040, 16777088, 16777040, 2158847, 4243711, 6340863, 8421631, 6344959, 2158847, 4243711, 6340863, 8421631, 6344959, 8454016, 6356896, 4259808, 4259808 ].map(function(e) {
return [ e, 16777215 ];
}),
$b7: [ 16777215, 16777215 ],
$b8: [ [ 16744544, 4, [ 6, 18, .7 ] ], [ 16758784, 3, [ 30, 50, 1.3 ] ], [ 16777024, 4, [ 55, 80, 1 ] ], [ 8191816, 4, [ 90, 125 ] ], [ 4259776, 3, [ 135, 165, 1.3 ] ], [ 61695, 3, [ 175, 195, 1.3 ] ], [ 8438015, 4, [ 200, 230, 1.3 ] ], [ 14723327, 4, [ 270, 285, .7 ] ], [ 16748768, 4, [ 310, 320, .7 ] ], [ 16428219, 4, [ 345, 350 ] ] ].map(dn),
$bb: [ 997985, 16776992, 16777120 ],
$bc: [ 11589887, 16777215 ],
$bd: [ 11589887, 16777215 ],
$be: [ "rgba(255,255,255,0.0)", "#b0d8ff", "#f0f8ff", "rgba(176,216,255,0.4)", [ 11589887, 15792383 ] ],
$bf: "#001428",
$bg: "#b0d8ff",
$bh: "#124675",
$bi: "#c0e0ff",
$bj: "#ffffff",
$bk: "#c0e0ff",
$bl: "#8692b2",
$bm: "#e0f0ff",
$bo: {
lbrd: [ 16764928, 16773248 ],
qa: [ 57344, 8454016 ],
"app-store-rate": [ 15794048, 16777184 ],
rmads: [ 16732176, 16748656 ],
"restore-iap": [ 57344, 8454016 ],
"close-btn": [ 12638448, 16777215 ],
settings: [ 8438015, 12574719 ],
contact: [ 16744448, 16755284 ]
},
$bn: [ {
$a1: 255,
$a2: 255,
$a8: .25,
$9w: 1.2,
$9x: 1,
$aa: [ .2, .4 ]
}, {
$a1: 80,
$a2: 16,
$a8: .99,
$9w: 1.2,
$9x: 1,
$aa: [ .2, .4 ]
} ]
} ], fn = Float32Array.of(.9, 1.75, 1.5), mn = 1.5, gn = GLOB.TAGS = "sgnittes_etirwer,sgnittes_teg,sgnittes,redivorp_da_kcip,tini_txe,dekcilc_no_ntb_lrtc,llorerp_tsal,tnc_yalp,qerf_llorerp,da_oediv_trats,dehsinif_da_oediv_no,llorerp_tsal_etadpu,llorerp_tsal_teg,tnc_yalp_teg,tnc_yalp_cni,ffo_sda,repleh_pai_tiaw,elbaliava_sdamr".split("").reduce(function(e, t) {
return t + e;
}, "").split(","), vn = .025, yn = [ .05, .065 ], $n = .25, bn = 1e3, xn = [ 300, 500 ], wn = 1e4, _n = 1, Mn = 5, Sn = 6, An = 8, Tn = 9, Ln = 10, Cn = 11, En = 12, Pn = /android|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|lge |maemo|meego|midp|mmp|mobile|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|fxios/i, kn = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, On = (Ge = navigator.userAgent || navigator.vendor || window.opera, 
Pn.test(Ge) || kn.test(Ge.substr(0, 4)) || CLIENT.startsWith("app/") || navigator.platform && (navigator.platform.match(new RegExp("iPad|iPhone|iPod")) || navigator.platform.startsWith("Mac") && navigator.maxTouchPoints > 1)), Dn = navigator.platform.match(new RegExp("iPad|iPhone|iPod|Mac")) || (navigator.userAgent || navigator.vendor || window.opera).match(new RegExp("Mac")), Nn = On && Math.min(window.screen.width, window.screen.height) <= 480, In = On ? Nn ? 5 : 8 : 10, Rn = Ne(96 / 2.54 * (Nn ? .1 : .13)), jn = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
return window.setTimeout(e, 1e3 / 60);
}, Un = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || window.clearTimeout, Bn = new Array(4), zn = new Float32Array(3), Fn = (new Float32Array(4), 
new Int32Array(4)), Gn = new Int32Array(3), Vn = ii(), Wn = (l = new s(), new O()), qn = 0, Hn = new $3.Color(16777215), Xn = null, Yn = [ .3, 1.5, .7 ], Jn = [ 0, .1 ], Zn = [ 0, .7 ], Kn = "  ", Qn = COUNTRY_CODE || Kn, er = Kn.length, tr = !On || !1, nr = 1e3, rr = 3, ir = 3, ar = 4096, or = ar, sr = Worker && 0, cr = null, lr = Worker && 1, ur = "function cb(x) { postMessage(x); } onmessage = function(e) { setTimeout(cb, e.data[0], e.data[1]); };", hr = document.location.href.match(new RegExp("test")) ? 1 : 0, dr = 0;
function pr(e, t, n, r, i) {
var a = this;
if (a.$cc = new Float32Array(e), n) {
a.$cd = 0;
for (var o = 0; o < e; ++o) a.$cd += a.$cc[o] = n(o);
} else a.$cc.fill(1), a.$cd = e;
a.$c9 = new (i || Float64Array)(e), a.$cb = 0;
for (o = 0; o < e; a.$cb += a.$c9[o] = t * (a.$cc[o] > 0), ++o) ;
a.$ce = r || Math.random;
}
function fr(e) {
return e.toLowerCase();
}
function mr(e) {
var t = e.match(new RegExp("wss?://([^/]+).*"));
return t && t[1] && (document.cookie = "xyz=; path=/; domain=" + t[1] + "; expires=" + new Date(0).toUTCString()), 
new WebSocket(e);
}
function gr(e, t) {
var n = this;
n.$ci = e, n.$cj = (n.$ci.search("localhost"), "wss://" + n.$ci), n.$ck = t, n.$cg = -0, 
n.$ch = 0, n.$cl = null;
}
function vr() {
window.foobar && "web/dev" !== CLIENT || console.log.apply(console, arguments);
}
!function() {
for (var e = pn[0].$b8, t = pn[0].$b9 = new Array(360), n = 0, r = pe.slice(), i = pe.slice(), a = pe.slice(); n < e.length; ++n) {
var o = (n + 1) % e.length;
fe(e[n][1], i), fe(e[o][1], a);
for (var s = i[0], c = a[0] + 360 * (i[0] > a[0]); s <= c; ++s) {
var l = s % 360, u = zr(s, i[0], c);
r[0] = l, r[1] = Ur(i[1], a[1], u), r[2] = Ur(i[2], a[2], u), t[l] = dn([ me(r), Ie(Ur(e[n][3], e[o][3], u)), e[n][4].map(function(t, n) {
return Ur(t, e[o][4][n], u);
}) ]).slice(0, 4);
}
}
t.push(t[0]);
}(), pr.prototype.$c5 = function() {
var t = this, n = t.$cb * t.$ce(), r = 0, i = t.$c9.length, a = 0;
if (n >= t.$cb) return i - 1;
for (;(a += t.$c9[r]) < n; ) ++r;
return e(t.$cc[r]), r;
}, pr.prototype.$c6 = function(e) {
for (var t = this.$cc, n = t.length - 1; n >= 0; --n) t[n] = e(n);
}, pr.prototype.$c7 = function(t, n) {
e(t >= 0 && t < this.$c9.length), n *= this.$cc[t], this.$c9[t] += n, this.$cb += n;
}, pr.prototype.$c8 = function(t, n) {
var r = this, i = r.$c9, a = i.length, o = r.$cc;
for (e(t >= 0 && t < a), r.$cb += n * (r.$cd - o[t]), i[t] -= n * o[t], t = 0; t < a; i[t] += n * o[t], 
++t) ;
}, gr.prototype.$cm = function(e) {
var t, n = this, r = mr(this.$cj + "/ping"), i = Ar(), a = 0, o = 0;
function s(i, a, o) {
t && (clearTimeout(t), t = 0), e && (n.$cf = i, n.$cg = a, n.$ch = o, e(n), e = null), 
r.onopen = r.onerror = r.onclose = r.onmessage = ne, r.readyState !== WebSocket.CLOSED && r.readyState !== WebSocket.CLOSING && r.close();
}
function c(e) {
1001 === e.code && 201 === parseInt(e.reason) ? Tc(bc, mc) : (ue.push("soc " + e.target.url.substr(6, 2) + " " + (0 | Ar())), 
o = Ar(), s(-(e.code + 1e6 * e.wasClean)));
}
function l() {
de("/gsit__[" + i + "," + a + "," + o + "]_" + r.readyState + "_" + r.bufferedAmount + "_" + unescape(decodeURIComponent(n.$cj)) + "_" + Ar()), 
s(-2);
}
r.binaryType = "arraybuffer", r.onopen = function(e) {
ue.push("soo " + e.target.url.substr(6, 2) + " " + (0 | Ar())), a = Ar();
var n = Oa()[2];
if (Ea && n) {
n = ToUTF8(FromString(fr(n)));
var i = new ArrayBuffer(It + 1 + n.length), o = new DataView(i);
o.setUint8(0, ma), o.setUint8(It, n.length), new Uint8Array(i, It + 1, n.length).set(n), 
r.send(i);
} else r.send(new Uint8Array([ ha ]).buffer);
t && (clearTimeout(t), t = setTimeout(l, yt)), r.onclose = c;
}, r.onmessage = function(e) {
ue.push("som " + e.target.url.substr(6, 2) + " " + (0 | Ar()));
var t = new DataView(e.data);
r.onclose = r.onerror = ne, s(Vi(t, It), t.getUint32(It + Lt, Qe) / 65536, t.getUint8(It + Lt + 4));
}, r.onerror = function(e) {
s(-3);
};
}, String.prototype.repeat = function(e) {
if (e < 1) return "";
for (var t = "", n = this.valueOf(); e > 1; ) 1 & e && (t += n), e >>>= 1, n += n;
return t + n;
};
var yr = !1;
function e(e, t) {
if (!e) {
var n = new Error();
yr || (de("/" + ("stack" in n ? n.stack : n.toString()).slice(0, le)), yr = !0, 
Zc().$p8(Kt));
}
}
function $r(e) {
var t = new Map();
return function(n) {
var r = t.get(n);
return r || t.set(n, r = e(n)), r;
};
}
var br, xr, wr, _r = (br = new Map(), function(e) {
var t = br.get(e);
if (!t) {
var n = e.toString(16);
t = "#" + Array(7 - n.length).join("0") + n, br.set(e, t);
}
return t;
}), Mr = (function() {
var e = new Map();
}(), (window.PERFORMANCE_ORIGIN || (window.PERFORMANCE_ORIGIN = performance.timing && performance.timing.navigationStart || performance.timeOrigin)) && "function" == typeof performance.now && function() {
return performance.now();
}), Sr = Mr || function(e) {
return (e > 1e3 * TIME_ORIGIN || e < TIME_ORIGIN) && de("/uet_" + e + "_" + TIME_ORIGIN + "_" + !!performance.now + "_" + performance.timeOrigin + "_" + (performance.timing && performance.timing.navigationStart)), 
.001 * e > TIME_ORIGIN && (e *= .001), e < .1 * TIME_ORIGIN ? e : e - TIME_ORIGIN;
}, Ar = Mr || function() {
return Date.now() - TIME_ORIGIN;
}, Tr = function(e) {
var t = Zc();
return (e || Ar()) - t.$n0;
};
function Lr(e) {
var t = Zc(), n = t.$jq.$cr;
return _e(e, t.$jt, Ne(n.$dh.$es + t.$o2) - t.$jn);
}
function Cr(e) {
var t = Sr(e.timeStamp);
return Lr(Ne(Tr(t < TIME_ORIGIN ? null : t)));
}
function Er(e, t, n) {
return n ? e.getInt32(t + 4, !0) * qe + e.getUint32(t, !0) : e.getUint32(t + 4) + e.getInt32(t) * qe;
}
function Pr(e, t, n) {
return n ? e.getUint32(t + 4, !0) * qe + e.getUint32(t, !0) : e.getUint32(t + 4) + e.getUint32(t) * qe;
}
function kr(e, t, n) {
return Math.max(Math.min(e, n), t);
}
function Or(e) {
return e[e.length - 1];
}
function Dr(e) {
return e * e;
}
function Nr(e) {
return e * e * e;
}
function Ir(e, t) {
for (var n = e.length - 1; n >= 0 && e[n] === t[n]; --n) ;
return n < 0;
}
function Rr(t, n) {
return e(t && n), Math.sqrt(Dr(n[0] - t[0]) + Dr(n[1] - t[1]));
}
function jr(e) {
return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function Ur(e, t, n) {
return e + n * (t - e);
}
function Br(e, t) {
return e + xe() * (t - e);
}
function zr(e, t, n) {
return t === n ? 0 : (e - t) / (n - t);
}
function Fr(e, t, n) {
return e[2] >= t[0] - n && e[0] <= t[0] + n && e[3] >= t[1] - n && e[1] <= t[1] + n;
}
function Gr(e, t, n) {
return e[2] + n >= t[0] && t[2] + n >= e[0] && e[3] + n >= t[1] && t[3] + n >= e[1];
}
function Vr(e, t, n, r, i, a, o, s) {
var c, l, u, h, d, p, f, m;
i = i ? Math.min(.5 * e, i) : 0, a = a ? Math.min(.5 * e, a) : 0, o = o || [ 0, 0, 0 ], 
c = this, l = 4, u = !0, h = $3.TriangleFanDrawMode, d = this.material, p = new Float32Array(3 * l), 
f = new Uint8Array(4 * l), m = new $3.BufferGmtr(), p.fill(0), f.fill(0), c.$8y = new $3.BufferAttribute(p, 3), 
c.$cn = new $3.BufferAttribute(f, 4, !0), u && (c.$8y.setUsage($3.DynamicDrawUsage), 
c.$cn.setUsage($3.DynamicDrawUsage)), m.setAttribute("position", c.$8y), m.setAttribute("clr", c.$cn), 
$3.Mesh.call(c, m, d || Vr.prototype.material), c.drawMode = h, function(e, t, n, r, i) {
var a = e.array, o = n.array, s = i[0], c = i[1], l = i[2], u = i[3], h = i[4], d = i[5], p = i[6], f = i[7];
h = h ? Math.min(.5 * s, h) : 0, d = d ? Math.min(.5 * s, d) : 0, p = p || [ 0, 0, 0 ], 
f ? a.set([ p[0] - h, p[1], p[2], p[0] - d, p[1] + c, p[2], p[0] + s + d, p[1] + c, p[2], p[0] + s + h, p[1], p[2] ], t) : a.set([ p[0] - h, p[1], p[2], p[0] + s + h, p[1], p[2], p[0] + s + d, p[1] + c, p[2], p[0] - d, p[1] + c, p[2] ], t);
var m = ye(l);
o.set(m, r), o.set(m, r + 4), o.set(m = ye(u), r + 8), o.set(m, r + 12), e.needsUpdate = n.needsUpdate = !0;
}(this.$8y, 0, this.$cn, 0, [ e, t, n, r, i, a, o, s ]);
}
function Wr(e) {
e && e.parent && e.parent.remove(e);
}
function qr(e) {
return new $3.WebGLRenderer(e);
}
function Hr(e, t) {
e && (e.firstChild ? e.firstChild.nodeValue !== t && (e.firstChild.nodeValue = t) : e.textContent !== t && (e.textContent = t));
}
Vr.prototype = new $3.Mesh(), Vr.prototype.constructor = Vr, Vr.prototype.material = (xr = $0([ 843, 866, 887, 531, 861, 887, 773, 873, 881, 888, 879, 809, 794, 890, 862, 890, 845, 867, 826, 809, 531, 891 ]), 
wr = $0([ 861, 866, 887, 773, 873, 881, 888, 766, 809, 773, 891 ]), new $3.ShaderMtrl({
vertexShader: xr,
fragmentShader: wr,
side: $3.DoubleSide,
transparent: !0,
blending: $3.CustomBlending,
blendSrc: $3.SrcAlphaFactor,
blendSrcAlpha: $3.OneFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendDstAlpha: $3.OneFactor
})), Vr.prototype.$co = Vr.prototype.material.clone(), Vr.prototype.$co.depthTest = !1, 
Vr.prototype.$cp = function(e, t) {
!function(e, t, n, r) {
for (var i = [ ye(n).slice(), ye(r).slice() ], a = 0; a < 4; ++a, t += 4) e.set(i[a < 2 ? 1 : 0], t);
}(this.geometry.attributes.color.array, 0, e, t), this.geometry.attributes.color.needsUpdate = !0;
};
function Xr(e) {
var t = this;
t.$cq = new Map(), t.$de = e, t.$cr = null, t.$cs = null;
}
Xr.prototype.$ct = function(e) {
var t = this.$de.$k7;
t && t.$hq.clear();
for (var n = this.$cq, r = this.$cr, i = n.values(), a = i.next(); !a.done; a = i.next()) if ((a = a.value) !== r && e >= a.$d4 && 0 == a.$dg && !a.$ct(e) && a.$fi()) {
var o = e;
a.$fq(o, !1), t && t.$hz(a, o);
}
if (r && e >= r.$d4) {
var s = 0 == r.$dg;
if (!s) {
for (var c = r.$d8, l = r.$da - 9; l >= 0 && 256 !== c[l]; l -= 9) ;
s = l >= 0;
}
s && t && t.$hz(r, e);
}
t && t.$i1(e);
}, Xr.prototype.$cu = function(t) {
var n = new si(t), r = this.$de;
return e(!this.$cq.get(n.$d2)), this.$cq.set(n.$d2, n), n.$d2 === r.$d2 && (ue.push("apm " + (0 | Ar()) + " " + (n.$d4 + r.$n0)), 
this.$cr = n, r.$jn = n.$d6, vr("delay = " + n.$d6)), n;
}, Xr.prototype.$cv = function(e) {
return this.$cq.get(e);
}, Xr.prototype.$cw = function(e) {
var t = null;
return Qo(this.$cq, function(n) {
n.$d7 === e && (t = n);
}), t;
}, Xr.prototype.$cx = function(t, n) {
var r = this, i = r.$cv(t), a = i.$de;
e(i), i === a.$m6 && (a.$m6 = null), i === a.$m4 && (a.$m4 = null), i.$fi() && i.$fv(n ? 1 : Ni), 
i.$dd && (Wr(i.$dd), i.$dd = null), i == r.$cr && (r.$cr = null), a.$of.set(t, i.$fg()), 
i.$dq && (r.$ku.$c8(i.$dp / Zr | 0, -Kr), r.$ku.$cb <= 0 && de("/cv_" + r.$ku.$c9), 
i.$dq = !1), r.$cq.delete(t), a.$qf();
};
var Yr = Float32Array.of(.33, 1, 1, 1, 1, 1, 1, 1, .33, .01, .01, .01), Jr = Yr.slice(), Zr = 30, Kr = 1;
function Qr(e, t, n, r, i, a) {
a = a || 0;
var o = 2 * Math.PI;
e += n, t -= r, e = Math.min(e, t), n = Math.min(n, e);
var s = 0 == e || e === t ? 8 : Math.ceil(Math.PI / Math.acos(e / t) * 1.5);
isNaN(s) && (s = 512);
var c = 1 / Math.cos(Math.PI / s), l = e !== t && (0 === e ? new $3.CircleBufferGmtr(t, s, 0, o) : new $3.RingBufferGmtr(e * c, t, s, 1, 0, o)), u = Zc(), h = l ? new $3.Mesh(l, Vr.prototype.$co) : null;
if (l) {
var d = new $3.BufferAttribute(new Uint8Array(4 * l.attributes.position.count), 4, !0);
d.setUsage($3.DynamicDrawUsage), l.setAttribute("clr", d), l.deleteAttribute("normal"), 
l.deleteAttribute("uv");
}
if (r > 0) {
var p = new $3.RingBufferGmtr(t, (t + r) * c, s, 1, 0, o), f = 1 / (1 - ($ = t / (t + r)));
(y = new Float32Array(2 * p.attributes.position.count)).fill($);
for (var m = (w = (x = p.attributes.uv.array).length - 2) >>> 1; w >= 0; w -= 2, 
--m) {
var g = [ 2 * x[w] - 1, 2 * x[w + 1] - 1 ];
x[w] = .5 * (g[0] * c + 1), x[w + 1] = .5 * (g[1] * c + 1), y[w + 1] = f;
}
p.setAttribute("clr", new $3.BufferAttribute(new Uint8Array(4 * p.attributes.position.count), 4, !0)), 
p.setAttribute("uv_range", new $3.BufferAttribute(y, 2)), p.deleteAttribute("normal");
var v = new $3.Mesh(p, u.$i3);
v.renderOrder = a, h ? h.add(v) : h = v;
}
if (n > 0) {
var y, $, b = new $3.RingBufferGmtr(e - n, e * c, s, 1, 0, o);
f = -1 / (1 - ($ = (e - n) / e));
(y = new Float32Array(2 * b.attributes.position.count)).fill(1);
var x, w;
for (m = (w = (x = b.attributes.uv.array).length - 2) >>> 1; w >= 0; w -= 2, --m) {
g = [ 2 * x[w] - 1, 2 * x[w + 1] - 1 ];
x[w] = .5 * (g[0] * c + 1), x[w + 1] = .5 * (g[1] * c + 1), y[w + 1] = f;
}
b.setAttribute("clr", new $3.BufferAttribute(new Uint8Array(4 * b.attributes.position.count), 4, !0)), 
b.setAttribute("uv_range", new $3.BufferAttribute(y, 2)), b.deleteAttribute("normal");
var _ = new $3.Mesh(b, u.$i3);
_.renderOrder = a, h ? h.add(_) : h = _;
}
return h.renderOrder = a, ei(h, i), h;
}
function ei(e, t) {
for (var n = ye(t), r = "Group" === e.type ? e.children : e.children.concat(e), i = 0, a = r.length; i < a; ++i) {
for (var o = r[i].geometry.attributes.clr.array, s = o.length - 4; s >= 0; s -= 4) o.set(n, s);
r[i].geometry.attributes.clr.needsUpdate = !0;
}
}
function ti(e) {
return e;
}
Xr.prototype.clear = function() {
for (var e = this, t = e.$cq.values(), n = t.next(); !n.done; n = t.next()) (n = n.value).$fi() && n.$fv(0), 
n.$dd && (Wr(n.$dd), n.$dd = null);
e.$cq.clear(), e.$cr = null;
var r = GLOB[gn[16]]().player_hue, i = [ r - 60, r + 60 ];
Jr.set(Yr);
for (var a = .5, o = Jr.length; a < o; ++a) for (var s = -1; s <= 1; ++s) if (i[0] <= a * Zr + 360 * s && a * Zr + 360 * s <= i[1]) {
Jr[0 | a] = 0;
break;
}
e.$ku = new pr(Jr.length, 1, function(e) {
return Jr[e];
});
};
var ni = new Map();
function ri(e) {
var t = ni.get(e);
if (t) return t;
var n = ti(filter_profanity(e));
return ni.set(e, n), n;
}
function ii() {
var e = Array.of(Math.sqrt);
return e.shift(), e;
}
function ai(e, t, n) {
var r = this;
r.$cy = e, r.$cz = t, r.$d0 = function(e) {
return Ur(Ho[0], Ho[1], we(kr(zr(e, 50, 1e4), 0, 1)));
}(t), r.$d1 = null;
}
var oi = Float32Array.of(0, 0, 0);
function si(e) {
var t = this, n = t.$de = Zc();
t.$d2 = e.$d2, t.$d3 = e.$d3, t.$d6 = e.$d6, t.$d7 = e.$d7, n.$jm.set(t.$d7, ri(t.$d7)), 
t.$d8 = t.$d9 = null, t.$da = 0, t.$do = e.$do, t.$dp = e.$dp, t.$dq = !1, t.$dr = ii(), 
t.$dh = null, t.$di = e.$di, t.$d4 = Number.MAX_VALUE, t.$ds = e.$ds, t.$dg = -0, 
t.$er = 1;
var r = n.$k0.player_hue;
if (t.$d2 !== n.$d2 && (t.$dp >= 360 || t.$dp === SETTINGS_DEFAULT.player_hue || Pe(t.$dp - r) < Zr || Pe(t.$dp - r) > 360 - Zr || Yr[t.$dp % 360 / Zr | 0] < .1)) {
var i = !1, a = !1;
if (0 !== t.$d3 && ((i = t.$d7.startsWith("Hunter")) || (a = t.$d7.startsWith("Gatherer")) || t.$d7.startsWith("Dummy"))) {
var o = Bn;
if (o[0] = i ? 345 : a ? 190 : 55, o[1] = i ? 385 : a ? 240 : 115, t.$dp = (0 | Br(o[0], o[1])) % 360, 
Pe(t.$dp - r) < 30 || Pe(t.$dp - r) > 330) {
var s = .5 * (o[0] + o[1]);
t.$dp = (r + (Br(.5, .75) * (o[1] - o[0]) | 0) * (s > r && s < r + 180 ? 1 : -1) + 360) % 360;
}
} else {
var c = n.$jq.$ku.$c5();
n.$jq.$ku.$c8(c, Kr), t.$dp = (c + .99 * xe()) * Zr | 0, t.$dq = !0;
}
}
t.$df = n.$hf.$b9[t.$dp], t.$db = new Float64Array(4), t.$dc = new Float64Array(4), 
t.$dj = -0, t.$dd = null;
}
si.prototype.$dt = si.prototype.$dn = null, (si.prototype.$dm = new O()).$9v = new Float32Array(3), 
si.prototype.$du = new Float32Array(3), si.prototype.$dv = new Float32Array(3), 
si.prototype.$dw = new Uint32Array(3), si.prototype.$dx = new Float32Array(3);
var ci = 2, li = 1, ui = .25, hi = [ 30, 33 ], di = 1;
function pi(e) {
var t = this;
t.$e8 = new e.$lc(2), t.$e9 = new e.$lc(2), t.$e6 = !0, t.$f9 = gi * vi / ((t.$f8 = Ie(Ur(hi[0], hi[1], .5) / di) * di) + vi), 
t.$eg = new Int32Array(Ne(gi / t.$f9 + 1)), t.$eh = 0;
var n = Ne(ci * Re / e.$ka + 1);
t.$ec = new e.$ld(2 * n), t.$ee = new e.$lc(2), t.$ef = t.$ed = t.$j7 = t.$j8 = t.$ez = t.$f2 = 0, 
t.$ey = t.$ej = t.$et = t.$e2 = t.$eo = t.$es = t.$e3 = t.$eq = t.$ek = t.$el = t.$dk = t.$dl = t.$f7 = t.$e4 = t.$e5 = t.$ew = t.$f3 = t.$f4 = t.$f5 = t.$fa = -0, 
t.$ep = t.$ex = .999, t.$en = new Float32Array(6), t.$j9 = ii(), t.$em = ii(), t.$eu = new e.$lc(4), 
t.$f0 = t.$f1 = li, t.$f6 = ui;
}
pi.prototype.$e7 = new O(), pi.prototype.$e7.$9w = pi.prototype.$e7.$9x = pi.prototype.$e7.$a9 = pi.prototype.$e7.$a3 = 0;
var fi = [ [ 2e3, 6e3 ], [ 200, 300 ] ], mi = [ 240, 280 ];
si.prototype.$fb = function() {
var e = this, t = e.$de.$lp, n = e.$d5[5] << 2, r = e.$dh = e.$de.$k9.di.$ar();
r.$ey = r.$ef = e.$d5[6], r.$ev = r.$eo = r.$es = r.$e2 = e.$d4, r.$e3 = 1, r.$ep = 0, 
r.$e8[0] = r.$e9[0] = e.$d5[3], r.$e8[1] = r.$e9[1] = e.$d5[4];
var i = r.$eu;
i[0] = i[2] = r.$e8[0], i[1] = i[3] = r.$e8[1], r.$e6 = !0, r.$eh = r.$et = 0, r.$dk = r.$f7 = -0, 
r.$ex = 1, r.$fa = e.$de.$mg;
var a = r.$ec.length / ci | 0;
r.$ee[0] = a * t[n + 0], r.$ee[1] = a * t[n + 1];
for (var o = 0; o < ci * a; o += ci) r.$ec[o] = t[n + 0], r.$ec[o + 1] = t[n + 1];
r.$ed = 0, r.$eq = e.$d4, r.$ei = e.$de.$oy(r.$ey), r.$ej = r.$j7 = r.$j8 = 0, r.$j9.length = 0, 
r.$em.length = 0, r.$ek = Br(fi[0][0], fi[0][1]), r.$ez = 0, r.$ew = e.$df[1], r.$f0 = r.$f1 = li, 
r.$f2 = 0, r.$f3 = r.$f4 = r.$f5 = -0, r.$f6 = ui, r.$f9 = gi * vi / ((r.$f8 = Ie(Br(hi[0], hi[1]) / di) * di) + vi), 
r.$eg = new Int32Array(Ne(gi / r.$f9 + 1));
}, si.prototype.$fc = function(e, t) {
var n = this.$dh, r = this.$de, i = n.$ec, a = n.$ed % i.length, o = this.$d8, s = o[e + 5] << 2, c = r.$lp, l = c[s + 0], u = c[s + 1], h = Ce(u, l);
n.$ee[0] += l - i[a], n.$ee[1] += u - i[a + 1], i[a] = l, i[a + 1] = u, n.$ed += ci;
for (var d = 0, p = 0, f = h, m = e, g = t, v = _e(t - Re / r.$p0(r.$ik) * r.$ja | 0, o[1]); g > v; m -= 9) {
var y = o[m + 5] << 2, $ = g - _e(o[m + 1], v), b = Ce(c[y + 1], c[y + 0]), x = b - f, w = zr(g, v, t);
Pe(x) > Re && (x -= Be * je(x)), g -= $, Pe(d += x * w) > Re && (x -= Be * je(d)), 
p += _e(Pe(x * w), r.$p0(o[m + 6]) * $ / (y & ar ? r.$jb : r.$ja) * w), f = b;
}
n.$ej = p ? d / p : 0, n.$ej = kr(n.$ej, -1, 1);
}, si.prototype.$fd = function(e) {
if (0 !== (t = this).$dr.length) {
for (var t = this, n = 0, r = ii(); n < t.$dr.length; ++n) {
var i = t.$dr[n];
e - i.$cy > Xo ? i.$d1 && (i.$d1[0].visible = i.$d1[1] = !1) : r.push(i);
}
t.$dr = r;
}
}, si.prototype.$fe = function(e) {
for (var t = this, n = t.$dh, r = t.$de, i = 0; i < t.$dr.length; ++i) {
var a = t.$dr[i], o = (e - a.$cy) / Xo, s = r.$mb, c = s.getContext("2d", xo), l = (r.$hk.right - r.$hk.left) / (r.$k8.width * window.devicePixelRatio);
if (!a.$d1 && o > 0) for (var u = 0; u < r.$md.length; ++u) if (!r.$md[u][1]) {
(a.$d1 = r.$md[u])[1] = !0;
var h = $e((t.$df[1] << 8 | 255) >>> 0, 4294967295, .5);
Wo.has(h) ? c.fillStyle = Wo.get(h) : Wo.set(h, c.fillStyle = Zo(h >> 8, 255));
var d = Jo(Ho[1]);
c.clearRect(0, s.height - (u + 1) * d, s.width, d), c.font = a.$d0 + "px sans-serif";
var p = "+" + a.$cz, f = .5 * (s.width - c.measureText(p).width) | 0;
c.fillText(p, f, s.height - (u + .5) * d | 0), r.$mc.needsUpdate = !0;
break;
}
if (a.$d1) {
var m = a.$d1[0], g = Ur(1, .5, Nr(1 - o));
m.scale.set(g * s.width * l, g * l * (Jo(Ho[1]) + 1 * window.devicePixelRatio), 1), 
m.position.set(n.$e8[0] * r.$i8, (n.$e8[1] + n.$ei * r.$ih) * r.$i8 + (.5 + .5 * g) * Jo(Ho[1]) * l, mt), 
m.material.opacity = 1 - Nr(o), m.visible = !0;
}
}
}, si.prototype.$ff = function(e, t) {
var n = this.$dh, r = Pe(Ce(t, e) - Ce(n.$ee[1], n.$ee[0]));
return r - Be * (r > Re);
}, si.prototype.$fg = function() {
var e, t = this;
return (t.$de.$k0.show_flags && t.$do !== Kn && !t.$de.$o0 ? es(t.$do) : "") + (t.$de.$kb && t.$d2 === t.$de.$d2 ? t.$d7 : t.$de.$jm.get(t.$d7)) + (qo ? "(" + ((e = t.$dh.$ef) < 1e3 ? e : (.001 * e | 0) + (e % 1e3 < 100 || e > 1e4 ? "" : "." + (e % 1e3 * .01 | 0)) + "k") + ")" : "");
};
var gi = 500, vi = 8, yi = 5 + vi, $i = 1 / vi, bi = 1 / gi, xi = function() {
for (var e = new Float32Array(yi * gi), t = 0, n = 0; t < yi; ++t) for (var r = 0; r < gi; ++r) e[n++] = .5 * (1 + Se(Me(1, Pe(t - (r * bi * yi - vi)) * $i) * Re)) * (1 - r * bi);
return e;
}();
si.prototype.$fh = function() {
var e = this, t = e.$dh;
if (!t.$e6) {
for (var n = t.$j9, r = t.$j7 - 1, i = e.$de.$i4; r >= 0; --r) n[r].$8q();
for (n = t.$em, r = t.$em.length - 1; r >= 0; --r) n[r].$8o(i, 1025);
t.$e6 = !0, t.$ev = t.$es, t.$j7 = t.$j8 = 0, e.$dd && (e.$dd.visible = !1);
}
}, si.prototype.$fi = function() {
return this.$d4 !== Number.MAX_VALUE;
}, si.prototype.$fj = new Map(), si.prototype.$fk = function(e) {
var t = this, n = t.$de, r = t.$dh, i = 0, a = e - 9, o = r.$es, s = 0 | _e(t.$d4, o - 1500), c = t.$d8, l = c[e + 6], u = c[e + 5] << 2, h = 1 / n.$jd;
r.$eo = o;
for (var d = e, p = o - n.$jd * t.$er; d >= 0 && c[d + 1] >= p; d -= 9) if (8 === c[d]) {
var f = -c[d + 2] - (o - c[d + 1]) * h;
f > 0 && (l += f, r.$eo = c[d + 1]);
}
if (r.$ey = l, u >>> 2 & ar) {
for (;a >= 0 && c[a + 1] >= s && c[a + 5] & ar; ) a -= 9;
0 == r.$e4 && (r.$e4 = c[a + 9 + 1], r.$e5 = 0, r.$e3 = r.$ep);
} else {
for (;a >= 0 && c[a + 1] >= s && !(c[a + 5] & ar); ) a -= 9;
0 != r.$e4 && (r.$e4 = 0, r.$e5 = c[a + 9 + 1], r.$e3 = r.$ep);
}
0 != r.$e4 ? i = o < r.$e4 + 1500 ? r.$e3 + (1 - Nr(1 - (o - r.$e4) / 1500)) * (1 - r.$e3) : 1 + 0 * (Ae((o - (r.$e4 + 1500)) / 800 * Be) - 1) : 0 != r.$e5 && (o < r.$e5 + 1500 ? i = (1 - Dr((o - r.$e5) / 1500)) * r.$e3 : (i = 0, 
r.$e5 = 0)), r.$ep = kr(i, 0, 1);
}, si.prototype.$fl = function(e, t) {
for (var n = this.$dh, r = n.$eg, i = n.$eh, a = e - gi; i > 0 && r[i - 1] > a; --i) ;
i > 0 && (r.copyWithin(0, i, n.$eh), n.$eh -= i), n.$ef < t && (0 === n.$eh || e - r[n.$eh - 1] > n.$f9) && (r[n.$eh++] = e);
}, si.prototype.$fm = function(e, t, n, r) {
var i = this, a = i.$fj.get(e);
if (a ? (a[0] = Me(a[0], t), a[1] = _e(a[1], t)) : i.$fj.set(e, Uint32Array.of(t, t, 1)), 
n) {
a = i.$fj.get(n);
var o = r.$8k >>> n.$99;
a[1] = _e(a[1], o);
}
}, si.prototype.$fn = function(n) {
var r = this, i = r.$dh, a = r.$de, o = a.$nb, s = a.$nd, l = i.$j9, u = a.$k9.pai, h = 0, d = n, p = r.$fj;
if (nt) {
var f = a.$jh, m = c, g = c, v = null, y = null, $ = null, b = null, x = (i.$et, 
i.$ei * a.$i8 * a.$ih), w = x * Ur(Pi[0], Pi[1], i.$ep), _ = x * Ur(ki[0], ki[1], i.$ep), M = 0 | Ur(Oi[0], Oi[1], i.$ep), S = 0 | Ur(Di[0], Di[1], i.$ep), A = ki[0] / (Pi[0] + ki[0]);
f.$8h();
for (var T = d - 1; T >= 0; --T) if (0 !== s[T]) {
l.length === h ? (l.push(m = u.$ar()), f.$8e(i.$e7, m, g)) : null === (m = l[h]).$8j ? f.$8e(i.$e7, m, g) : 3 != (3 & m.$8m) && (m.$8q(), 
f.$8e(i.$e7, m, g)), m.$8m = T << 2 | 3;
var L = m.$8j, C = 3 * (F = m.$8k >>> L.$99) | 0;
v !== L && (r.$fm(L, F, v, g), v = L, y = L.$9b, $ = L.$9d, b = L.$9i);
var E = o[T][0];
y[C] = E[1], y[C + 1] = E[2];
var P = o[T][3][0];
$[C] = $[C + 1] = w + _ * P, $[C + 2] = A, b.setUint8(F, M + S * P | 0), g = m, 
++h;
}
if (g !== c) {
var k = p.get(g.$8j), O = g.$8k >>> g.$8j.$99;
k[0] = Me(k[0], O), k[1] = _e(k[1], O);
}
for (var D = h, N = i.$j8; D < N && null !== l[D].$8j; ++D) l[D].$8q();
h = i.$j8 = _e(h, N);
}
f = a.$jg, m = c, g = c, v = null, y = null, $ = null, b = null;
f.$8h();
T = d - 1;
for (var I = 3 * -(3 - (d % 3 == 0)); T >= I; T -= 3) for (var R = 0; R < 3; ++R) for (var j = Me(d - 1, T + 3 * R), U = _e(0, T + 3 * (R - 1) + 1); j >= U; --j) if (0 !== s[j]) for (var B = 0 | (E = o[j][R])[0], z = 1; B > 0; --B) {
l.length === h ? (l.push(m = u.$ar()), f.$8e(i.$e7, m, g)) : (null === (m = l[h]).$8j && f.$8e(i.$e7, m, g), 
e(g === c || !0 === g.$8r(m))), m.$8m = j << 2 | R;
var F;
L = m.$8j, C = 3 * (F = m.$8k >>> L.$99) | 0;
v !== L && (r.$fm(L, F, v, g), v = L, y = L.$9b, $ = L.$9d, b = L.$9i), y[C] = E[z++], 
y[C + 1] = E[z++], $[C] = $[C + 1] = E[z++], $[C + 2] = E[z++], b.setUint32(F << 2, E.dv.getUint32(z++ << 2)), 
g = m, ++h;
}
if (g !== c) {
k = p.get(g.$8j), O = g.$8k >>> g.$8j.$99;
k[0] = Me(k[0], O), k[1] = _e(k[1], O);
}
var G = p.keys();
for (L = G.next(); !L.done; L = G.next()) {
L = L.value;
(k = p.get(L))[0] <= k[1] && (k[1] = k[1] - k[0] + 1, t(L.$8y.updateRange, 3 * k[0], 3 * k[1]), 
t(L.$90.updateRange, 3 * k[0], 3 * k[1]), t(L.$91.updateRange, k[0] * L.$91.itemSize, k[1] * L.$91.itemSize), 
L.$8y.needsUpdate = L.$90.needsUpdate = L.$91.needsUpdate = !0), k[0] = 4294967295, 
k[1] = 0;
}
for (D = h; D < i.$j7; ++D) l[D].$8q();
i.$j7 = h;
}, si.prototype.$fo = function() {
var e = this.$de, t = e.$oy(e.$ii[1]);
return Ur(1, Ur(e.$ie / t, 1, .6), zr(this.$dh.$ei, e.$ie, t));
}, si.prototype.$fp = function(e) {
var t = this, n = t.$de, r = t.$dh, i = t.$dh.$es, a = n.$nb[0][2], o = r.$en, s = r.$ei * n.$i8, c = t.$fo(), l = s * Ur(1, n.$ih, c), u = .36 * s, h = r.$ep, d = l * Ur(.45, .42, h), p = Pe(r.$ej), f = Ur(.1, 1, i < r.$ek || i > r.$ek + r.$el ? 1 : i < r.$ek + .35 * r.$el ? Dr(1 - (i - r.$ek) / (.35 * r.$el)) : 1 - Dr(1 - (i - r.$ek - .35 * r.$el) / (.65 * r.$el))), m = t.$fr(i, !1), g = t.$d8, v = g[m + 5] << 2, y = n.$lp, $ = Ce(y[v + 1], y[v + 0]), b = $, x = _e(0, i - r.$eq) * (1 / 3e3) % 1 * Be, w = n.$k3 * n.$if, _ = n.$jg, M = r.$j9[r.$j7 - 1];
i >= r.$ek + r.$el && 0 === h && (r.$ez = !r.$ez && xe() < .25 ? 1 : 0, r.$ek = i + Br(fi[r.$ez][0], fi[r.$ez][1]), 
r.$el = Br(mi[0], mi[1]));
for (var S = g[m + 5] & ar ? n.$jb : n.$ja, A = m + 9, T = t.$da; A < T && g[A + 1] < i + S; A += 9) if (4 === g[A]) {
v = g[A + 2] << 2;
var L = Ce(y[v + 1], y[v + 0]);
Pe($ - L) > Re && (L -= Be * je(L - $)), b = Ur(L, $, (g[A + 1] - i) / S);
break;
}
var C = -Re * Ur(.12, .18, h) * p * je(r.$ej), E = t.$dm;
E.$9v[2] = 0, E.$9z = $e($e(Ii(t.$df[1]), 4294967295, .5 * _e(h, (1 - h) * e)), a.dv.getUint32(20), .5), 
o[0] = a[1] - .1 * l * Se(b), o[1] = a[2] - .1 * l * Ae(b);
for (var P = 0; P < 2; ++P) {
var k = r.$ej > 0 == (0 === P), O = b + C + (1 - 2 * P) * Re * Ur(.24, .24, k ? 1 - p : 1), D = d + p * u * (k ? .01 : 0);
o[2 * P + 2] = (E.$9v[0] = a[1] + D * Se(O)) - o[0], o[2 * P + 3] = (E.$9v[1] = a[2] + D * Ae(O)) - o[1], 
E.$9w = u * (1 + .5 * e + .25 * h * (.5 * (1 - Se(x))) + p * (.15 + .1 * h) * (k ? 1 : -.1)) * f, 
E.$a8 = .8 * w / E.$9w, P < r.$em.length ? r.$em[P].$8r(M) && (r.$em[P].$8q(), _.$8e(r.$e7, r.$em[P], M)) : r.$em.push(_.$8e(r.$e7, n.$k9.pai.$ar(), M)), 
r.$em[P].$8o(E, 1348);
}
};
var wi = Be / 1e3, _i = Re / ke(.5, 1 / 1.5), Mi = function() {
for (var e = new Float32Array(512), t = 0, n = 0; t < 512; ++t, n += 1 / 512) {
var r = n < .5 ? n * _i : ke(n, 1.5) * Be;
e[t] = .5 * (1 - Se(r));
}
return e;
}(), Si = 512, Ai = null, Ti = function() {
for (var e = new Float32Array(512), t = 0, n = 0; t < 512; ++t, n += 1 / 512) {
var r = n;
e[t] = -.5 * Se(r * Be - Ue);
}
return e;
}();
si.prototype.$fq = function(t, n) {
var r = this, i = r.$de, a = r.$dh, o = t, s = t - a.$es;
if (0 !== s) {
var c = r.$d8, l = 1, u = r.$d9;
if (c[l] < o) for (l = r.$da - 9 + 1; c[l] >= o; ) l -= 9;
if (262913709 === c[(l -= 1) + 3]) {
for (var h = l; l > 0 && 262913709 === c[l + 3]; ) l -= 9;
de("/error/um_" + t + "_" + l + "_" + c[l + 0] + "_" + c[l + 1] + "_" + (i.$d2 === r.$d2) + "_" + r.$dh.$es + "_" + r.$dh.$ev + "__" + h + "_" + c[h + 0] + "_" + c[h + 1] + "__" + r.$da + "__t=" + JSON.stringify(Array.from(c.subarray(l, h + 9))));
}
e(262913709 !== c[l + 3]);
var d = c[l + 5] << 2, p = c[l + 6], f = i.$lp, m = (i.$lq, i.$lr, i.$ii[1], i.$oy(p)), g = a.$eu, v = m - a.$ei, y = .001 * i.$ie * .5;
a.$ei = a.$ei + je(v) * Me(s * y, Pe(v)) | 0;
var $ = a.$ei, b = i.$i8, x = $ * b, w = r.$fo(), _ = w * $ * (i.$ih - 1), M = i.$m0, S = ($ + _) * (2 - M[4]) | 0, A = r.$d2 === i.$d2, T = a.$ex = 1 - Pe(a.$ej), L = Fn, C = S + (n ? 1 : 0) * _e.apply(null, Li) * i.$iq;
if (L[0] = i.$lo[0] - C, L[1] = i.$lo[1] - C, L[2] = i.$lo[2] + C, L[3] = i.$lo[3] + C, 
A && (i.$mw = x), Gn[0] = a.$e8[0], Gn[1] = a.$e8[1], a.$es = t, a.$e8[0] = c[l + 3] + (o - c[l + 1]) * f[d + 2], 
a.$e8[1] = c[l + 4] + (o - c[l + 1]) * f[d + 3], i.$jk === qt && jr(a.$e8) > 1.1 * i.$id) {
var E = new Array(), P = 0;
for (h = r.$da - 9; h >= 0 && P < 3; ++P, h -= 9) (E = Array.from(c.slice(h, h + 7)).concat(E))[3] = Number(E[3] / i.$j4).toFixed(3), 
E[4] = Number(E[4] / i.$j4).toFixed(3);
h >= 0 && ((E = Array.from(c.slice(0, 7)).concat(E))[3] = Number(E[3] / i.$j4).toFixed(3), 
E[4] = Number(E[4] / i.$j4).toFixed(3));
i.$cl.url.startsWith("wss://sa2") || i.$cl.url.startsWith("wss://au1");
de("/ooao " + r.$d7 + "/" + i.$jq.$cr.$d7 + "/" + i.$nn + (n ? " force " : " ") + i.$js + " " + t + "/" + i.$kn[i.$q4(i.$ko)] + "/" + r.$d4 + "/" + s + "/" + i.$kk + " [" + Number(Gn[0] * i.$i8).toFixed(3) + "," + Number(Gn[1] * i.$i8).toFixed(3) + "][" + Number(a.$e8[0] * i.$i8).toFixed(3) + "," + Number(a.$e8[1] * i.$i8).toFixed(3) + "] " + Number(jr(a.$e8) / i.$id).toFixed(3) + "," + Number(jr(Gn) / i.$id).toFixed(3) + " " + i.$n1 + "/" + (i.$n5 - i.$n1) + "/" + (i.$n0 - i.$n1) + " " + te.$aj(20) + " " + r.$da + " [" + E + "] " + ue), 
ce = 0;
}
if (r.$fc(l, t), r.$fd(t), a.$f0 = kr(a.$f0 + je(1 - T - a.$f0) * Me(Pe(1 - T - a.$f0), s / 1500), 0, 1), 
A || a.$ev === r.$d4 || Gr(L, g, $) || Fr(L, a.$e9, $ + (o - a.$ev) * i.$iq)) {
var k = x * i.$ih, O = x * Ur(1, i.$ih, w), D = i.$lu, N = (i.$oz(p), i.$lm + Me(i.$ln, i.$ln * ($ - i.$ie) / i.$ig | 0)), I = x / (.5 * (x + O)), R = _e(0, 1 - (o - r.$d4) / (i.$m3 + 1500));
r.$fk(l), r.$fl(0 | o, p), a.$ef = p, a.$eq -= s * (4 * i.$ip * a.$ep + Br(2, 4) + Ae(Be * Dr(5e-4 * (o - r.$d4) % 1)));
var j = a.$ep, U = j * (0 === R), B = a.$ey, z = (fe(r.$df[1], pe), pe[0] += r.$df[3] * Se((o - r.$d4) * wi), 
pe[0] += pe[0] < 0 ? 360 : pe[0] >= 360 ? -360 : 0, Ii(me(pe))), F = i.$k3 * i.$if, G = M[3], V = M[5], W = M[0] - M[2], q = (M[2], 
M[4], 25e-5 * t), H = _e(0, t - a.$eq) * (1 / 3e3), X = 0 | H, Y = a.$et = 1 - H % 1, J = r.$du, Z = r.$dv, K = r.$dw, Q = -0 != a.$dk && o < a.$dk + 400 ? Ur(.5, 1, a.$f7) * _e(0, o - a.$dk) / 400 : 0, ee = 0 === Q ? 0 : .5 * (1 - Se(ke(Q, .4) * Be)), ne = A && 0 !== Q ? .5 * Oe(-Q) * (1 - Se(10 * Q * Be)) : 0, re = r.$dt, ie = i.$nb, ae = i.$nd, oe = a.$eg, se = a.$f8, le = (a.$f9, 
0 | Ie(se / di)), he = 1 / se, ge = 1 / le, ve = se + 2, ye = ve + yi * (a.$eh > 0), be = le + 2, Te = be + yi * (a.$eh > 0), Le = _e(ye, Te);
o >= a.$dk + 400 && (a.$f7 = -0), K[1] = Ii(r.$df[0]), Z[0] = 2 * (k - x), Z[1] = 2 * (k - x), 
Z[2] = .8 * (1 - D) * x, g[0] = g[2] = re[0] = a.$e8[0], g[1] = g[3] = re[1] = a.$e8[1];
var Ce = 0, Ee = 0, De = 0, Re = r.$dx, Ue = 1, ze = 1, Fe = 0, Ge = 1, We = o, qe = i.$no;
i.$np, i.$nq;
X > a.$f2 && (a.$f2 = X, t > a.$f4 + 4e3 && (a.$f4 = a.$f5 = -0), xe() < a.$f3 ? (a.$f3 = -0, 
-0 === a.$f4 && (a.$f4 = t, a.$f5 = Br(.3, .7))) : a.$f3 += (1 - a.$f1) * Br(0, .1), 
a.$f1 = Me(1, a.$f0 + (a.$f4 > 0 ? .5 * a.$f5 * (1 - Se((t - a.$f4) / 4e3 * Be)) : 0)));
var He = Ur(ui, .6, _e(.8 * j / .6, a.$f1)) - a.$f6;
(4 * (H + .25) & 2) == (He < 0) << 1 && (a.$f6 += je(He) * Me(Pe(He), Ur(i.$ip, 1, j) * s / 1500));
var Xe = A ? 1 : Ur(Me(1, i.$mw / x), 1, .33), Ye = Ur(1, .5, .5 * (1 - j + T)) * (1 + .2 * Se(q * Be) * (1 - j)) * Xe, Je = Ur(.4, .8, _e(.8 * j, a.$f1)) * (1 + .2 * Se(1.5 * q * Be)) * Xe;
for (Re[0] = (M[0] - 1 + W * (1 * ne)) * x + Z[0] * (.4 + .4 * j), Re[1] = (M[2] - 1 + W * (1 * ne)) * x + Z[1] * (.5 + .3 * j), 
Re[2] = (M[4] - 1 + W * (2 * ne)) * x + Z[2] * (-.5 + a.$f6), J[0] = Z[0] * Ye * (1.1 - .5 * j), 
J[1] = Z[1] * Ye * (1 - .4 * j), J[2] = Z[2] * Je; l >= 0; ) {
var Ze = Me(B - Ce, i.$im), Ke = 0 | Ze, Qe = qe[Ke], et = i.$np[Ke] + i.$nq[Ke] * (Ze - Ke);
if (Fe >= Qe + et) break;
if (Ge, Ge = Qe - Fe >= 1 ? 1 : et, 0 === Fe) s = o - c[l + 1]; else for (var tt = Ge * (Fe > 1 ? ze = Ve[Ue = N] : i.$lv * (ze = Ve[Ue = Ne(N * i.$lv)])), nt = 1 / tt, rt = tt, it = Ue - 1 << 1; ;) {
var at = c[l + 1];
if ((rt -= (We - at) * u[l + 7]) <= 0) {
We = at + (s = -rt * u[l + 8]);
var ot = 2 + (c[l + 5] << 2);
if (re[it] = c[l + 3] + s * f[ot], re[it + 1] = c[l + 4] + s * f[ot + 1], 0 === it) break;
it -= 2, rt = tt;
} else if (re[it] = c[l + 3], re[it + 1] = c[l + 4], We = at, 16 === c[l] && (Ee += c[l + 2]) > Fe - 1 && (Ce = _e(Ce, Ee - (Fe - (rt * nt + (it >>> 1)) * ze))), 
(l -= 9) < 0) {
Ge = 1, re.set(re.subarray(it, Ue << 1)), ze = Ve[Ue -= it >>> 1];
break;
}
}
if (1 & Fe || (re[0] < g[0] ? g[0] = re[0] : re[0] > g[2] && (g[2] = re[0]), re[1] < g[1] ? g[1] = re[1] : re[1] > g[3] && (g[3] = re[1])), 
Fe >= Le && (L[2] < re[0] || L[0] > re[0] || L[3] < re[1] || L[1] > re[1])) ae[Fe++] = 0; else {
ae[Fe] = 1;
var st = ie[Fe], ct = st[0], lt = ct.dv, ut = st[1], ht = ut.dv, dt = st[2], pt = dt.dv, ft = st[3], mt = Fe >= ve && 1 === Ge && ie[2 + (Fe - ve) % se], gt = Fe >= be && 1 === Ge && ie[2 + (Fe - be) % le], vt = 0;
if (Fe < yi) {
if (j < 1) {
for (h = a.$eh - 1; h >= 0; --h) vt = _e(vt, xi[Fe * gi + (o - oe[h] | 0)]);
vt *= 1 - j;
}
0 === Fe && (De = vt);
}
if (Fe >= ye && mt) {
var yt = ie[ye - se + (Fe - ye) % se];
K[0] = yt[0].dv.getUint32(20);
} else {
var $t = .68 + .32 * _e(j, ee, vt * (2 - vt)), bt = $e(z, 255, .4 * $t), xt = $e(z, 4294967295, .5 * $t), wt = Y + Fe * he, _t = Mi[512 * (wt - (0 | wt)) | 0];
K[0] = $e(bt, xt, _t);
}
if (Fe >= Te && gt) {
var Mt = ie[Te - le + (Fe - Te) % le];
e(Mt), K[2] = Mt[2].dv.getUint32(20);
} else {
$t = .68 + .32 * _e(j, ee, vt * (2 - vt)), bt = $e(z, 255, .4 * $t), xt = $e(z, 4294967295, .5 * $t);
var St = Y + Fe * ge, At = St - (0 | St), Tt = Mi[512 * At | 0];
K[2] = 4294967040 & $e(bt, xt, Tt) | 143 + 112 * Ge;
}
if (mt) {
if (ct.set(mt[0]), ut.set(mt[1]), Ue > 1) for (var Lt = 6, Ct = Ue - 1 << 1, Et = 1 + 5 * Ue; Lt < Et; Ct -= 2) ut[Lt] = ct[Lt] = re[Ct] * b, 
ut[++Lt] = ct[Lt] = re[Ct + 1] * b, Lt += 3, lt.setUint32(Lt << 2, K[0]), ht.setUint32(Lt << 2, K[1]), 
++Lt;
ft[0] = mt[3][0];
} else {
var Pt = (1 === Ge ? x : x * we(Ge)) * Ai[Ge * Si | 0], kt = _t - .5;
if (ut[0] = ct[0] = Ue, Fe > 0 ? (ct[3] = Pt + Re[0] + J[0] * (.3 + kt * (1 - j) + .1 + .1 * j), 
ut[3] = Pt + Re[1] + J[1] * kt, ct[4] = F / ct[3]) : (ct[3] = O + Re[0] + J[0] * (.1 + .3 * kt + .1 * j), 
ut[3] = O + Re[1] + J[1] * (.33 * kt - .2), ct[4] = I * F / ct[3], a.$ew = K[0] >>> 8, 
J[1] *= 1 + .4 * U), ut[4] = G * ct[4], Ue > 1) if (1 === Fe) {
Lt = 6, Ct = Ue - 1 << 1, Et = 1 + 5 * Ue;
for (var Ot = 1 - ze, Dt = ct[3], Nt = ie[Fe - 1][0][3] - Dt, It = ut[3], Rt = ie[Fe - 1][1][3] - It; Lt < Et; Ct -= 2, 
Ot -= ze) ut[Lt] = ct[Lt] = re[Ct] * b, ut[++Lt] = ct[Lt] = re[Ct + 1] * b, ct[++Lt] = Dt + Ot * Ot * Nt, 
ut[Lt] = It + Ot * Ot * Rt, ct[++Lt] = ct[4], ut[Lt] = ut[4], ++Lt, lt.setUint32(Lt << 2, K[0]), 
ht.setUint32(Lt << 2, K[1]), ++Lt;
} else {
Lt = 6, Ct = Ue - 1 << 1, Et = 1 + 5 * Ue;
var jt = ((Dt = ie[Fe - 1][0][3]) - ct[3]) * ze, Ut = (Dt = Dt - jt, ((It = ie[Fe - 1][1][3]) - ut[3]) * ze);
for (It = It - Ut; Lt < Et; Ct -= 2, Dt -= jt, It -= Ut) ut[Lt] = ct[Lt] = re[Ct] * b, 
ut[++Lt] = ct[Lt] = re[Ct + 1] * b, ct[++Lt] = Dt, ut[Lt] = It, ct[++Lt] = ct[4], 
ut[Lt] = ut[4], ++Lt, lt.setUint32(Lt << 2, K[0]), ht.setUint32(Lt << 2, K[1]), 
++Lt;
}
ft[0] = _t;
}
if (gt) dt.set(gt[2]); else {
if (dt[0] = 1, Fe > 0) {
Pt = (1 === Ge ? x : x * we(Ge)) * Ai[Ge * Si | 0];
var Bt = Ti[512 * At | 0];
dt[3] = Pt + Re[2] + J[2] * Bt;
} else dt[3] = 0;
dt[4] = V * ct[4];
}
lt.setUint32(20, K[0]), ht.setUint32(20, K[1]), pt.setUint32(20, K[2]), dt[1] = ut[1] = ct[1] = re[0] * b, 
dt[2] = ut[2] = ct[2] = re[1] * b, ++Fe;
}
}
a.$e2 = Me(a.$eo, c[_e(0, l) + 1]), a.$e9[0] = a.$e8[0], a.$e9[1] = a.$e8[1], Gr(L, g, $) ? (a.$e6 = !1, 
r.$dd && !r.$dd.visible && (r.$dd.visible = t >= r.$d4), r.$fn(Fe), a.$j7 > 0 && r.$fp(De), 
r.$fe(t)) : a.$e6 ? a.$ev = t : r.$fh();
} else r.$fh();
}
}, si.prototype.$fr = function(e, t) {
var n = this.$d8;
if (n[1] > e) return 0;
for (var r = this.$da - 9 + 1; n[r] > e; ) r -= 9;
if (t) {
if (262913709 === n[3]) return 0;
for (var i = r - 1 + 3; 262913709 === n[i]; ) i -= 9;
r = i - 3 + 1;
}
return r - 1;
}, si.prototype.$fs = function(t) {
var n = this, r = n.$de, i = n.$d8, a = 0, o = 9 * t;
for (e(o < n.$da); a < o; a += 9) 386 & i[a] && r.$qn(i[a + 2]);
i.copyWithin(0, o, n.$da), n.$da -= o;
}, si.prototype.$ct = function(e) {
for (var t = this, n = t.$de, r = n.$lp, i = n.$lr, a = n.$ii[1], o = t.$d5, s = t.$d8, c = t.$d9, l = t.$da, u = l - 9 + 3; 262913709 === s[u]; ) u -= 9;
for (u += 6; u < l && s[u + 1] <= e; u += 9) {
var h = s[u + 1] - s[u - 9 + 1], d = o[5] << 2, p = s[u];
if (o[3] += r[d + 2] * h, o[4] += r[d + 3] * h, 4 === p) o[5] = (o[5] & ar) + s[u + 2]; else if (24 & p) o[6] += s[u + 2]; else if (32 === p) o[5] |= ar; else if (64 === p) o[5] &= ~ar; else if (128 === p) {
if (n.$p1()) if (0 === (w = n.$m1.get(s[u + 2]))[0]) Fr(n.$lo, o.subarray(3), Ao * n.$j4 * .5) && n.$jl && n.$jl.visible && n.$pe(s[u + 1], Ce(w[1][1], w[1][0]), Ce(r[d + 1], r[d + 0]), !!(o[5] & ar)); else {
if (t.$d2 === n.$d2) {
n.$ox(w[1], zn);
var f = Pe((zn[0] - n.$l9[0]) / n.$hk.right), m = Pe((zn[1] - n.$l9[1]) / n.$hk.top), g = _e(0, (f + m < 2) * (1 - Rr(n.$l9, zn) / (.5 * (n.$hk.right + n.$hk.top))) * (1 - .4 * (1 - (w[2] >>> 1)) - .3 * (1 - (1 & w[2]))));
n.$pj(e, 1200), n.$mv = Ur(st[0], st[1], g), t.$dh.$f7 = g;
} else t.$dh.$f7 = 1;
if (t.$d2 === n.$d2 && n.$jk === qt && !Fr(n.$lo, w[1], 0)) {
n.$ox(w[1], zn);
var v = n.$k9.cfm.$ar(), y = (f = kr((zn[0] - n.$l9[0]) / n.$hk.right, -1, 1), m = kr((zn[1] - n.$l9[1]) / n.$hk.top, -1, 1), 
n.$hk), $ = 0;
function b(e, t, n) {
n = Ur(1, Yn[1], 1 - Dr(1 - (null == n ? $ : n))), e.scale.set(Me(t.right - t.left, t.top - t.bottom) * Ur(1, Yn[2], Dr(f)) * n, Me(t.right - t.left, t.top - t.bottom) * Ur(1, Yn[2], Dr(m)) * n, 1);
}
function x(e) {
if (1 == e) Wr(v), n.$o9.delete(v), n.$k9.cfm.$ap(v); else {
var t = Ur(Jn[0], Jn[1], Dr(null == e ? $ : e)), r = Ce(m * y.top, f * y.right);
v.position.set(f * y.right * (1 + t * Pe(Se(r))), m * y.top * (1 + t * Pe(Ae(r))), 0), 
b(v, y, e), null != e && (ei(v, Ii(n.$hf.$b4[0], Ur(Zn[0], Zn[1], 1 - Dr(1 - 2 * Dr(1 - e))))), 
$ = e);
}
}
v.position.set(f * y.right, m * y.top, 0), b(v, y), y.add(v), n.$gp.$gr(n.$pm(s[u + 1], 800, x, 1)), 
n.$o9.set(v, x);
}
t.$dh.$dk = s[u + 1];
}
} else if (256 === p) {
s.set(o.subarray(3), u + 3), n.$p1() && !t.$dh.$e6 && t.$fq(s[u + 1], !0);
var w = n.$m1.get(s[u + 2]);
if (t.$d2 === n.$d2) {
n.$kk = s[u + 1], vr("Defeated by: " + w[4]);
var _ = "border" !== w[4] && n.$jq.$cw(w[4]), M = _ && _.$dh;
!M || _.$fi() && !M.$e6 || (n.$mg, M.$es), n.$pg(n.$kk), n.$p8(2, w);
} else n.$jq.$cx(t.$d2, !0), n.$k7 && n.$k7.$i0(s[u + 1], w.slice(2, 4), o[6]);
return !0;
}
s.set(o.subarray(3), u + 3), c[u + 8] = 1 / (c[u + 7] = i[o[5]] / n.$nm[Me(a, o[6])]);
}
if (e > n.$nf && t.$dh.$e2 > t.$d4) {
var S = t.$dh.$e2;
if (t.$d2 === n.$d2 && (S = Me(S, n.$kn[n.$q4(n.$kp) + 1] + n.$jn, n.$jt, n.$mg - Eo)), 
(u -= 9) > 0) {
var A = 0;
if (s[u + 1] < S) A = u - 9; else for (;s[A + 1] < S; ) A += 9;
for (A -= 9; A > 0 && 507 & s[A]; ) A -= 9;
for (var T = u; T > 0 && 4 !== s[T]; T -= 9) ;
(A = Me(A, T)) > 0 && t.$fs(A / 9);
}
}
return !1;
}, si.prototype.$ft = function(t, n, r) {
var i = this, a = i.$de, o = i.$d8, s = i.$da, c = i.$d5;
if (e(i.$fi()), n < i.$d4) return !1;
if (s > 0 && n === o[1] && 24 & t && 1 === o[0]) return !0;
if (0 === s) return o[0] = t, o[1] = n, o[2] = null != r ? r : -1, o[3] = 262913709, 
i.$da += 9, !0;
i.$dh.$e2 = Me(i.$dh.$e2, n), i.$d2 === a.$d2 && i.$dh.$es - n > 50 && 4 === t && de("/ae2/" + n + "_" + t + "_" + (i.$dh.$es - n) + "_" + i.$d7 + "_" + i.$d4 + " " + i.$n0 + "_" + i.$n1);
for (var l = s - 9; l > 0 && o[l + 1] > n; l -= 9) o[l + 3] = 262913709;
if (o[l + 1] > n) {
if (de("/ae/" + i.$d4 + "_" + o[l + 1] + "_(" + n + "_" + t + "_" + (null != r ? a.$m1.get(r) : r) + ")_" + i.$dh.$e2 + "_" + i.$d7 + "_" + (a.$d2 === i.$d2) + "_" + i.$dh.$es + "_" + i.$dh.$ev + "__" + a.$jz.$gt + "_" + a.$jz.$gu, !0), 
2 === t) {
var u = new ArrayBuffer(Ft), h = new DataView(u);
return h.setUint8(0, pa), h.setUint16(It, i.$d2, Qe), a.$pv(u), c.set(o.subarray(l + 3, l + 9), 3), 
!1;
}
return i.$fu(n), !0;
}
if (32 === t) for (;l > 0 && o[l + 1] === n; l -= 9) o[l + 3] = 262913709;
if (262913709 !== o[l + 3] && c.set(o.subarray(l + 3, l + 9), 3), 26 & t && t === o[l] && n === o[l + 1]) {
2 === t ? (a.$qn(o[l + 2]), o[l + 2] = r) : ((o[l + 2] += r) < 0 && (i.$er = _e(i.$er, Pe(o[l + 2]))), 
o[l] = o[l + 2] >= 0 ? bt : $t, o[l + 3] = 262913709);
for (var d = l - 9; d > 0 && 262913709 === o[d + 3]; d -= 9) ;
for (e(262913709 !== o[d + 3]), c.set(o.subarray(d + 3, d + 9), 3); l < i.$da; ) o[l + 3] = 262913709, 
l += 9;
} else l += 9, i.$da === o.length ? (i.$d8 = new Int32Array(a.$ne = _e(a.$ne, 9 * Ne(1.5 * i.$da / 9))), 
i.$d9 = new Float32Array(i.$d8.buffer), i.$d8.set(o.subarray(0, l)), i.$d8.set(o.subarray(l, o.length), l + 9), 
o = i.$d8) : o.copyWithin(l + 9, l, i.$da), o[l] = t, o[l + 1] = n, o[l + 2] = null != r ? r : -1, 
o[l + 3] = 262913709, i.$da += 9;
return !0;
}, si.prototype.$fu = function(e) {
var t = this, n = t.$de;
if (t.$fi() && (vr("start_resetting", t.$d2), 0 == t.$dg)) {
t.$dg = e, t.$fh();
var r = new ArrayBuffer(Ft), i = new DataView(r);
i.setUint8(0, da), i.setUint16(It, t.$d2, Qe), n.$pv(r);
}
};
var Li = Uint32Array.of(0, 0, 0, 3e3), Ci = (Li = Uint32Array.of(400, 300, 1500, 1e3), 
function() {
for (var e = new Float32Array(Li.length), t = 0; t < e.length; ++t) e[t] = 1 / Li[t];
return e;
}()), Ei = Uint8Array.of(0, 0, 0, 0), Pi = Float32Array.of(1.3, 1.45), ki = Float32Array.of(.2, .15), Oi = Uint8Array.of(112, 128), Di = Int8Array.of(-80, -96), Ni = .25;
function Ii(e, t) {
return (e << 8 | ("number" != typeof t || t >= 1 ? 255 : 255 * (t < 0 ? 0 : t))) >>> 0;
}
function Ri(e) {
var t = this;
t.$d2 = t.$d3 = t.$fy = t.$fz = t.$fx = t.$ck = 0, t.$g6 = -0, t.$g5 = -1, t.$g3 = t.$g4 = t.$g0 = t.$g7 = null, 
t.$g1 = new s(), t.$g2 = new s();
}
si.prototype.$fv = function(t) {
var n, r, i = this, a = i.$de, o = a.$k9.pai, s = a.$k9.maxlenf, c = i.$dh, l = c.$j9, u = c.$em, h = c.$en;
t = t || 0;
if (e(c), !si.prototype.$dn) {
var d = a.$m0;
si.prototype.$dn = Float32Array.of(-d[2], d[4] - d[2], 2.25 - d[4], .25);
}
function p() {
for (var e = 0; e < 2; ++e) for (var t = 0 === e ? l : u, a = t.length - 1; a >= 0; --a) t[a].$8q(), 
o.$ap(t[a]);
n && (s.$ap(n), s.$ap(r)), i.$fw();
}
if (t > 0 && !c.$e6 && a.$p1()) {
for (var f = c.$j7, m = 1 / t, g = Wn.$8n(), v = 1.2 * t * _e(600, Math.max(1, Ni) * _e.apply(null, Li)), y = Uint32Array.of(i.$df[1] << 8, i.$df[0] << 8, i.$df[1] << 8, 0), $ = new Uint32Array(y.length), b = 0, x = 0; x < f; ++x) b = _e(b, l[x].$8m >>> 2);
++b, n = s.$ar(), r = s.$ar();
var w = b - 1, _ = 1 / b;
for (x = 1; w >= 0; --w, x -= _) n[w] = 1 / (1 + .2 * x), r[w] = 1 + .4 * xe();
for (x = u.length - 1, g = Wn; x >= 0; --x) u[x].$8p(g, 1024), g.$9x = g.$9w, u[x].$8o(g, 2048);
a.$gp.$gr(a.$pm(c.$es, v, function(e, t) {
if (1 === e) p(); else {
for (var o = t * m, s = null, d = 3, v = Ur(Oi[0], Oi[1], c.$ep); d >= 0; --d, v = 255) {
var b = Me(1, o * Ci[d]);
$[d] = $e(y[d], 4294967040, .5 * b) | v + b * (Ei[d] - v);
}
for (var x = 0, w = a.$k3 * a.$if; x < f; ++x) {
var _ = l[x];
if (null !== _.$8j) {
d = 3 & _.$8m;
var M = _.$8m >>> 2, S = (b = Me(1, o * Ci[d] * n[M]), d >= 2 ? 1 - Nr(1 - b) : b * b), A = c.$ei * a.$i8 * r[M] * i.$dn[d] * S;
1 === b ? (g.$9w = 0, _.$8o(g, 1024)) : (_.$8p(g, 2048), 3 === d ? (g.$9w = _e(0, (null === s ? s = g.$9x : Ur(g.$9x, _e(g.$9x, s), S)) + A), 
g.$a1 = 255 & $[d], _.$8o(g, 1025)) : (g.$9w = _e(0, g.$9x + A), g.$a8 = w / g.$9w, 
g.$9z = $[d], _.$8o(g, 1092)));
}
}
for (g.$9v = zn, x = u.length - 1; x >= 0; --x) if (o >= 600) g.$9w = 0, u[x].$8o(g, 1024); else {
u[x].$8p(g, 2048), g.$9w = o <= 540 ? g.$9x * Ur(3, 1, Nr(1 - o / 540)) : g.$9x * Ur(2.5, 3, Nr(1 - (o - 540) / 60));
var T = 1 + _e(0, g.$9w - g.$9x) / we(Dr(h[2 * x + 2]) + Dr(h[2 * x + 3])), L = 1 - Nr(1 - o / 600);
g.$9v[0] = h[0] + T * h[2 * x + 2], g.$9v[1] = h[1] + T * h[2 * x + 3], g.$9z = $e(y[0], 4294967040, .5 * L) | 255 + -159 * L, 
g.$a8 = .8 * w / g.$9w, u[x].$8o(g, 1348);
}
}
}, 1));
} else p();
for (w = 0; w < i.$dr.length; ++w) i.$dr[w].$d1 && (i.$dr[w].$d1[0].visible = i.$dr[w].$d1[1] = !1);
i.$dr.length = 0;
}, si.prototype.$fw = function() {
var e = this, t = e.$de.$k9;
t.hstr.$ap(e.$d8), e.$d8 = e.$d9 = e.$d5 = null, e.$da = 0, t.di.$ap(e.$dh), e.$dh = null;
}, Ri.prototype.$g8 = new O(), Ri.prototype.$g9 = new Array(), Ri.prototype.$ga = function() {
return this.$d3 < 3;
}, Ri.prototype.$gb = function() {
return this.$fx * (this.$ck || this.$d3 % 3 != 0 ? fn[1] : 1);
}, Ri.prototype.$gc = function(t, n, r, i, a, o) {
var s = this, l = Zc(), u = o || 0 !== n, h = l.$hf.$bn, d = xe(), p = Ur(fn[0], fn[2], d);
e(0 == s.$d2), s.$d2 = t, s.$d3 = n + 3, s.$fy = r[0], s.$fz = r[1], s.$g6 = a, 
s.$ck = o, s.$fx = i;
var f = l.$ov(s.$gb());
if (i += i * (p - 1) & -16, !(s.$g0 = s.$g9[i])) {
for (var m = ii(), g = 0; g < 2; ++g) {
var v = new Float32Array(2 * h.length), y = 0;
for (v = ii(); y < h.length; ++y) v[y << 1] = l.$ov(i * fn[g]) * h[y].$9w, v[1 + (y << 1)] = l.$ov(i * fn[g]) * h[y].$9x;
m.push(v);
}
s.$g9[i] = s.$g0 = m;
}
var $ = s.$g0 = s.$g0[u ? 1 : 0];
Gn.set(r), l.$ox(Gn, zn), zn[2] = 0;
var b, x = s.$g8, w = 1 - 2 * (xe() > .5), _ = o && l.$kt.get(o);
x.$9v = zn, x.$a9 = Ur(2.5, 3, d) * cn, x.$a5 = _e(0, a) * on, x.$a3 = (u ? 1.25 : 1) * Ur(4, 8, d), 
x.$aa = x.$9w = x.$9x = x.$a8 = 0, u ? b = (_ ? _[1] : l.$hf.$b9[xe() * l.$hf.$b9.length * .999 | 0])[2] : (l.$jr.$gh.$c8(s.$g5 = l.$jr.$gh.$c5(), 1), 
b = l.$hf.$b6[s.$g5]);
var M = l.$je[l.$p9(r[0], r[1])];
M || (de("/ii_" + l.$p9(r[0], r[1]) + "_" + nn + "_" + l.$id + "_" + r[0] + "_" + r[1]), 
M = l.$je[l.$je.length >> 1]);
for (g = 0; g < h.length; ++g) {
var S = h[g];
x.$9z = b[g] << 8 | S.$a1, x.$a0 = b[g] << 8 | S.$a2;
var A = l.$k3 * l.$if / $[1 + (g << 1)];
A > x.$a8 && (x.$a8 = A), x.$aa = (u ? .5 : 1) * f * Br(S.$aa[0], S.$aa[1]) * w, 
M.$8e(x, g ? s.$g2 : s.$g1, g ? s.$g1 : c);
}
};
var ji = function() {
for (var e = (mn - .8 * .8 * .8) / 2.8479999999999994, t = 20 * e, n = 1 - t - e, r = new Float64Array(100), i = 0, a = 0; i < r.length; ++i, 
a += 1 / (r.length - 1)) r[i] = ((n * a + t) * a + e) * a;
return r;
}();
function Ui(e) {
var t = this;
t.$de = e, t.$gg = new Map(), t.$ge = new Uint32Array(256), t.$gf = 0, t.$gh = null;
}
Ri.prototype.$gd = function() {
var e = this, t = Zc(), n = t.$hf.$bn, r = e.$g0, i = Wn;
if (e.$d3 = e.$d3 % 3, Gn[0] = e.$fy, Gn[1] = e.$fz, e.$ck && 2 !== e.$d3 || e.$g6 <= 0 || !(t.$p1() && Fr(t.$lo, Gn, 2 * e.$fx * n[0].$9x) && t.$js > 1)) i.$9w = r[0], 
i.$9x = r[1], e.$g1.$8o(i, 3072), i.$9w = r[2], i.$9x = r[3], e.$g2.$8o(i, 3072), 
e.$g4 = null; else {
t.$gp.$gr(e.$g4 = t.$pm(_e(e.$g6, Tr()), Br(xn[0], xn[1]), function(t) {
if (1 === t) i.$9w = r[0], i.$9x = r[1], e.$g1.$8o(i, 3072), i.$9w = r[2], i.$9x = r[3], 
e.$g2.$8o(i, 3072), e.$g4 = null; else {
var n = ji[t * ji.length | 0];
i.$9w = i.$9x = r[0] * n, e.$g1.$8o(i, 3072), i.$9w = i.$9x = r[2] * n, e.$g2.$8o(i, 3072);
}
}, 1));
}
}, Ri.prototype.$fv = function() {
var e = this, t = Zc();
e.$g1.$8q(), e.$g2.$8q(), e.$d2 = e.$d3 = 0, e.$g3 && (e.$g3.fn = null), e.$g5 >= 0 && (t.$jr.$gh.$c8(e.$g5, -1), 
e.$g5 = -1), e.$g7 && (e.$g7.$8n(), t.$k9.pp.$ap(e.$g7)), e.$g0 = e.$g3 = e.$g7 = null, 
t.$k9.item.$ap(e);
}, Ui.prototype.$gi = function(e) {
var t = this;
if (t.$gg.set(e.$d2, e), e.$g6 < 0) e.$gd(); else {
for (var n = 0, r = t.$gf, i = t.$ge; n < r && 0 !== i[n]; ++n) ;
n === r && (n === i.length && (t.$ge = new Uint32Array(2 * n), t.$ge.set(i), i = t.$ge), 
t.$gf = n + 1), i[n] = e.$d2;
}
}, Ui.prototype.$ct = function(e) {
for (var t = this, n = t.$de, r = t.$gg, i = t.$ge, a = 0, o = t.$gf, s = -1; a < o; ++a) if (0 !== i[a]) {
var c = r.get(i[a]);
c ? e >= c.$g6 ? (i[a] = 0, c.$gd()) : s = a : (de("/iu_" + a + "_" + i[a] + "_" + n.$jk + "_" + r.size + "_" + !!Map + " " + i.length + "_" + t.$gf + " " + ue), 
i[a] = 0);
}
t.$gf = s + 1;
};
function Bi() {
var e = this;
e.$d2 = e.$gk = 0, e.fn = null, e.$d4 = e.$gj = e.$gm = e.$gl = -0, arguments.length && e.$go.apply(e, arguments);
}
function zi() {
var e = this;
return e.$gp = ii(), e.$gq = ii(), e;
}
function Fi() {
return 0;
}
function Gi(e, t) {
return e.getUint8(t);
}
function Vi(e, t) {
return e.getUint16(t, Qe);
}
function Wi(e, t) {
return Qe ? e.getUint8(t) | e.getUint16(t + 1, !0) << 8 : e.getUint8(t) << 16 | e.getUint16(t + 1);
}
function qi(e, t) {
return e.getUint32(t, Qe);
}
Ui.prototype.$bt = function(t, n, r, i) {
var a = this, o = a.$de, s = o.$hf.$bn, u = a.$gg, h = a.$ge, d = u.get(t), p = n ? n.$d2 : 0;
if (d) {
if (u.delete(t), !d.$ga()) for (var f = 0, m = a.$gf; f < m; ++f) if (h[f] === t) {
h[f] = 0;
break;
}
d.$g4 && (d.$g4.$ct(d.$g4.$d4 + d.$g4.$gj + 1), e(!d.$g4));
var g = r === Number.MIN_VALUE ? Tr() : n ? n.$d6 + r : d.$g6 + r;
if (n && i >= o.$n0 + g + 375 && (n = null), Gn[0] = d.$fy, Gn[1] = d.$fz, d.$ga() && (!n || n.$fi() && o.$p1() && Fr(o.$lo, Gn, 2 * d.$fx * s[0].$9x))) {
(d.$g1.$8k & d.$g1.$8j.$9a) != d.$g1.$8j.$98[d.$g1.$8k >> d.$g1.$8j.$99] && de("/ri1_" + (d.$g1.$8k & d.$g1.$8j.$9a) + "_" + d.$g1.$8j.$98[d.$g1.$8k >> d.$g1.$8j.$99] + "_" + o.$jk);
d.$g0;
var v = d.$g1.$8p(Wn, 12197), y = (v.$9z, 3 * s[0].$a8), $ = Pe(v.$aa), b = (g - v.$a5 * sn) / (v.$a9 * sn) % 1, x = b * v.$a3 % 1, w = je(v.$aa) * Be * b, _ = new Float32Array(7), M = new Float32Array(3);
_[0] = M[0] = v.$9v[0] + $ * Se(w), _[1] = M[1] = v.$9v[1] + $ * Ae(w), _[2] = M[2] = v.$9v[2], 
d.$g7 || (d.$g7 = o.$k9.pp.$ar(), d.$g7.$9v = _, d.$g7.$a3 = 1), d.$g7.$a0 = (d.$g7.$9z = v.$9z) >> 8 << 8 & 4294967104;
o.$gp.$gr(o.$pm(g, 1, function() {
var e = o.$jq.$cv(p), t = e && e.$fi(), n = t ? 0 != e.$dh.$e4 ? 180 : 250 : 1e3, r = Wn;
r.$a5 = on * g, r.$a9 = 2 * n * on, r.$a3 = 1, r.$aa = 0, r.$9v = M, r.$a2 = 127;
for (var i = 0, a = .5 - .5 * Se(x * Be), s = 0 * (null != e), u = d.$g0; i < 2; ++i) r.$9x = s * (r.$9w = Ur(u[i << 1], u[1 + (i << 1)], a)), 
(i ? d.$g2 : d.$g1).$8o(r, 12194);
t ? o.$gp.$gr(d.$g3 = o.$pm(this.$d4, n, function(e) {
var t = d.$g7, n = 0;
return _[2] = _[3] = _[4] = 0, function(r, i) {
if (1 !== r && e.$da) {
var a = e.$d5[5] << 2, s = o.$ov(d.$gb()), u = o.$ic * _e(0, e.$dh.$ei * o.$i8 - s) * (1 - r), h = o.$lp, p = o.$lq;
_[3] = e.$dh.$e8[0] * o.$i8 + h[a + 0] * u - _[0], _[4] = e.$dh.$e8[1] * o.$i8 + h[a + 1] * u - _[1];
var f = we(_[3] * _[3] + _[4] * _[4]), m = we(p[0 + (a >> 1)]), g = 0 === n ? 0 : we(Dr(e.$dh.$e8[0] - _[5]) + Dr(e.$dh.$e8[1] - _[6])) * o.$i8, v = (_[3] * h[a + 0] + _[4] * h[a + 1]) / (f * m), $ = g / (a >> 2 & ar ? Ur(1, o.$ip, .67 * we(1 - r)) : 1) / f * Ur(2.5, 1, Dr(1 - .5 * (v + 1)));
if ($ >= 1) d.$fv(), this.fn = null; else if (o.$lo && (_[0] += $ * _[3], _[1] += $ * _[4], 
_[5] = e.$dh.$e8[0], _[6] = e.$dh.$e8[1], n = r, Gn[0] = _[0] * o.$j4, Gn[1] = _[1] * o.$j4, 
Fr(o.$lo, Gn, d.$fx))) {
d.$g1.$8o(t, 256), d.$g2.$8o(t, 256);
var b = 1.25 - .5 * we(r);
t.$9x = (t.$9w = 1.25 * s * b) * (.5 - .5 * b), t.$a5 = (this.$d4 + i) * on, t.$a9 = 2 * (t.$a4 = 1 * this.$gj * on), 
t.$a8 = y / b, o.$jf.$8e(t, l, c);
}
} else d.$fv();
};
}(e), 1)) : o.$gp.$gr(d.$g3 = o.$pm(this.$d4 + n, 1, function(e) {
1 === e && d.$fv();
}, 1)), this.fn = null;
}, 1));
} else (d.$g1.$8k & d.$g1.$8j.$9a) != d.$g1.$8j.$98[d.$g1.$8k >> d.$g1.$8j.$99] && de("/ri2_" + (d.$g1.$8k & d.$g1.$8j.$9a) + "_" + d.$g1.$8j.$98[d.$g1.$8k >> d.$g1.$8j.$99] + "_" + o.$jk + "_" + d.$ga() + " " + !!n), 
d.$fv();
} else {
for (f = 0, m = a.$gf; f < m; ++f) if (h[f] === t) {
de("/ri_" + f + "_" + h[f] + "_" + o.$jk + "_" + u.size + " " + h.length + "_" + a.$gf + "_" + !!n + "_" + r + "_" + (0 | Tr()) + (o.$jq.$cr ? "_1_" + o.$jq.$cr.$di + "_" + o.$jq.$cr.$dh.$es : "_0")), 
h[f] = 0;
break;
}
o.$jq.$cr && o.$jq.$cr.$di !== o.$jq.$cr.$dh.$es && de("/ri2_" + t + "_" + !!n + "_" + r + "_" + Tr() + (o.$jq.$cr ? "_1_" + o.$jq.$cr.$di + "_" + o.$jq.$cr.$dh.$es : "_0"));
}
}, Ui.prototype.clear = function() {
for (var e = this, t = e.$gg.values(), n = t.next(); !n.done; n = t.next()) {
(n = n.value).$fv(!0);
}
e.$gg = new Map(), e.$ge = new Uint32Array(256), e.$gf = 0, e.$gh = new pr(e.$de.$hf.$b6.length, 1);
}, Bi.prototype.$gn = 0, Bi.prototype.$go = function(t, n, r, i) {
var a = this;
return e(0 == a.$d2), a.$d2 = ++a.$gn, a.fn = r, a.$d4 = t, a.$gj = n, a.$gm = 1 / n, 
a.$gk = i || 0, a.$gl = -0, e(null != a.$d4), a;
}, Bi.prototype.$ct = function(e) {
var t = this;
if (!t.fn) return !0;
var n = e - t.$d4;
if (n < 0) return !1;
var r = n * t.$gm;
if (t.$gk >= 1) {
var i = Math.floor(r), a = i >= t.$gk;
t.fn.call(t, a ? 1 : r - i, n), a && (t.fn = null);
} else t.fn.call(t, r % 1, n);
return t.$gl = n, !t.fn;
}, zi.prototype.$gr = function(e) {
this.$gq.push(e);
}, zi.prototype.$gs = function(e) {
var t = this.$gp.indexOf(e);
return e.$d2 = 0, t >= 0 ? (this.$gp[t] = void 0, !0) : (t = this.$gq.indexOf(e)) >= 0 && (this.$gq[t] = void 0, 
!0);
}, zi.prototype.$ct = function(e, t) {
for (var n = this, r = n.$gp, i = r.length, a = n.$gq, o = a.length, s = 0, c = 0; s < i; ) {
if (!r[s] || r[s].$ct(e)) for (o = a.length, r[s] && t && t(r[s]), r[s] = void 0; c < o && !(r[s] = a[c++]); ) ; else o = a.length;
++s;
}
for (;c < a.length; ) a[c] && !a[c].$ct(e) && r.push(a[c]), ++c;
o && (n.$gq.length = 0);
};
var Hi = new DataView(new ArrayBuffer(4));
function Xi(e, t, n) {
return e.setUint32(t, n, Qe);
}
function Yi(e, t, n) {
e.setUint8(t, n);
}
function Ji(e, t) {
return e.getInt32(t, Qe);
}
function Zi(e, t) {
return Qe ? e.getUint8(t) + (e.getUint16(t + 1, !0) << 8) : (e.getUint8(t) << 16) + e.getUint16(t + 1);
}
function Ki(e, t) {
return e.getUint32(t, Qe);
}
function Qi(e, t) {
return e.getUint16(t, Qe);
}
function ea(e, t, n) {
if ("number" == typeof n) {
for (var r = new Int32Array(n), i = t + (n << 2), a = 0; t < i; t += 4, ++a) r[a] = e.getInt32(t, Qe);
return r;
}
return e.getInt32(t, Qe);
}
function ta(e, t, n) {
if ("number" == typeof n) {
for (var r = new Int16Array(n), i = t + (n << 1), a = 0; t < i; t += 2, ++a) r[a] = e.getInt16(t, Qe);
return r;
}
return e.getInt16(t, Qe);
}
function na(e, t) {
return 1 === e ? t ? function(e, t) {
return e.getInt8(t);
} : function(e, t) {
return e.getUint8(t);
} : 2 === e ? t ? function(e, t) {
return e.getInt16(t, Qe);
} : function(e, t) {
return e.getUint16(t, Qe);
} : 3 === e ? t ? Qe ? function(e, t) {
return (e.getInt8(t + 2) << 16) + e.getUint16(t, !0);
} : function(e, t) {
return (e.getInt8(t) << 16) + e.getUint16(t + 1);
} : Wi : 4 === e ? t ? function(e, t) {
return e.getInt32(t, Qe);
} : function(e, t) {
return e.getUint32(t, Qe);
} : e;
}
var ra = [ Yi, Yi, function(e, t, n) {
e.setUint16(t, n, Qe);
}, function(e, t, n) {
Qe ? (e.setUint8(t, n), e.setUint16(t + 1, n >>> 8, !0)) : (e.setUint16(t, n >>> 8), 
e.setUint8(t + 2, n));
}, function(e, t, n) {
e.setUint32(t, n, Qe);
} ], ia = [ Fi, Gi, Vi, Wi, qi, ne, ne, ne, Pr ], aa = [ Fi, Gi, Vi, Wi, qi ], oa = [ Fi, function(e, t) {
return e.getInt8(t);
}, function(e, t) {
return e.getInt16(t, Qe);
}, function(e, t) {
var n = e.getUint8(t + 2);
return Qe ? (Hi.setUint16(0, e.getUint16(t, !0), !0), Hi.setUint8(2, n), Hi.setUint8(3, 255 * (n >= 128)), 
Hi.getInt32(0, !0)) : 0;
}, function(e, t) {
return e.getInt32(t, Qe);
}, ne, ne, ne, Pr ], sa = function() {
for (var e = 0, t = new Array(); e <= 4; ++e) t.push(na(e, !0));
return t;
}(), ca = (function() {
for (var e = 0, t = new Array(); e <= 4; ++e) t.push(na(e));
}(), 1), la = 3, ua = 5, ha = 6, da = 18, pa = 19, fa = 22, ma = 92, ga = 110, va = 123, ya = 124, $a = 125, ba = [ 24, 24, 25, 26, 27 ], xa = null;
function wa() {
this.$gx();
}
var _a = new Float64Array(2);
function Ma() {
var e = this;
e.$h0 = new Int32Array(2), e.$d2 = 0, e.$gz = -0, e.$gx(0);
}
function Sa(e, t, n) {
this.$h9 = e, this.$ha = 0, this.$hb = t, this.$hc = n;
}
wa.prototype.$gv = function(t) {
var n = t - this.$gt, r = n <= 255 ? 1 : n <= 65535 ? 2 : n <= 16777215 ? 3 : 4, i = r !== this.$gu;
return e(n >= 0), _a[0] = this.$gu = r, _a[1] = i, _a;
}, wa.prototype.$gw = function(e, t, n) {
return ra[this.$gu](e, t, n - this.$gt), this.$gt = n, this.$gu;
}, wa.prototype.$gx = function() {
this.$gt = 0, this.$gu = 3;
}, Ma.prototype.$h4 = function(e, t) {
return this.$gt += aa[this.$gu](e, t), this.$gt;
}, Ma.prototype.$h5 = function(e, t) {
return this.$gt = (this.$gu < 8) * this.$gt + oa[this.$gu](e, t), this.$gt;
}, Ma.prototype.$h6 = function(e, t, n) {
this.$gy = this.$gy * (n < 4) + ia[n](e, t) >>> 0;
}, Ma.prototype.$h7 = function(e) {
this.$gu = e;
}, Ma.prototype.$h8 = function(e, t, n, r, i) {
var a = this, o = a.$gz + sa[n](e, t);
return a.$h0[0] = o % (i << 1) - i << r, a.$h0[1] = De(o / (i << 1)) - i << r, a.$gz = o, 
a.$h0;
}, Ma.prototype.$gx = function(e) {
var t = this;
t.$h7(e), t.$gt = t.$gy = t.$h1 = 0, t.$gz = 0, t.$h2 = 0, t.$h3 = !1;
}, Sa.prototype.$hd = function(e, t, n) {
var r = this;
r.$ha = 0;
try {
r.$hc.call(r, e, t, n);
} catch (t) {
de(("/ih_" + e.getUint8(0) + "/" + t).slice(0, le));
}
return r.$h9 + r.$ha;
};
var Aa, Ta, La, Ca = 0;
var Ea = 1, Pa = $r(function(e) {
var t = e.split("@");
return t.length > 1 && t[t.length - 1].match(/[^\s]+/) ? [ e.substr(0, e.length - t[t.length - 1].length - 1), !0, e.substr(e.length - t[t.length - 1].length) ] : [ e.substr(0, e.length - (t.length > 1)), t.length > 1, "" ];
}), ka = new RegExp('["\\\\]', "g");
function Oa(e) {
return e = e || $("#nick-input")[0].value.replace(ka, "\\$&"), Ea ? Pa(e) : [ e, !1, "" ];
}
var Da = 500, Na = new Float64Array(128);
function Ia(e) {
var t = performance.timingOrigin || performance.timing && performance.timing.navigationStart;
if (!Mr || !t) return 0;
var n = 0, r = Na;
for (e = e || r.length; n < e; r[n] = Mr() + t - Date.now(), ++n) ;
return (e === r.length ? r : r.subarray(e)).sort(), r[e >>> 1];
}
function Ra(e, t) {
return e[0] - t[0];
}
function ja(e) {
return function(t, n, r) {
r.$h7(e);
};
}
function Ua(e) {
return function(t, n, r) {
r.$h7(e), r.$h5(t, It);
};
}
function Ba(e) {
return function(t, n, r) {
r.$h6(t, It, e);
};
}
function za(t) {
var n = t;
return function(r, i, a) {
this.$ha = n;
var o = Zc(), s = a.$h8(r, this.$h9, t, o.$i9, o.$i6 << o.$i7 - o.$i9);
if (o.$jr.$gg.has(a.$gy)) {
var c = o.$jr.$gg.get(a.$gy);
return de("/ai2_" + o.$jk + "_" + a.$gy + "_[" + s + "]/[" + c.$fy + "," + c.$fz + "] " + a.$h2 + "_" + a.$h3 + "_" + a.$h1 + " " + c.$d3 + "_" + c.$ck + " /" + c.$g6 + " " + (a.$gt + o.$is) + "/_" + ue), 
ce = Me(1, ce), void (a.$gy = a.$gy + 1 >>> 0);
}
c = o.$k9.item.$ar();
var l = o.$kt.size;
c.$gc(a.$gy, a.$h1, s, a.$h2, a.$gt + o.$is, a.$h3 && l), o.$jr.$gi(c), a.$gy = a.$gy + 1 >>> 0, 
a.$h3 && o.$kt.get(l) && ++o.$kt.get(l)[0], e(0 !== a.$gy && c.$fx);
};
}
function Fa(e, t) {
var n = e + t, r = 3 === t ? Zi : Ki, i = 3 === e ? Wi : qi;
return function(t, a, o) {
this.$ha = n;
var s = Zc(), c = s.$jq.$cv(o.$d2);
s.$jr.$bt(r(t, It + e), c, c ? i(t, It) : Number.MIN_VALUE, a);
};
}
function Ga(e) {
var t = 3 === e ? Zi : Ki;
return function(n, r) {
this.$ha = e, Zc().$jr.$bt(t(n, It), null, Number.MIN_VALUE, r);
};
}
function Va(e) {
return new Sa(It + jt, !0, function(t, n, r) {
this.$ha = r.$gu;
var i = Zc(), a = i.$jq.$cv(r.$d2), o = r.$h4(t, It);
if (a && a.$fi() && (a.$d2 !== i.$d2 || 0 !== a.$dg)) {
var s = t.getUint8(It + r.$gu) + (e << 8);
a.$ft(4, o + a.$d6, s);
}
});
}
function Wa(t, n) {
return new Sa(It + jt, !0, function(r, i, a) {
var o = Zc(), s = o.$jq.$cv(a.$d2);
if (s && s.$fi() && (s.$d2 !== o.$d2 || 0 !== s.$dg)) {
for (var c = r.getUint8(It) + (t << 8), l = s.$d8, u = s.$da - 9; u >= 0 && 4 !== l[u]; u -= 9) ;
u < 0 && (de("/pcds_" + l[1] + "_" + l[s.$da - 8] + "_" + s.$d7 + " " + s.$d4 + "_" + (s.$d2 === o.$d2)), 
e(0)), s.$ft(4, l[u + 1] + (n ? o.$jb : o.$ja), c);
}
});
}
function qa(t) {
return new Sa(It, !0, function(n, r, i) {
this.$ha = i.$gu, e(i.$gu > 0);
var a = Zc().$jq.$cv(i.$d2), o = i.$h4(n, It);
a && a.$fi() && t && (a.$d2 !== Jc.$d2 || 0 !== a.$dg) && a.$ft(t, o + a.$d6);
});
}
function Ha(e) {
return new Sa(Ft + Pt, !0, function(t) {
var n = Zc().$jq.$cv(Qi(t, It));
if (n && n.$fi()) {
var r = qi(t, Ft);
n.$ft(e, r + n.$d6);
}
});
}
function Xa(e) {
return new Sa(It + Pt, !0, function(t, n, r) {
var i = Zc().$jq.$cv(r.$d2);
i && i.$fi() && i.$ft(e >= 0 ? bt : $t, qi(t, It) + i.$d6, e);
});
}
function Ya(e) {
return new Sa(It, !0, function(t, n, r) {
this.$ha = r.$gu;
var i = Zc().$jq.$cv(r.$d2), a = r.$h4(t, It);
i && i.$fi() && i.$ft(e >= 0 ? bt : $t, a + i.$d6, e);
});
}
_o.prototype.$he = function(e, t, n, r, i) {
var a = this, o = ++a.$oe;
if (a.$ko = o, (a.$kp < 0 || a.$jk !== qt) && (a.$kp = o), a.$q5(o, e + a.$jo, n), 
a.$q6(a.$kp), -1 != (0 | r) && 0 !== r) {
var s = a.$nx[a.$ny % a.$nx.length];
s[0] = i - a.$n0 - t, s[1] = t - (r + .5 * a.$ju[0]), ++a.$ny;
}
a.$ny % a.$nx.length == 0 && (a.$nx.sort(Ra), a.$nx[a.$nx.length >>> 1][1]);
};
var Ja = [ new Sa(It, !1, function(t) {
e(0);
}), new Number(ca), new Sa(It, !1, function() {
var e = Zc();
sr ? e.$q3() : (e.$cl.onclose = no, e.$cl.close()), Tc(bc, gc);
}), new Sa(It + Ct + Tt + Pt + 2 * Et, !0, function(e, t) {
var n = Zc(), r = e.getUint16(this.$h9 - Et);
if (this.$ha = r, n.$qu()) {
var i = e.getUint8(It), a = Vi(e, It + Ct), o = qi(e, It + Ct + Tt), s = e.getUint16(this.$h9 - 2 * Et, Qe), c = n.$n2;
if (n.$og = n.$og || 1, i === c.length && c.push(new Float64Array(2)), 0 === i) for (var l = 0; l < c.length; c[l][0] = c[l][1] = 0, 
++l) ;
c[i][0] = t - o, i && (c[i - 1][1] = a);
var u = It + 2 * Pt + Et + s;
if (!Aa || Aa.byteLength !== u) {
Ta = new DataView(Aa = new ArrayBuffer(u)), La = new Uint8Array(Aa), Ta.setUint8(0, la), 
Ta.setUint16(u - (Et + s), s), l = u - s;
for (var h = new Uint8Array(e.buffer, this.$h9, this.$ha); l < u; l += r) {
var d = Me(u - l, r);
new Uint8Array(Aa, l, d).set(d == r ? h : h.slice(0, d));
}
}
var p = Ne(i ? t - (n.$n0 || c[i - 1][0] - (a >>> 1)) : 0);
Xi(Ta, It, p), Xi(Ta, It + Pt, p), n.$pv(Aa);
}
}), new Sa(It + Ct + 3 * Tt, !0, function(e, t) {
var n = Zc();
if (n.$jk !== Vt && n.$jk !== Ht) {
n.$og = n.$oh = 0, n.$ju[0] = Vi(e, It + Ct + Tt), n.$ju[1] = Vi(e, It + Ct + 2 * Tt);
var r = e.getUint8(It), i = Vi(e, It + Ct), a = Ia(), o = a - n.$n3, s = n.$n2, c = n.$jv;
n.$jv ? n.$ju[0] < n.$jv[0] && (c = n.$jv.slice(), n.$jv.set(n.$ju)) : c = n.$jv = n.$ju.slice(), 
n.$n3 = n.$n4 = a, s.length > r && s.splice(r, s.length - r), s[r - 1][1] = i, s.sort(function(e, t) {
return e[1] === t[1] ? e[0] - t[0] : e[1] - t[1];
});
for (var l = s[0][0] - .5 * s[0][1], u = kr(n.$jv[0], 1, s[0][1]), h = s.length, d = h - 1; d > 0; --d) s[d][1] < s[0][1] + 10 && (l = Ur(l, s[d][0] - .5 * s[d][1], u / (u + s[d][1])), 
u = kr(u, 1, s[d][1]));
var p = n.$n5 && !n.$mk && n.$n0 && Pe(l - n.$n0) > 50 ? "/pfha4" + (n.$jq.$cr ? " " + n.$jq.$cr.$d7 : "") + " [" + Array.from(n.$ju) + "]_[" + Array.from(c) + "] " + n.$n1 + "_" + n.$n5 + "_" + n.$n0 + " " + (l - n.$n0) + "_" + a + "," + o + "  " + s + " " + s[h >>> 1][1] / n.$jv[0] + " " + (Pe(o) > 10 && -o / (l - n.$n5) > .9) : null;
if (n.$n0) if (s[h >>> 1][1] < 2 * n.$jv[0] || s[h - 2][1] - s[0][1] < 5) {
var f = Ur(n.$n5, l, Me(1, Dr(n.$jv[0] / s[0][1])));
s[h - 2][1] - n.$jv[0] < _e(.2 * n.$jv[0], 10) ? (n.$n0 += f - n.$n5, p && (p += " @1")) : p && (p += " @2"), 
n.$n5 = f;
} else n.$oh = 1;
if (te.$ak(n.$js, n.$ju, n.$jv, n.$n3, n.$n5, n.$n0), !n.$n0) {
for (n.$n1 = n.$n0 = n.$n5 = l, n.$ny = -0, d = 0; d < n.$nx.length; n.$nx[d][0] = n.$nx[d][1] = 0, 
++d) ;
n.$pz();
var m = function(e) {
try {
return Uint8Array.from(JSON.parse(e));
} catch (e) {
return;
}
}(Q.$bs("uuid"));
if (!m) {
for (m = new Uint8Array(16), d = 0; d < m.length; m[d++] = 256 * Math.random() - 1e-6) ;
Q.$br("uuid", JSON.stringify(Array.from(m)));
}
var g = Oa(), v = g[0], y = g[2] && ToUTF8(FromString(fr(g[2]))) || n.$oc && ToUTF8(FromString(fr(n.$oc))), $ = ToUTF8(FromString('{"nick":"' + v + '","ads":' + (window.ADS_BLOCKED ? 0 : 1) + ',"n_games":' + GLOB[gn[4]]() + (Qn && Qn !== Kn ? ',"country":"' + Qn + '"' : "") + ',"color":' + n.$k0.player_hue + "}")), b = ToUTF8(FromString((b = encodeURI(document.location.href)).substring(0, Me(b.length, 255)))), x = new ArrayBuffer(It + 7 + Ot + St + Mt + At + 1 + $.length + b.length + (y ? y.length : 0) + 1 + m.length), w = 0;
(e = new DataView(x)).setUint8(w, ua), e.setUint8(w += It, On ? 1 : 0), e.setUint16(w += 1, _e(window.screen.width, window.screen.height), Qe), 
e.setUint16(w += 2, Me(window.screen.width, window.screen.height), Qe), e.setUint16(w += 2, 1e3 * window.devicePixelRatio | 0, Qe), 
function(e, t, n) {
Qe ? (e.setUint32(t, n & Xe, !0), e.setUint32(t + 4, n / qe | 0, !0)) : (e.setUint32(t, n / qe | 0), 
e.setUint32(t + 4, n & Xe));
}(e, w += 2, n.$n0), e.setUint8(w += Ot, $.length), e.setUint8(w += St, b.length), 
e.setUint8(w += At, y ? y.length : 0), e.setUint8(w += Mt, m.length), e.setUint8(++w, (!g[2] && n.$oc ? 1 : 0) | n.$k0.switch_rooms << 1), 
new Uint8Array(x, ++w, $.length).set($), new Uint8Array(x, w += $.length, b.length).set(b), 
y && new Uint8Array(x, w += b.length, y.length).set(y), new Uint8Array(x, w += y ? y.length : b.length, m.length).set(m), 
n.$pv(x), n.$nz.push(n.$q2());
}
}
}), new Number(ua), new Number(ha), new Number(7), new Sa(It + Tt, !0, function(e) {}), new Sa(Ft, !0, function(e) {
var t = Qi(e, It), n = Zc(), r = n.$jq.$cv(t);
if (r) if (r.$fi()) {
for (var i = 0, a = r.$da; i < a && 256 !== r.$d8[i]; i += 9) ;
i === a && n.$jq.$cx(t);
} else n.$jq.$cx(t);
}), new Sa(Ft + Nt + 6 + 11 * Dt + 6 * Bt + 2 * Rt + Ot + Pt + 9 * Lt + Nt + zt + 2 * (1 + (or >> 3)) * Rt + kt + 2, !0, function(t) {
this.$ha = t.getUint8(this.$h9 - 2) + t.getUint8(this.$h9 - 1);
var n = t.getUint8(this.$h9 - 2) >>> 1, r = t.getUint8(this.$h9 - 1), i = Ft + Nt, a = Zc(), s = GLOB[gn[16]]();
a.$op = Qi(t, It), a.$d2 = Qi(t, Ft), a.$j4 = 1 << (a.$i7 = t.getUint8(i)), a.$ia = 1 << (a.$i9 = t.getUint8(++i)), 
a.$i8 = 1 / a.$j4, a.$ic = 1 / (a.$ib = (1 << t.getUint8(++i)) - 1), a.$o0 = t.getUint8(++i), 
xa = function(e, t) {
for (var n = new Uint8Array((2 + e) * t), r = 0, i = 0; r < t; ++r, i += e) {
n[i++] = ga, n[i++] = e;
for (var a = 0; a < e; n[i + a++] = 255 * Math.random()) ;
}
return n.buffer;
}(t.getUint8(++i), t.getUint8(++i));
var c = ea(t, ++i, 11);
if (a.$id = a.$j4 * (a.$i6 = c[0]), a.$j5 = 1 / a.$id, a.$ie = c[1], a.$if = c[1] * a.$i8, 
a.$ig = c[2], a.$ih = c[3] * (1 / 65536), a.$lf = c[4], a.$h2 = c[5], a.$iu = a.$h2 * a.$i8, 
a.$j1 = Float32Array.of(c[6] * (1 / 65536), c[7] * (1 / 65536)), On && Me(window.screen.width, window.screen.height) < 768) for (var l = 0; l < 2; ++l) a.$j1[l] *= .8;
a.$lt = c[8] * (1 / 65536), a.$lu = c[9] * (1 / 65536), a.$lv = c[10] * (1 / 65536), 
a.$ii = Int16Array.of(Ji(t, i += c.length * Dt), Ji(t, i += Bt)), a.$ij = Ji(t, i += Bt), 
a.$ik = Ji(t, i += Bt), a.$il = Ji(t, i += Bt), a.$l6 = Ji(t, i += Bt);
var u = ta(t, i += Bt), h = ta(t, i += Rt);
a.$is = Er(t, i += Rt, Qe), a.$my = qi(t, i += Ot), a.$iy = Vi(t, i += Pt), a.$iz = Vi(t, i += Lt), 
a.$ja = Vi(t, i += Lt), a.$jb = Vi(t, i += Lt), a.$ls = Vi(t, i += Lt), a.$jd = Vi(t, i += Lt), 
a.$m3 = Vi(t, i += Lt), a.$jo = Vi(t, i += Lt), a.$is += a.$jo, a.$o2 = Vi(t, i += Lt), 
a.$ng = Qi(t, i += Lt), a.$nh = Ki(t, i += Nt), a.$ka = Re * a.$ja / a.$ls, a.$li = Ne(Re / a.$ka), 
a.$la = a.$hl.getContext().getParameter(a.$hl.getContext().ALIASED_POINT_SIZE_RANGE)[1], 
a.$lb = Me(a.$j1[0], a.$j1[1]) * a.$hl.getContext().getParameter(a.$hl.getContext().ALIASED_POINT_SIZE_RANGE)[1] / (_e(screen.width, screen.height) * Oo(s.graph_qual)), 
a.$oe = qi(t, this.$h9 - 2 - kt), i += zt - Rt;
for (var d = a.$o1 = new a.$ld(2 * or), p = (l = 0, 2 + (d.length >> 3)); l < p; ++l) d[l] = t.getInt16(i += Rt, Qe);
for (p = d.length >> 2; l < p; l += 2) d[l] = d[p - l + 1], d[l + 1] = d[p - l];
var f = p;
for (p = d.length >> 1; l < p; l += 2) d[l] = -d[l - f + 1], d[l + 1] = d[l - f];
for (f = p, p = d.length; l < p; ++l) d[l] = -d[l - f];
a.$nl = new a.$lc(a.$ii[1] + 1), a.$nm = new a.$lc(a.$ii[1] + 1);
for (var g = 0; g <= a.$ii[1]; ++g) a.$nl[g] = a.$ie + ((kr(g, a.$ii[0], a.$ii[1]) - a.$ii[0]) * a.$ig / (a.$ii[1] - a.$ii[0]) | 0), 
a.$nm[g] = a.$nl[g] * a.$lf * (1 / 65536);
a.$im = 0;
var $ = new Uint16Array(n);
for (l = 0; l < n; ++l) $[l] = t.getUint16(this.$h9 + (l << 1), Qe), a.$im += (l + 1) * $[l];
a.$nn = ToString(FromUTF8(new Uint8Array(t.buffer, t.byteOffset + this.$h9 + $.buffer.byteLength, r))), 
a.$pz(), vr("arena = " + a.$nn + " rejoin=" + (Jc.$oc ? 1 : 0)), a.$no = new Uint16Array(a.$im + 1), 
a.$np = new Float32Array(a.$im + 1), a.$nq = new Float32Array(a.$im + 1), a.$nq[0] = 1;
for (var b = 1, L = 1, E = 0; b <= n; ++b) for (l = 0; l < $[b - 1]; ++l) {
for (var P = 1; P < b; ++P, ++L) a.$no[L] = E, a.$np[L] = P / b, a.$nq[L] = 1 / b;
a.$no[L] = ++E, a.$np[L] = 0, a.$nq[L] = 1 / b, ++L;
}
var k = _e(a.$iu, a.$iv * a.$i8) * _e.apply(null, fn) * a.$hf.$bn.reduce(function(e, t) {
return _e(e, t.$9w, t.$9x);
}, 1) * mn >= a.$lb, O = 1024 * (On ? 1 : 2), D = kr(4 * a.$hf.$bn.length * a.$nh / (rn * Re * .25) | 0, .25 * O, O), N = M | A | T | v | y | w | C | _ | x | S;
if (a.$je = new Array(rn), 1 === nn) {
var I = a.$je[0] = G(k, null, D, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneFactor
}, Sn, null, N);
a.$ke.add(I), I.position.z = ht;
} else for (var R = nn >>> 1, j = Dr(R), U = -R, B = 0, z = null; U < R; ++U) for (l = -R; l < R; ++l, 
++B) Dr(U + (U < 0)) + Dr(l + (l < 0)) <= j && (z = (I = a.$je[B] = G(k, z, D, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneFactor
}, Sn, null, N)).$87, a.$ke.add(I), I.position.z = ht);
for (a.$ns = 1 / Ne(2 * a.$id / nn), e(!a.$jr.$gg.size), I = a.$jf = G(k, a.$je[0].$87, D, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneFactor
}, Mn), a.$ke.add(I), I.position.z = dt, l = 1, z = null; l > 0; --l) I = Y(1, z, O, 1, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendDstAlpha: $3.OneFactor
}, An + 1 - l, null), z = z || I.$87, I.position.z = pt, a.$jg = I, a.$ke.add(I);
if (On && 1 === s.controls) {
var F = 2 * Rn >= a.$la;
I = a.$n8 = G(F, F === a.$jg.$86 ? a.$jg.$87 : null, 128, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendDstAlpha: $3.OneFactor
}, En), a.$hg.add(I), I.position.z = vt, a.$n9 = ii(), a.$na = 0;
}
a.overlay_mesh = new $3.Mesh(new $3.PlaneGmtr(4 * a.$i6, 4 * a.$i6), new $3.PointsMtrl({
transparent: !0,
color: 0,
opacity: 0
})), a.overlay_mesh.position.z = gt, a.overlay_mesh.renderOrder = Ln, a.$hg.add(a.overlay_mesh), 
a.$i5();
for (var V = a.$lp = new a.$ld(2 * or * 4), W = a.$lq = new a.$lc(2 * or * 2), q = a.$lr = new Float32Array(2 * or), H = 0, X = 0, J = 0, Z = 0; H <= 1; ++H) {
l = 0;
for (var K = u + h * H + 1; l < or; ++l, ++X, J += 2, Z += 4) V[Z + 2] = (V[Z + 0] = d[2 * l]) * K >> 15, 
V[Z + 3] = (V[Z + 1] = d[2 * l + 1]) * K >> 15, W[J + 0] = Dr(d[2 * l]) + Dr(d[2 * l + 1]), 
W[J + 1] = Dr(V[Z + 2]) + Dr(V[Z + 3]), q[X] = we(W[J + 1]);
}
a.$ip = (a.$iq = V[4 * ar + 2]) / (a.$ir = V[2]), Ai || (Ai = function(e) {
for (var t = e.$nm[0] / e.$nl[0], n = new Float32Array(Si + 1), r = 0, i = 0, a = 1 / Si; r <= Si; ++r, 
i += a) {
var o = i;
n[r] = Ae(Te(t * (o < .5 ? o : 1 - o)));
}
return n;
}(a)), a.$mr = a.$mu = a.$mx = null, a.$mv = a.$mt = 0, a.$pc(), a.$po(), a.$pn(), 
a.$pp(), a.$pr(), a.$ph(!0), nt && ((I = a.$jh = function(e, t, n, r, i, a) {
var s = $0([ 868, 876, 790, 332, 868, 876, 887, 73, 868, 870, 25, 140, 843, 876, 799, 807, 843, 866, 790, 576, 861, 790, 812, 861, 852, 838, 861, 852, 872, 861, 790, 763, 873, 881, 888, 774, 782, 796, 817, 888, 876, 799, 244, 809, 404, 829, 713, 890, 679, 890, 637, 800, 879, 809, 794, 890, 862, 890, 656, 867, 213, 809, 401, 890, 627, 890, 400, 829, 247, 347, 809, 576, 815, 809, 654, 870, 790, 858, 809, 885, 877, 719, 874, 690, 772, 809, 520, 829, 755, 877, 602, 890, 858, 874, 886, 890, 812, 891, 889, 888, 879, 809, 880, 867, 891, 891 ]), c = $0([ 861, 790, 812, 861, 852, 838, 861, 852, 872, 861, 790, 763, 868, 388, 517, 873, 881, 888, 866, 887, 23, 809, 659, 195, 766, 809, 616, 787, 874, 473, 423, 890, 771, 866, 790, 116, 809, 670, 874, 812, 670, 781, 136, 796, 817, 890, 677, 891 ]), l = {
uniforms: {
tex_conf: {
type: "4f",
value: Float32Array.of(n.offset.x, n.offset.y, 1 / n.repeat.x, 1 / n.repeat.y)
},
tex_rot_mat: {
type: "m2f",
value: Float32Array.of(Se(r), -Ae(r), Ae(r), Se(r))
},
tex: {
value: n
}
},
vertexShader: s,
fragmentShader: c,
transparent: !0,
blending: $3.CustomBlending
}, u = new $3.ShaderMtrl(l);
return u.setValues(i), new o(!0, u, e, t, a, M | A | w | m);
}(O >>> 2, 1, a.$nv, No, {
blendSrc: $3.SrcAlphaFactor,
blendSrcAlpha: $3.OneFactor,
blendDst: $3.OneMinusSrcAlphaFactor
}, _n)).position.z = ut, a.$ke.add(I));
a.$p5(hr);
}), new Sa(Ft + 1 + _t + Ot + er + Gt + Pt + Bt, !0, function(e, t, n) {
var r = Ft + 1 + _t, i = r + Ot + er + Gt;
this.$ha = e.getUint8(r - _t);
var a = Zc(), o = Qi(e, It + 1), s = this.$ha, c = Er(e, r, Qe), l = {
$d3: e.getUint8(It),
$d2: o,
$d7: ToString(FromUTF8(new Uint8Array(e.buffer, e.byteOffset + this.$h9, s))),
$d6: c,
$do: ToString(FromUTF8(new Uint8Array(e.buffer, e.byteOffset + r + Ot, er))),
$dp: e.getUint32(r + Ot + er, Qe),
$di: qi(e, i) + c,
$ds: Ji(e, this.$h9 - Bt)
}, u = a.$jq.$cv(o), h = 0;
u && (a.$jq.$cx(o, !0), h = u.$dg), u = a.$jq.$cu(l), h && (u.$dg = h), a.$me = !0;
}), new Sa(Ft, !0, function(e) {
var t = Zc().$jq.$cv(Qi(e, It));
t && (t.$dg = -0, t.$ct(Tr()));
}), new Sa(Ft + Pt + 2 * Dt + Ut + Bt, !0, function(e, t, n) {
var r = Zc(), i = Qi(e, It), a = qi(e, Ft), o = ea(e, Ft + Pt, 2), s = Int32Array.of(-1, -1, -1, o[0], o[1], e.getUint16(this.$h9 - Ut - Bt, Qe), Ji(e, this.$h9 - Bt), 0, 0), c = r.$jq.$cv(i);
c.$ft(2, a + c.$d6, r.$qm(s));
}), new Sa(It + 2, !0, function(e, t) {
var n = Zc(), r = e.getUint8(It), i = It + 1, a = 1 + (3 & r), o = 1 + (r >>> 2 & 3), s = 1 + (r >>> 4 & 3), c = 1 + (r >>> 6 & 3), l = aa[a](e, ++i), u = l + oa[o](e, i += a), h = l + oa[s](e, i += o), d = 1 === c ? -1 : l + oa[c](e, i += s);
this.$ha = a + o + s + c, n.$os |= e.getUint8(It + 1), n.$he(l, u, h, d, t);
}), new Sa(It + 2 * Pt, !1, function(e, t, n) {
n.$gx(rr);
}), new Sa(It + 1, !0, function(e, t, n) {
n.$gx(rr), n.$d2 = e.getUint8(It);
}), new Sa(Ft, !0, function(e, t, n) {
n.$gx(rr), n.$d2 = Qi(e, It);
}), new Number(da), new Number(pa), new Number(20), new Sa(Ft + Nt + Pt + 4 + 2 * Dt + 1 + Pt, !0, function(e) {
var t, n = Zc(), r = Qi(e, It), i = n.$jq.$cv(r), a = Qi(e, Ft), o = ea(e, this.$h9 - Pt - 1 - 2 * Dt), s = ea(e, this.$h9 - Pt - 1 - Dt);
i ? (i.$fi() ? i.$ft(256, qi(e, Ft + Nt) + i.$d6, n.$qm([ e.getInt32(Ft + Nt + Pt, Qe), e.getUint8(this.$h9 - Pt - 1), o, s, a ? (t = n.$jq.$cv(a)) && t.$fg() || n.$of.get(a) : "border", qi(e, this.$h9 - Pt) ])) : (i.$ds = 0, 
n.$qf()), r === n.$d2 && ue.push("pd " + n.$jk + " " + (i.$di + n.$n0) + " " + (qi(e, Ft + Nt) + i.$d6 + n.$n0) + "  " + (0 | Ar()) + " " + (0 | n.$l7))) : i || de("/pd_" + n.$d2 + "_" + r + "__" + (n.$jq.$cr ? "1_" + n.$jq.$cr.$di + "_" + n.$jq.$cr.$dh.$es : "0") + "_" + qi(e, Ft) + "__" + Tr());
}), new Number(fa), new Sa(It, !1, function(e, t, n) {
n.$gx(rr);
}), new Sa(It, !1, ja(1)), new Sa(It, !1, ja(2)), new Sa(It, !1, ja(3)), new Sa(It, !1, ja(4)), new Sa(It, !1, function(e, t, n) {
n.$gx(ir);
}), new Sa(It, !1, Ua(0)), new Sa(It + 1, !0, Ua(1)), new Sa(It + 2, !0, Ua(2)), new Sa(It + 3, !0, Ua(3)), new Sa(It + 4, !0, Ua(4)), new Sa(It + 8, !0, Ua(8)), new Sa(It + 1, !0, function(e, t, n) {
n.$h1 = e.getUint8(It);
}), new Sa(It + 1, !0, Ba(1)), new Sa(It + 2, !0, Ba(2)), new Sa(It + 4, !0, Ba(4)), new Sa(It + Dt, !0, function(e, t, n) {
n.$h2 = ea(e, It);
}), new Sa(It, !0, za(1)), new Sa(It, !0, za(2)), new Sa(It, !0, za(3)), new Sa(It, !0, za(4)), Va(0), Va(1), Va(2), Va(3), Va(4), Va(5), Va(6), Va(7), Va(8), Va(9), Va(10), Va(11), Va(12), Va(13), Va(14), Va(15), Wa(0, 0), Wa(1, 0), Wa(2, 0), Wa(3, 0), Wa(4, 0), Wa(5, 0), Wa(6, 0), Wa(7, 0), Wa(8, 0), Wa(9, 0), Wa(10, 0), Wa(11, 0), Wa(12, 0), Wa(13, 0), Wa(14, 0), Wa(15, 0), Wa(0, 1), Wa(1, 1), Wa(2, 1), Wa(3, 1), Wa(4, 1), Wa(5, 1), Wa(6, 1), Wa(7, 1), Wa(8, 1), Wa(9, 1), Wa(10, 1), Wa(11, 1), Wa(12, 1), Wa(13, 1), Wa(14, 1), Wa(15, 1), new Number(ma), new Sa(It, !0, Fa(3, 3)), new Sa(It, !0, Fa(3, 4)), new Sa(It, !0, Fa(4, 3)), new Sa(It, !0, Fa(4, 4)), new Sa(It, !0, Ga(3)), new Sa(It, !0, Ga(4)), qa(32), qa(64), Ha(32), Ha(64), Xa(1), Xa(-1), new Sa(It + Pt + Bt, !0, function(e, t, n) {
var r = Zc().$jq.$cv(n.$d2), i = Ji(e, this.$h9 - Bt);
r && r.$fi() && r.$ft(i >= 0 ? bt : $t, qi(e, It) + r.$d6, i);
}), new Sa(Ft, !0, function(e, t, n) {
n.$gx(ir);
var r = Zc(), i = r.$jq.$cv(Qi(e, It));
r.$kt.set(r.$kt.size + 1, [ 0, i ? i.$df : r.$hf.$b8[xe() * r.$hf.$b8.length * .999 | 0] ]), 
n.$h3 = !0;
}), new Sa(It, !1, function(e, t, n) {
n.$h3 = !1;
}), new Sa(It + 2 * Nt + 2 + Pt + 2 * Dt, !0, function(e) {
var t = Zc(), n = Qi(e, It), r = Qi(e, Ft), i = r || n, a = t.$jq.$cv(i), o = e.getUint8(It + 2 * Nt), s = (e.getUint8(It + 2 * Nt + 1), 
qi(e, It + 2 * Nt + 2) + t.$is - (i === t.$d2 ? t.$jo - t.$jn : 0));
a && a.$fi() && a.$ft(128, s, t.$qm([ r ? n : 0, ea(e, this.$h9 - 2 * Dt, 2), i === n ? o : o >>> 1 | (1 & o) << 1 ]));
}), new Sa(It + Pt + zt, !0, function(e) {
var t = Zc(), n = Ki(e, this.$h9 - zt);
t.$jr.$bt(n, null, qi(e, It), 0);
}), new Number(ga), new Sa(It, !1, function(e, t, n) {
n.$gx(rr);
}), new Sa(Ft + Nt + Pt + 2, !0, function(e, t) {
var n = Zc().$k6, r = e.getUint16(this.$h9 - 2);
this.$ha = r;
var i = ToString(FromUTF8(new Uint8Array(e.buffer, e.byteOffset + this.$h9, r))).split("\n");
n && (n.$hm = [ Qi(e, Ft), t + qi(e, Ft + Nt), i.slice(0, i.length - 1), parseInt(Or(i)) ]);
}), new Sa(It, !1, function() {
var e = Zc().$k6;
e && (e.$hm = Vn);
}), new Sa(It + 4, !0, function(e) {
Zc().$or = e.getUint32(It, Qe);
}), new Sa(Ft + Pt + Bt, !0, function(e) {
var t = Zc(), n = Qi(e, It), r = t.$jq.$cq.get(n), i = qi(e, Ft), a = Ji(e, Ft + Pt);
if (r) {
var o = new ai(_e(i + r.$d6, Tr()), a);
r.$dr.push(o);
}
}), new Sa(It + 2 * Pt + 2 * Dt + Ut + Bt, !0, function(e, t, n) {
var r = Zc(), i = n.$d2, a = r.$jq.$cv(i), o = qi(e, It), s = qi(e, It + Pt), c = ea(e, It + 2 * Pt, 2), l = a.$d5 = new Int32Array(9), u = a.$d8 = r.$k9.hstr.$ar();
a.$fi() && de("/pis_" + i + " " + r.$d2), l[3] = c[0], l[4] = c[1], l[5] = e.getUint16(this.$h9 - Ut - Bt, Qe), 
l[6] = Ji(e, this.$h9 - Bt), l[7] = l[8] = 0, a.$d4 = o + a.$d6, a.$d9 = new Float32Array(u.buffer), 
a.$da = 0, a.$ft(1, s + a.$d6), u.set(l.subarray(3), 3), a.$d9[8] = 1 / (a.$d9[7] = r.$lr[u[5]] / r.$nm[Me(r.$ii[1], u[6])]), 
a.$fb();
}), new Sa(Ft, !0, function(e, t, n) {
var r = Zc(), i = Qi(e, It), a = r.$jq.$cv(i);
a && a.$fi() || de("/pu_" + i + " " + r.$d2), a.$fv(0), a.$d4 = Number.MAX_VALUE;
}), new Sa(Ft, !0, function(e, t, n) {
var r = Zc(), i = Qi(e, It);
this.$ha = i * (Nt + Bt);
for (var a = 0, o = this.$h9; a < i; ++a, o += Nt + Bt) {
var s = r.$jq.$cv(Qi(e, o)), c = Ji(e, o + Nt);
s && (s.$ds = c);
}
r.$qf();
}), Ya(1), Ya(-1), new Sa(It + Bt, !0, function(e, t, n) {
this.$ha = n.$gu;
var r = Zc().$jq.$cv(n.$d2), i = n.$h4(e, It), a = Ji(e, It + n.$gu);
r && r.$fi() && r.$ft(a >= 0 ? bt : $t, i + r.$d6, a);
}), new Sa(It + 2, !0, function(e, t, n) {
var r = Zc(), i = It + 1, a = e.getUint8(It), o = 1 + (3 & a), s = 1 + (a >>> 2 & 3), c = aa[o](e, ++i), l = c + oa[s](e, i += o);
this.$ha = o + s, r.$os |= e.getUint8(It + 1), r.$he(c, l, 0, -1, t);
}), new Sa(It + 1, !0, function(e, t) {
var n = Zc(), r = e.getUint8(It);
ue.push("csr" + r + " " + n.$jk + " " + n.$oi + " " + (0 | t)), r && (2 === n.$k0.switch_rooms || r >= 2) && n.$p8(va);
}), new Sa(It + 1, !0, function(e) {
de("/sr" + e.getUint8(It));
}), new Number($a), new Number(126), new Number(127) ];
function Za(e) {
vr("Connection opened.");
var t = Zc();
t.$k0 = GLOB[gn[16]](), t.$k0.show_flags = 0, t.$pv(Uint8Array.of(ca)), t.$ol = Number.MIN_VALUE, 
ue.push("so " + t.$jk + " " + (0 | Ar()));
}
var Ka = "", Qa = "";
function eo(e) {
var t = Zc();
vr(e ? "Connection error: data=" + e : "Connection error"), Qa = "d=" + e, ue.push("ser " + t.$jk + " " + e + " " + (0 | Ar())), 
t.$p8(Kt);
}
function to(e, t, n) {
vr("Connection closed: code=" + e + " reason=" + t), Ka = "c=" + e + "_r=" + t;
var r = Zc();
ue.push("cl " + r.$jk + " " + e + "_" + t + " " + (0 | Ar()) + " " + (0 | r.$l7) + "  " + (n === r.$cl)), 
200 === parseInt(t) && de("/woc_" + ue), 1011 === e ? ie() : 1006 === e ? Tc(bc, pc) : 1001 === e && 201 === parseInt(t) ? Tc(bc, mc) : 1002 === e && 100 !== parseInt(t) ? Tc(bc, fc(t)) : (1002 === e && 107 === parseInt(t) && de("/107"), 
r.$p8(Zt, !0));
}
function no(e) {
ue.push("cl2 " + Zc().$jk + " " + e.code + "_" + e.reason + " " + (0 | Ar()));
}
function ro(e) {
var t = Zc(), n = new DataView(new ArrayBuffer(5));
n.setUint8(0, $a), n.setUint16(It, t.$op, Qe), n.setUint16(Ft, t.$d2, Qe), e.target.send(n.buffer), 
t.$n6.find(function(t) {
return t[0] === e.target;
})[1] = !0;
}
function io(e) {}
function ao(e) {
var t = Zc(), n = t.$n6.findIndex(function(t) {
return t[0] === e.target;
});
n >= 0 && (t.$n6[n][1] && !(1e3 === e.code || 1011 === e.code || 1002 === e.code && e.reason) && setTimeout(function() {
t.$jk === qt && t.$jq.$cr && t.$p5(hr);
}, 1e3), t.$n6.splice(n, 1));
}
function oo(e) {}
var so = new Uint32Array(128), co = new Float64Array(128);
function lo(t) {
var n = Zc(), r = Sr(t.timeStamp), i = t.data.byteLength, a = 0, o = n.$jz, s = new DataView(t.data);
if (r > 2147483647 && de("/wom_" + r + "_" + TIME_ORIGIN + "_" + n.$jk), e(i > 0), 
Pe(r - n.$ol) > 1e3 && n.$qo(), n.$ol = r, 2 === n.$oi) (c = s.getUint8(a)) === ya && (s.getUint8(a + It) ? (n.$oi = 0, 
n.$oj = -0, i > Ja[c].$h9 && de("/sr2_" + n.$jk + "_" + i)) : n.$p8(Qt)); else for (;a < i; ) {
var c = s.getUint8(a), l = Ja[c];
e(l && "object" == typeof l && l.$hd && i - a >= l.$h9);
var u = l.$hd(l.$hb && new DataView(t.data, a), r, o);
a += u, ++so[c], co[c] += u;
}
if (n.$ko > 0) {
var h = n.$q4(n.$ko);
te.$ag(n.$js, r, n.$ko, n.$kn[h], n.$kn[h + 1], i, n.$l7);
}
}
var uo = null;
function ho(e) {
var t = Zc(), n = Ar();
if (!(t.$l7 && t.$l8 % 2)) {
e ? (e > t.$mh + t.$n0 && ee.$ct(e), t.$kl = 0) : t.$km = 0, Jc.$n0 !== Jc.$n5 && et && (Jc.$n0 += je(Jc.$n5 - Jc.$n0) * Me(1e3 * tt / Ze, Pe(Jc.$n5 - Jc.$n0)));
var r = e && null !== t.$o8;
r && fo(e), te.$af(t.$js, e || n, n, r ? e || n : Ar(), t.$l7, (t.$p1() ? "1" : "0") + (t.$kw ? "1" : "0")), 
function(e) {
var t = Zc();
if (t.$p1() && t.$kw > 0) {
var n = e - t.$n0, r = n - t.$mh;
t.$mh < n && (t.$hl.render(t.$hg, t.$hk), t.$mh = n), --t.$kw, t.$mh > 0 && (t.$mi[1][t.$mj[1]++] = r, 
t.$mj[1] *= t.$mj[1] < t.$mi[1].length);
}
}(e || n);
var i = ee.$c4(n + (t.$mz ? 1e3 / Ze : 0));
t.$l7 && fo(i), t.$p2(i);
}
}
var po = 1;
function fo(e) {
var t = Zc(), n = t.$jk;
if (t.$o8 = null, n !== Vt) {
var r = t.$jq.$cr;
if (n === Wt || n === Xt) {
t.$n0 && t.$nz.length && (ue.push("ps " + t.$jk + " " + (0 | Ar())), t.$pv(t.$nz[0]), 
t.$nz.length = 0), t.$ou(e || Ar());
var i = t.$k6;
if (t.$n0 > 0 && r && !Kc) return t.$p8(Jt, e || Ar()), void (t.$js = 0);
if (t.$cl && t.$cl.readyState === WebSocket.CONNECTING && 0 === t.$mk && e >= t.$mm + wc) return ue.push("ct " + n + " " + (e - t.$mm | 0)), 
t.$cl.onopen = t.$cl.onmessage = t.$cl.onerror = t.$cl.onclose = ne, t.$cl.close(), 
void t.$p8(Zt, !0);
} else {
var a = function(e, t) {
return e && t < e ? e : ee.$c4(t);
}(e, Ar()), o = _e(t.$mg, a - t.$n0), s = t.$q4(t.$ko), c = o < t.$kn[s], l = o + t.$o2, u = t.$mz && t.$js > po && 1 & t.$js;
if (n === qt && t.$n6.length && (o - t.$mh > kr(10 * ee.$ab[1], 100, 200) || xe() < .001) && t.$oq < 4294967295 && (t.$oq = o + 300), 
o > t.$oq && (t.$oq = -0), n === qt && !t.$og && t.$oh && (t.$qp(), t.$oh = 0), 
te.$ae(t.$js, a, a - e, t.$kn[s] + t.$n0, c, t.$l7), t.$js === po) n === qt && t.$gp.$gr(t.$mr = t.$pm(o + it, at, function(e) {
1 === e && (t.$mr = null);
}, 1)); else if (t.$js === po + 1 && n === qt) {
t.$k0.show_lbrd ? sc("#aux-canvas,#room-wait-info,#clr-select-area", "#main-canvas,#lbrd,#stats,#gl-stats")() : sc("#aux-canvas,#room-wait-info,#clr-select-area,#lbrd", "#main-canvas,#stats,#gl-stats")(), 
se("main-canvas").focus();
var h = t.$k8;
window.innerWidth === h.width && window.innerHeight === h.height || dc(), t.$p7(!0), 
t.$k6 = null, t.$od = !0;
}
if (r && o >= r.$d4 && 0 === r.$dg && (r.$ct(l) || 0 !== r.$dg || (t.$q0(l), c && !u && (r.$fq(o, !1), 
t.$pg(o)), t.$kp = t.$ko)), !u) {
t.$me && t.$q9() && (t.$me = !1);
var d = null;
if (c) t.$jq.$ct(o), qo && t.$q9(), t.$pd(o), t.$qa(o); else if ((o - t.$kn[s] | 0) > t.$mp && !t.$mq) {
var p = t.$mp = o - t.$kn[s] | 0;
d = "/delay/" + p + "/" + t.$ju, vr("delay max = " + p);
}
t.$jr.$ct(o), t.$gp.$ct(o, function(e) {
e.$d2 = 0, t.$k9.anim.$ap(e);
}), t.$pi(o), t.$pk(), t.$pl(o), d ? uo = d : uo && (d = uo, uo = null), (t.$js <= po || c) && (t.$kw = 1), 
0 === t.$kw && o >= _e(t.$kn[s], r ? r.$di : Number.MAX_SAFE_INTEGER) + wn && Tc(bc, yc), 
t.$ot(o), o > t.$nf && (t.$nf = o + lt);
var f = o - t.$mg;
t.$mg > 0 && (t.$mi[0][t.$mj[0]++] = f, t.$mj[0] *= t.$mj[0] < t.$mi[0].length), 
t.$mf = a, t.$mg = o;
}
if (o > t.$ok + Da && (0 === t.$og && setTimeout(t.$om, 0), t.$ok = o), (t.$js += !!(t.$js || r && o >= r.$d4)) >= po) return;
t.$ou(a);
}
!t.$mq && (t.$jk === Wt || t.$jk === Xt ? 0 === t.$n0 && 0 === t.$mk && e >= _e(i.$d4, t.$ml, t.$mn) + xc || 2 === t.$oi && t.$oj && e > t.$oj + xc : r && e >= t.$n0 + r.$d4 + xc) && (de("/ofv_" + t.$jk + "_" + (t.$cl && t.$cl.readyState) + "_" + t.$oi + "_[" + t.$mk + "_" + t.$ml + "_" + (i && i.$d4) + "_now=" + e + "_" + Bc + "]_" + !!t.$ni + "_lc=" + Ka + "_le=" + Qa + "__" + Ze + "_ss=" + (t.$k5 && t.$k5.$ci) + "___t0=" + t.$n5 + "_" + t.$n0 + "_" + (r && r.$d4) + "_" + performance.timeOrigin + "_" + TIME_ORIGIN + "___" + unescape(encodeURIComponent(Cc)) + "_bl=" + t.$l7 + "_" + ue + " [" + t.$n2 + "] " + unescape(encodeURIComponent(GLOB[gn[16]]().last_ws)), !0), 
t.$k5 ? Tc(bc, yc) : Tc(2 * bc, gc));
}
}
var mo = null;
function go(e) {
var t = window.innerWidth, n = window.innerHeight, r = Oo(We.length - 1), i = null;
return e.getSize(Co), r !== e.getPixelRatio() && (e.setPixelRatio(r), i = !0), Co.w === t && Co.h === n || (e.setSize(t, n, !0), 
i = !0), i && (mo = new $3.OrthographicCamera(-t / n, t / n, 1, -1, -1, 1)), mo;
}
function vo(e) {
var t = this, n = .5 * $n, r = .05 * n, i = .5 * n * .2 + r, a = Zc();
t.$hg = new $3.Scene(), t.$hh = Qr(n - i, n + i, r, r, Ii(a.$hf.$bb[0])), t.$hi = G(!0, null, 256, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor
}), t.$hj = ii();
var o = t.$e1 = new O();
o.$9v = oi, o.$aa = -n, o.$9w = i - r, o.$9z = Ii(a.$hf.$bb[1]), o.$a8 = .99, o.$a9 = on * bn, 
o.$a3 = 0, t.$d4 = e || Ar(), t.$hm = null, a.$le.setClearColor(a.$hf.$ay[0], 1), 
t.$hg.add(t.$hh), t.$hg.add(t.$hi), t.$hk = go(a.$le), sc(".overlay,#overlay-bg", 0)();
}
function yo(e) {
if ($("#start-btn,#restart-btn,#main-menu-btn").prop("disabled") != !e) {
$("#start-btn,#restart-btn,#main-menu-btn").prop("disabled", !e);
var t = se("main-canvas");
(e ? K.$bp : K.$bq)(t, "keydown", uc);
}
}
var $o = 1.3;
function bo(e, t, n, r) {
var i = this;
i.$de = e, i.$hr = t * (.5 - vn - yn[1]), $3.Group.call(i), i.add(i.$hx = new $3.Object3D()), 
i.$hx.add(i.$hq = G(yn[1] * i.$hr * $o >= e.$lb, null, 128, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneFactor
}, Cn, 1)), i.$hq.position.z = .001, i.$e7 = new O(), i.$e7.$a5 = 0, i.$e7.$a9 = 1e3 * on, 
i.renderOrder = e.$jg.$89 + 1, i.$gx(t, n, r), i.$hv = ii(), i.$hw = 0;
}
bo.prototype = new $3.Object3D(), bo.prototype.$hy = bo, bo.prototype.$hz = function(e, t) {
var n = this, r = n.$de;
if (e === r.$jq.$cr || e === r.$m4) {
var i = n.$e7, a = i.$9v = zn, o = e.$d2 === r.$d2, s = e === r.$m4, u = s ? $o : 1, h = 1 - kr((jr([ a[0] * r.$j5, a[1] * r.$j5 ]) - (1 + vn)) / vn, 0, 1);
a[0] = e.$dh.$e8[0] * r.$j5 * n.$hr, a[1] = e.$dh.$e8[1] * r.$j5 * n.$hr, a[2] = 0, 
i.$a9 = 1 * an, i.$9v = a, i.$9w = yn[0] * n.$hr * h, i.$9x = yn[1] * n.$hr * h * u, 
i.$9z = Ii((o ? r.$hf.$b1 : r.$hf.$b4)[0]), i.$a0 = Ii((o ? r.$hf.$b1 : r.$hf.$b4)[1]), 
i.$a8 = .4 / u, i.$a3 = s && !o ? 1.7 : 1, i.$a5 = 0, n.$hq.$8e(i, l, c);
}
}, bo.prototype.$i0 = function(e, t, n) {
var r = this;
if (r.$hw === r.$hv.length) r.$hv.push([ Tr(), t, n ]); else {
var i = r.$hv[r.$hw];
i[0] = Tr(), i[1] = t, i[2] = n;
}
++r.$hw;
}, bo.prototype.$i1 = function(e) {
var t = this;
if (0 !== t.$hw) {
var n = t.$hv, r = t.$e7, i = r.$9v = zn, a = 1 - kr((jr([ i[0] * Jc.$j5, i[1] * Jc.$j5 ]) - (1 + vn)) / vn, 0, 1);
r.$9v = i, i[2] = 0, r.$a9 = 0, r.$a3 = 1;
for (var o = 0, s = 0; o < t.$hw; ++o) {
var u = n[o], h = Ur(600, 2400, Me(1, u[2] / 1e4)), d = (e - u[0]) / h;
d >= 1 ? ++s : (i[0] = u[1][0] * Jc.$j5 * t.$hr, i[1] = u[1][1] * Jc.$j5 * t.$hr, 
r.$a5 = u[0] * on, r.$9w = r.$9x = yn[1] * t.$hr * a * 2 * (1 - Nr(1 - d)), r.$a8 = .4 + .1 * d, 
r.$9z = r.$a0 = $e(Ii(Jc.$hf.$b4[0]), Jc.$hf.$b4[1] << 8, d), t.$hq.$8e(r, l, c), 
s && (n[o] = n[o - s], n[o - s] = u));
}
t.$hw -= s;
}
}, bo.prototype.$gx = function(e, t, n) {
var r = this, i = Zc(), a = e * vn, o = .035 * e, s = r.$hx;
r.$hr = e * (1 - vn - .5 * yn[1]), r.$ht || (r.$ht = Qr(0, e + o, 0, o, i.$hf.$b2, Cn), 
s.add(r.$ht)), r.$hs || (r.$hu = e, r.$hs = Qr(e, e + a + 2 * o, o, o, i.$hf.$b3, Cn), 
s.add(r.$hs)), r.$hs.scale.x = r.$hs.scale.y = r.$ht.scale.x = r.$ht.scale.y = e / r.$hu, 
s.position.x = t, s.position.y = n;
};
var xo = {
alpha: !0
};
function wo(e, t, n) {
if ("OffscreenCanvas" in window) {
var r = new OffscreenCanvas(e, t);
try {
if ("getContext" in r && r.getContext(n || "2d", xo)) return r.width = e, r.height = t, 
r;
} catch (e) {}
}
return (r = document.createElement("canvas")).width = e, r.height = t, r;
}
function _o() {
var e = this;
e.$d2 = e.$op = e.$m2 = e.$kz = e.$i7 = e.$i9 = e.$ia = e.$j4 = e.$ib = e.$id = e.$ie = e.$ig = e.$it = e.$h2 = e.$ij = e.$ik = e.$im = e.$my = e.$iy = e.$iz = e.$ja = e.$jb = e.$ls = e.$jd = e.$m3 = e.$iq = e.$ir = e.$lm = e.$ln = e.$jo = e.$ko = e.$kb = e.$kq = e.$kr = e.$kp = e.$mz = e.$na = e.$ng = e.$nh = e.$js = e.$jp = e.$kw = e.$mp = e.$o0 = e.$o2 = e.$o5 = e.$oe = e.$og = e.$oh = e.$oi = e.$oo = e.$or = e.$os = 0, 
e.$jt = e.$n0 = e.$n3 = e.$n4 = e.$n5 = e.$m5 = e.$i8 = e.$ic = e.$i6 = e.$j5 = e.$if = e.$ih = e.$iu = e.$lt = e.$lu = e.$lv = e.$l6 = e.$is = e.$ka = e.$li = e.$lb = e.$lf = e.$ip = e.$ms = e.$k3 = e.$k2 = e.$k1 = e.$mf = e.$mg = e.$mh = e.$dk = e.$kk = e.$lg = e.$dl = e.$ki = e.$mv = e.$mw = e.$mt = e.$nf = e.$l7 = e.$ns = e.$ny = e.$j2 = e.$j3 = e.$o3 = e.$o6 = e.$o4 = e.$o7 = e.$la = e.$jn = e.$nk = e.$il = e.$ok = e.$ol = e.$on = e.$oq = e.$mm = e.$mn = e.$oj = e.$l8 = -0, 
e.$jx = e.$ju = e.$jv = e.$jy = e.$gp = e.$hg = e.$ke = e.$kd = e.$ll = e.$m1 = e.$m7 = e.$m8 = e.$m6 = e.$m4 = e.$mi = e.$mj = e.$kn = e.$lz = e.$kc = e.$jl = e.$ks = e.$jm = e.$jw = e.$l5 = e.$dy = e.$k6 = e.$cl = e.$n7 = e.$j1 = e.$ii = e.$je = e.$jf = e.$jg = e.$jh = e.$n8 = e.$k9 = e.$lp = e.$lq = e.$lr = e.$hk = e.$k7 = e.$m0 = e.$kg = e.$kh = e.$k0 = e.$mx = e.$mu = e.$mr = e.$lw = e.$k5 = e.$k4 = e.$n9 = e.$nl = e.$nm = e.$no = e.$np = e.$nq = e.$nt = e.$nu = e.$nv = e.$nd = e.$nb = e.$nc = e.$nw = e.$nn = e.$nz = e.$o1 = e.overlay_mesh = e.$o8 = e.$oa = e.$ob = e.$oc = e.$of = null, 
e.$me = e.$od = !1, e.$n2 = ii(), e.$nx = new Array(400);
for (var t = 0; t < e.$nx.length; e.$nx[t++] = new Int32Array(2)) ;
e.$kx = e.$ky = Number.MAX_VALUE, e.$ne = 9 * nr, e.$n6 = ii(), e.$jk = Vt, e.$jq = new Xr(e), 
e.$jr = new Ui(e), e.$jz = new Ma(), e.$kt = new Map(), e.$hf = pn[0], e.$mq = e.$kv = !1, 
e.$l9 = new Float64Array(2);
var n = se("main-canvas");
e.$k8 = n.getBoundingClientRect(), e.$hl = qr({
canvas: n,
antialias: !1,
alpha: !1,
depth: !1,
stencil: !1,
powerPreference: "high-performance",
preserveDrawingBuffer: !1
}), e.$le = qr({
canvas: $("#aux-canvas")[0],
antialias: !1,
alpha: !1,
depth: !1,
stencil: !1
});
var r = wo(zo[0], zo[1]), i = r.getContext("2d", xo);
i.clearRect(0, 0, r.width, r.height), i.textBaseline = "middle", i.font = Fo + "px sans-serif", 
e.$m9 = r, e.$ma = new $3.CanvasTexture(e.$m9), e.$ma.generateMipmaps = !0, e.$ma.magFilter = e.$ma.minFilter = $3.LinearFilter, 
e.$ma.wrapS = e.$ma.wrapT = $3.ClampToEdgeWrapping, e.$oa = new $3.MeshBasicMtrl({
side: $3.DoubleSide,
map: e.$ma,
transparent: !0
});
var a = 1 << Ne(Ee(i.measureText("+00000000").width)), o = 1 << Ne(Ee(Yo * Jo(Ho[1])));
(i = (r = wo(a, o)).getContext("2d", xo)).clearRect(0, 0, r.width, r.height), i.textBaseline = "middle", 
i.font = Ho[0] + "px sans-serif", e.$mb = r, e.$mc = new $3.CanvasTexture(e.$mb), 
e.$mc.generateMipmaps = !0, e.$mc.magFilter = e.$mc.minFilter = $3.LinearFilter, 
e.$mc.wrapS = e.$mc.wrapT = $3.ClampToEdgeWrapping, e.$ob = new $3.MeshBasicMtrl({
side: $3.DoubleSide,
map: e.$mc,
transparent: !0
}), e.$md = new Array(Yo);
for (t = 0; t < e.$md.length; ++t) {
var s = new $3.Mesh(new $3.PlaneGmtr(1, 1), e.$ob.clone()), c = s.geometry.faceVertexUvs[0], l = t * Jo(Ho[1]) / o, u = (t + 1) * Jo(Ho[1]) / o;
e.$md[t] = Array.of(s, !1), s.renderOrder = Tn, c[0][0].set(0, u), c[0][1].set(0, l), 
c[0][2].set(1, u), c[1][0].set(0, l), c[1][1].set(1, l), c[1][2].set(1, u), s.geometry.uvsNeedUpdate = !0;
}
e.$lc = Int32Array, e.$ld = Int16Array, e.$lo = new e.$lc(4), Ui.prototype.$i2 = new e.$lc(2), 
e.$mk = e.$ml = -0, e.$mo = !1, e.$lx = null, e.$kl = e.$km = e.$ni = 0, e.$om = function() {
e.$qo();
}, e.$gx();
}
function Mo(e) {
var t;
try {
t = new Blob([ e ], {
type: "application/javascript"
});
} catch (e) {
(t = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder)()).append(response), 
t = t.getBlob();
}
return new Worker((window.URL || window.webkitURL).createObjectURL(t));
}
_o.prototype.$i3 = new $3.ShaderMtrl({
vertexShader: $0([ 843, 852, 859, 843, 887, 531, 861, 852, 872, 861, 887, 773, 861, 852, 313, 873, 881, 888, 879, 809, 794, 890, 862, 890, 845, 867, 815, 809, 713, 890, 863, 874, 336, 826, 809, 531, 875, 809, 859, 891 ]),
fragmentShader: $0([ 861, 870, 852, 872, 861, 866, 887, 773, 861, 870, 852, 313, 873, 881, 888, 870, 790, 652, 809, 885, 874, 65, 423, 874, 824, 766, 809, 539, 99, 235, 891 ]),
depthTest: !1,
transparent: !0,
side: $3.DoubleSide,
depthFunc: $3.LessEqualDepth,
blending: $3.CustomBlending,
blendSrc: $3.SrcAlphaFactor,
blendSrcAlpha: $3.OneFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendDstAlpha: $3.OneFactor
}), _o.prototype.$i4 = new O(), _o.prototype.$i4.$9w = _o.prototype.$i4.$9x = _o.prototype.$i4.$a1 = _o.prototype.$i4.$a2 = 0, 
_o.prototype.$i5 = function() {
for (var e = this, t = 1.25 * e.$ng | 0, n = e.$nh + .33 * e.$ng * Ur(e.$ij, e.$im, .5) | 0, r = [ [ Float64Array, 1e3, 1e3 ] ], i = [ [ "hstr", t, t, function() {
return new Int32Array(e.$ne);
} ], [ "item", n, n, function() {
return new Ri(e);
} ], [ "anim", 1e3, 1e3, function() {
return new Bi();
} ], [ "di", t, t, function() {
return new pi(e);
} ], [ "maxlenf", t, t, function() {
return new Float32Array(e.$im);
} ], [ "pai", 1e3, 1e3, function() {
return new s();
} ], [ "pp", 500, 500, function() {
return new O();
} ], [ "cfm", 5, 5, function() {
return Qr(0, Yn[0], 0, .99 * Yn[0], Ii(Jc.$hf.$b4[0], Zn[0]), Cn - 1);
} ] ], a = this.$k9 = {}, o = 0; o < r.length; ++o) for (var c = 3; c < r[o].length; ++c) a[r[o][c]] = new be(r[o][1], r[o][2], function(e, t) {
return function() {
return new e(t);
};
}(r[o][0], parseInt(r[o][c])));
for (c = 0; c < i.length; ++c) a[i[c][0]] = new be(i[c][1], i[c][2], i[c][3]);
}, _o.prototype.$ot = function(e) {
var t = this, n = e > t.$k1 + 2500;
if (n) {
var r = se("stats-fps"), i = t.$q7(0), a = t.$q7(1);
if (r) {
var o = r.textContent;
(0 === o.length || Pe(a - parseInt(o)) > 1 || a === Ze) && Hr(r, a + "/" + i);
}
t.$pz();
}
if ((n || t.$od) && t.$jq.$cr) {
for (var s = t.$nw, c = 0; c < s.length && null !== s[c][0]; ++c) ;
for (var l = 0; l < c; ++l) if (s[l][0] === t.$d2) {
Hr(se("stats-rank"), l + 1), Hr(se("stats-num-players"), c);
t.$jq.$cr.$d8, t.$jq.$cr.$fr(e, !0);
Hr(se("stats-score"), t.$jq.$cr.$ds), t.$lg = Me(Number.MAX_SAFE_INTEGER, l + 1);
}
}
n && (t.$k1 = e), t.$od && (t.$qg(e), t.$od = !1);
}, _o.prototype.$ou = function(t) {
e(this.$k6);
for (var n = this, r = n.$k6, i = (t - r.$d4) / bn % 1, a = 0, o = new Float32Array(2); a < 2; ++a) {
var l = (i + .1 * (2 * a - 1) + 1) % 1, u = .5 - Pe(.5 - l);
o[a] = .25 * u * (2 + 2 * u * 7) / 2.25, l > .5 && (o[a] = 1 - o[a]);
}
ei(r.$hh, $e(Ii(Jc.$hf.$bb[0]), 4294967295, .08 * (1 - Se(i * Be)))), Pe(o[1] - o[0]) > .5 && (o[0] += je(o[1] - o[0])), 
o[0] = (o[0] - .25) * Be, o[1] = (o[1] - .25) * Be, r.$e1.$9z = 255 | $e(n.$hf.$bb[1] << 8 >>> 0, n.$hf.$bb[2] << 8 >>> 0, .5 * (1 - Se(i * Be)));
for (var h = 0, d = r.$hj, p = d.length, f = o[0], m = r.$e1, g = m.$9w, v = .15 * m.$9w / -m.$aa; f <= o[1] && h < p; ++h, 
f += v) m.$a7 = -f * ze, d[h].$8o(m, 1044);
for (;f <= o[1]; ++h, f += v) m.$a7 = -f * ze, d.push(r.$hi.$8e(m, new s(), c));
for (m.$9w = 0, p = d.length; h < p; ++h) d[h].$8o(m, 1024);
m.$9w = g;
var y = r.$hm, b = n.$qc("#room-wait-msg");
if (y) if (y.length) {
b[0].textContent.startsWith("S") || (b.html('Starting <span></span> in <span class="sel-text" style="display: inline-block; width: 1.2rem; text-align: center"></span>...<br><span class="sel-text" style="display: inline-block; width: 1.2rem; text-align: right"></span>/<span class="sel-text"></span> players joined...<br><span class="sel-text"></span>'), 
$("#room-wait-msg > span.sel-text").css("color", n.$hf.$bj));
var x = n.$qc("#room-wait-msg")[0].getElementsByTagName("span"), w = y[2].length, _ = y[3] + _e(0, y[2].length + y[3] - y[0]), M = w ? y[2].slice(0, y[0]).join(",") + (_ ? " & " + _ + " more..." : "") : "";
Hr(x[0], "@" + Oa()[2]), Hr(x[1], _e(0, Ne(.001 * (y[1] - t)))), Hr(x[2], y[2].length + y[3]), 
Hr(x[3], y[0]), Hr(x[4], M);
} else {
for (;b[0].children.length > 0; ) b[0].removeChild(b[0].lastChild);
b[0].textContent.startsWith("N") || (Hr(b[0], "Not enough players to create @" + Oa()[2] + "..."), 
sc("#abort-btn", 0)());
} else {
for (;b[0].children.length > 0; ) b[0].removeChild(b[0].lastChild);
b[0].textContent.length && (Hr(b[0], ""), sc("#abort-btn", 0)());
}
n.$le.render(r.$hg, r.$hk);
}, _o.prototype.$ov = function(e) {
return e * this.$i8;
}, _o.prototype.$ow = function(e) {
var t = new Float32Array(2);
return t[0] = e[0] * this.$i8, t[1] = e[1] * this.$i8, t;
}, _o.prototype.$ox = function(e, t) {
t[0] = e[0] * this.$i8, t[1] = e[1] * this.$i8;
}, _o.prototype.$oy = function(e) {
return this.$nl[Me(e, this.$ii[1])];
}, _o.prototype.$oz = function(e) {
return this.$nm[Me(e, this.$ii[1])];
}, _o.prototype.$p0 = function(e) {
return this.$ka * (1 + (this.$lt - 1) * (this.$oy(e) - this.$ie) / this.$ig);
}, _o.prototype.$p1 = function() {
return this.$jk === qt || this.$jk === Ht;
}, _o.prototype.$p2 = function(e) {
var t = this;
t.$p3(), t.$l7 ? cr ? t.$l8 % 2 == 0 && cr.postMessage([ Ke, --t.$l8 ]) : t.$km = setTimeout(ho, Ke) : (t.$kl = jn(ho), 
null === t.$o8 && window.postMessage(t.$o8 = e || 0, "*"));
}, _o.prototype.$p3 = function() {
var e = this;
e.$kl && (Un(e.$kl), e.$kl = 0), e.$km && (clearTimeout(e.$km), e.$km = 0), e.$o8 = null, 
e.$l8 += e.$l8 % 2;
}, _o.prototype.$p4 = function(e) {
var t = this, n = t.$k5, r = n.$cj + "/game/" + Fe + "/" + window.GEN_TMSP;
if (t.$nz.length = 0, sr) t.$n7 = Mo("console.log('ws worker started');var ws = null;onmessage = function(e) {\tvar data = e.data;\tif (typeof data === 'object' && data.constructor === ArrayBuffer) {\t\tif (ws && ws.readyState === WebSocket.OPEN) {\t\t\tws.send(data);\t\t}\t} else if (data[0] === 'open') {\t\tif (ws) { ws.close(); }\t\tws = new WebSocket(data[1]);\t\tws.binaryType = 'arraybuffer';\t\tws.onopen = function(e) { postMessage(['open', e.timeStamp]); };\t\tws.onmessage = function(e) { postMessage(e.data, [e.data]); };\t\tws.onclose = function(e) { postMessage(['close', e.timeStamp, e.code, e.reason]); };\t\tws.onerror = function(e) { postMessage(['error', e.timeStamp, e.data]); };\t} else if (data[0] === 'close') {\t\tif (ws) { ws.close.apply(ws, data.slice(1)); ws = null; }\t}};"), 
t.$n7.onmessage = function(e) {
var t = e.data;
"object" == typeof t && (t.constructor === ArrayBuffer ? lo(e) : "open" === t[0] ? Za() : "close" === t[0] ? to.apply(null, t.slice(2)) : "error" === t[0] && eo.apply(null, t.slice(2)));
}, t.$n7.postMessage([ "open", r ]); else {
var i = t.$cl = mr(r);
if (i.binaryType = "arraybuffer", i.onopen = Za, i.onclose = function(e) {
to(e.code, e.reason, i);
}, i.onerror = function(e) {
eo(e.data);
}, i.onmessage = lo, n.$cf < 75 && !Lc()) {
var a = GLOB[gn[16]](), o = n.$ci.split("/")[0];
a.last_ws != window.btoa(unescape(encodeURIComponent(o))) && (vr("memorizing ws: " + o), 
a.last_ws = window.btoa(unescape(encodeURIComponent(o))), GLOB[gn[17]](a));
}
}
t.$p2(), t.$mm = Ar(), e && (t.$mn = t.$mm);
for (var s = 0; s < t.$n2.length; t.$n2[s][0] = t.$n2[s][1] = 0, ++s) ;
ue.push("sc " + t.$jk + " " + (0 | Ar()) + " " + (0 | t.$l7));
}, _o.prototype.$p5 = function(e) {
for (var t = this, n = t.$n6.length; n < e; ++n) {
var r = mr(t.$cl.url);
r.binaryType = "arraybuffer", r.onopen = ro, r.onclose = ao, r.onerror = oo, r.onmessage = io, 
t.$n6.push(Array.of(r, !1));
}
}, _o.prototype.$p6 = function(e) {
var t = this;
return Ur(t.$j1[0], t.$j1[1], kr(zr(e, t.$ii[0], t.$ii[1]), 0, 1));
}, _o.prototype.$p7 = function(e) {
var t = this;
if (e != t.$kv) {
var n = e ? K.$bp : K.$bq, r = document.body, i = se("main-canvas");
On ? (n(r, "touchstart", rc, !e || {
passive: tr,
capture: !0
}), n(r, "touchmove", Ks, !e || {
passive: tr,
capture: !0
}), n(r, "touchend", ac, !e || {
passive: tr,
capture: !0
}), (e ? K.$bq : K.$bp)(document.body, "touchstart", ic, !!e || {
passive: tr,
capture: !0
}), e || (t.$kx = t.$ky = Number.MAX_VALUE)) : (n(r, "mousedown", rc, {
capture: !0
}), n(r, "mousemove", Ks, {
capture: !0
}), n(r, "mouseup", ac, {
capture: !0
}), n(i, "keydown", Us), n(i, "keyup", Bs)), e && (js = new Object()), t.$kv = e;
}
}, _o.prototype.$p8 = function(t, n) {
var r = this, i = r.$jk, a = i === qt;
if (!r.$mq) {
if (t === Kt) r.$qr(), setTimeout(hc.$c1, hc.$c3, !0), sc("#main-canvas,#lbrd,#gl-stats,#game-stats,#stats,#room-wait-info", "#footnote,#social,.ctrl-btn,#to-top-btn,#hint,#aux-canvas,#start,#info")(), 
$("#lbrd,#footnote,#social,.ctrl-btn,#start,#screen,#game-stats").css("opacity", ""), 
r.$gx(), i = Vt; else if (t === Qt) if (a) {
var o = 1e3, s = 1e3, c = r.$nn, l = function() {
$("#screen,#game-stats,.banner-area").stop(), setTimeout(hc.$c1, hc.$c3, !0), sc("#lbrd,#screen", "#hint")(), 
$("#lbrd,#footnote,#social,.ctrl-btn,#start,#screen").css("opacity", ""), yo(!0), 
sc(".banner-area", 0)();
}, u = function() {
r.$qr(), sc("#main-canvas,#game-stats,#stats,#lbrd,#room-wait-info", "#aux-canvas,#footnote,#social,.ctrl-btn,#to-top-btn,#start,#info,#clr-select-area")(), 
$("#game-stats,.banner-area,#lbrd,#stats").css("opacity", ""), $("#footnote,#social,.ctrl-btn,#start").css("opacity", 0).animate({
opacity: 1
}, s), $("#screen").animate({
opacity: 0
}, s, l), sc(".banner-area", 0)();
};
yo(!1), sc("#gl-stats,#hint,#aux-canvas,#room-wait-info", "#screen")(), $("#game-stats,.banner-area,#lbrd,#stats").css("opacity", 1).animate({
opacity: 0
}, o), $("#screen").css("opacity", 0).animate({
opacity: 1
}, o, u), $("#nick-input").focus(), r.$gx(), r.$oc = c, r.$qi(), i = Vt;
} else i === Wt && 2 === Jc.$oi && ie(); else if (t === va) 0 !== r.$oi || !a && i !== Xt ? de("/csri_" + i + "_" + r.$oi + "_" + r.$oj + "_" + (0 | Ar())) : (ue.push("csr2 " + (0 | Ar())), 
r.$gx(!0), sc("#main-canvas,#lbrd,#stats,#gl-stats", "#aux-canvas,#room-wait-info")(), 
Hr(se("room-wait-msg"), ""), r.$k6 = new vo(), r.$pv(Uint8Array.of(va)), r.$oi = 2, 
r.$oj = 0 | Ar(), i = Wt); else if (t === Zt && (a || i === Wt || i === Xt)) {
var h = n, d = !!r.$mk;
r.$gx(), !h || 4 == ++r.$jp || a && r.$l7 ? (r.$qr(), setTimeout(hc.$c1, hc.$c3, !0), 
sc("#main-canvas,#screen,#gl-stats,#lbrd,#game-stats,#stats,#room-wait-info", "#aux-canvas,#start,#hint,#footnote,#social,.ctrl-btn,#to-top-btn,#info,#clr-select-area")(), 
qn && Uc(), $("#nick-input").focus(), r.$jp = 0, r.$qi(), Ca = 0, i = Vt) : a || !d ? (a ? (sc("#main-canvas,#screen,#start,#hint,#footnote,#gl-stats,.ctrl-btn,#to-top-btn,#lbrd,#game-stats,#stats,#social,.banner-area,#room-wait-info,#clr-select-area", "#aux-canvas")(), 
r.$k6 = new vo(r.$k6 && r.$k6.$d4), hc.$c2(), r.$qt()) : ue.push("hsc1 " + (0 | Ar()) + " " + (0 | r.$mk) + " " + (0 | r.$ml)), 
r.$p4(), i = Xt) : (ue.push("hsc2 " + (0 | Ar()) + " " + d), r.$mo = d);
}
if (i === Vt) {
if (t === Yt) {
$(".banner-area,#game-stats *").stop();
var p = GLOB[gn[16]]();
p.last_nick = window.btoa(unescape(encodeURIComponent($("#nick-input")[0].value))), 
GLOB[gn[17]](p), sc("#screen,#start,#hint,#footnote,.banner-area,#social,.ctrl-btn,#to-top-btn,#info,#abort-btn", "#aux-canvas,#room-wait-info")(), 
Hr(se("room-wait-msg"), ""), $("#start-btn,#restart-btn,#main-menu-btn").trigger("mouseleave"), 
r.$k6 = new vo();
var f = function(e) {
sc("#err-msg", "#root")(), r.$k5 = e, zc(function() {
r.$p4(!0);
});
};
r.$k5 ? f(r.$k5) : function e(t, n) {
var r = new Object(), i = Lc(), a = GLOB[gn[16]](), o = !i && a.last_ws && decodeURIComponent(escape(window.atob(a.last_ws))) && "", s = (o && GAME_SERVERS.split(",").filter(function(e) {
return e.startsWith(o) && (vr("using memorized ws: " + e.split("|")[0]), !0);
}) || (vr("trying every ws"), function() {
var e = GAME_SERVERS.split(","), t = COUNTRY_CODE && COUNTRY_CODE !== Kn && Ac.find(function(e) {
return e[0].indexOf(COUNTRY_CODE) >= 0;
});
return t && e.filter(function(e) {
return t.find(function(t, n) {
return n && (e.startsWith(t) || e.startsWith("as4"));
});
}) || e;
}())).reduce(function(e, t) {
for (var n = t.split("|"), i = n[0].split(":"), a = 0, o = parseInt(n[1]); a < o; ++a) {
var s = new gr(i[0] + ":" + parseInt(i[1]) + "/" + a, parseInt(n[2]));
s.$ck in r ? ++r[s.$ck] : r[s.$ck] = 1, e.push(s);
}
return e;
}, new Array()), c = new Object(), l = s.length, u = !1, h = new Object(), d = 0, p = null, f = ++Ec;
function m(i) {
if (!(--h[i.$cj] < 0 || ((0 === h[i.$cj] || i.$cf >= 0) && (--d, h[i.$cj] = 0), 
c[i.$ck] ? ++c[i.$ck] : c[i.$ck] = 1, vr(i.$ci + "(#" + (Sc - h[i.$cj]) + ")" + (i.$cf < 0 ? ": Not available" : ": latency=" + i.$cf + "ms available=" + (i.$cg < 1)) + " force=" + i.$ch), 
Cc += (Cc.length > 0 ? "_" : "") + i.$ci.substr(0, 3) + "@" + (Sc - h[i.$cj]) + "@" + h[i.$cj] + "@nr" + c[i.$ck] + "@gs" + r[i.$ck] + "@_" + i.$cf + "_" + i.$cg, 
u || Zc().$mq || f < Ec || i.$cg >= 10))) {
if (i.$cf >= 0) if (p) {
var a = (i.$cg >= .8) + (i.$cg >= 1), o = (p.$cg >= .8) + (p.$cg >= 1);
function s(e, t) {
var n = e.indexOf(":"), r = t.indexOf(":");
return e.substr(0, n) < t.substr(0, r) || n === r && e.substr(0, n) == t.substr(0, n) && parseInt(e.substr(n + 1)) < parseInt(t.substr(r + 1));
}
(i.$ch || (i.$ck === p.$ck ? i.$cf < 75 ? a === o ? s(i.$ci, p.$ci) : a < o : s(i.$ci, p.$ci) && a < 2 : i.$cf < p.$cf && a < 2)) && (p.$ch || (p = i));
} else p = i;
0 === d || p && Object.keys(c).length >= 2 - (p.$cf < (On ? 100 : 75) && !Oa()[2] ? 1 : 0) && c[p.$ck] >= r[p.$ck] - (p.$ci.indexOf(":443") >= 0 ? 1 : 0) ? (u = !0, 
p ? (vr("Selected server: " + p.$ci), p.$cg < 1 ? t(p) : (Tc(null, gc), n && setTimeout(function() {
e(t, n);
}, n))) : (Tc(null, On ? gc : vc), n && setTimeout(function() {
e(t, n);
}, n))) : i.$cf < 0 && h[i.$cj] > 0 && setTimeout(function() {
u || f !== Ec || i.$cm(m);
}, Mc);
}
}
i && (i = decodeURIComponent(i[1]), (i = s.findIndex(function(e) {
return e.$ci.length === i.length ? e.$ci === i : e.$ci.startsWith(i + ".");
})) < 0 ? i = null : l = 1);
if (null != i) d = 1, h[s[i].$cj] = Sc, s[i].$cm(m); else {
d = l;
for (var g = 0; g < l; ++g) h[s[g].$cj] ? --d : (h[s[g].$cj] = Sc, s[g].$cm(m));
}
Cc = "st_" + d + "_" + Ar() + "_";
}(f, _c), hc.$c2(), r.$qt(), r.$p2(), window.aiptag && window.aiptag.gdprShowConsentToolButton && (window.aiptag.gdprShowConsentToolButton = !1), 
i = Wt;
}
} else if (i === Wt) if (t === Jt) {
var m = n;
r.$ps(m), i = qt;
} else 2 === t && de("/gsdl"); else if (a) {
if (2 === t) {
yo(!1), r.$lw = null, $("#lbrd").animate({
opacity: 0
}, 500, function() {
sc("#lbrd", 0)(), $("#lbrd").css("opacity", "");
}), ue.push("go " + (0 | Ar()));
var g = n[0], v = r.$pq(g);
v && ($("#congrats").html(v), $("#congrats > span").css("color", r.$hf.$bj)), Hr($("#final-score")[0], g), 
Hr($("#top-rank")[0], r.$lg == Number.MAX_SAFE_INTEGER ? r.$jq.$cq.size : r.$lg);
var y = .001 * n[5] | 0;
$("#time-alive").html((y >= 3600 ? String(y / 3600 | 0) + "h " : "") + (y >= 60 ? String(y % 3600 / 60 | 0) + "m " : "") + y % 60 + "s");
var b = $("#game-stats-inner, #game-stats-inner > *, #restart-btn, #main-menu-btn"), x = CLIENT.startsWith("app/") ? 200 : 1e3, w = CLIENT.startsWith("app/") ? 200 : 400;
b.css("opacity", 0);
for (var _ = 0, M = b.length; _ < M; ++_) setTimeout(function(e) {
var t = {
$gj: 1e3
};
e === M - 1 && (t.complete = function() {
b.css("opacity", "");
}, yo(!0)), b.eq(e).animate({
opacity: 1
}, t);
}, x + _ * w, _);
sc("#hint,#stats,#aux-canvas,#room-wait-info,#clr-select-area", "#game-stats,#main-canvas,#gl-stats")(), 
setTimeout(Uc, 1e3), r.$mr && (r.$ms = To(r.$mr), r.$gp.$gs(r.$mr), r.$k9.anim.$ap(r.$mr), 
r.$mr = null), r.$pj(Tr(), Me(2100, r.$my)), r.$mv = Ur(.5, 1, Dr(r.$jq.$cr.$dh.$ep)), 
r.$gp.$gr(r.$mx = r.$pm(Tr() + 2100, _e(0, r.$my - 2100), function(e) {
1 === e && (r.$mx = null);
}, 1)), r.$jq.$cx(r.$d2, !0), r.$q1(), r.$k7 && (r.$k7.visible = !1), i = Ht;
}
} else if (i === Ht) {
if (t === Yt) $(".banner-area,#game-stats *").stop(), sc("#hint,#start,#lbrd,#footnote,.banner-area,#social,#game-stats,.ctrl-btn,#to-top-btn,#main-canvas,#screen,#gl-stats,#info,#abort-btn,#clr-select-area", "#aux-canvas,#room-wait-info")(), 
Hr(se("room-wait-msg"), ""), $("#start-btn,#restart-btn,#main-menu-btn").trigger("mouseleave"), 
hc.$c2(), r.$qt(), r.$k6 = new vo(), r.$kk = -0, zc(function(e) {
e ? r.$p4(!0) : Io(r.$cl) && (ue.push("rp " + (0 | Ar())), r.$pv(Uint8Array.of(20)), 
r.$nz.length = 0);
}), i = Xt; else if (t === Zt) {
o = 1e3, s = 1e3;
var S = n;
u = function() {
var e = function() {
$("#screen,#game-stats,.banner-area").stop(), setTimeout(hc.$c1, hc.$c3, !0), sc("#lbrd,#screen", "#hint")(), 
$("#lbrd,#footnote,#social,.ctrl-btn,#start,#screen").css("opacity", ""), yo(!0), 
qn ? Uc() : S || sc(".banner-area", 0)();
};
r.$qr(), sc("#main-canvas,#game-stats,#room-wait-info", "#aux-canvas,#footnote,#social,.ctrl-btn,#to-top-btn,#start,#info,#clr-select-area")(), 
$("#game-stats,.banner-area").css("opacity", ""), S ? ($("#footnote,#social,.ctrl-btn,#start").css("opacity", 0).animate({
opacity: 1
}, s), $("#screen").animate({
opacity: 0
}, s, e), sc(".banner-area", 0)()) : e();
};
yo(!1), sc("#gl-stats", 0)(), S ? (sc(0, "#screen")(), $("#game-stats,.banner-area").css("opacity", 1).animate({
opacity: 0
}, o), $("#screen").css("opacity", 0).animate({
opacity: 1
}, o, u)) : u(!0), r.$gx(), r.$qi(), i = Vt;
}
} else if (i === Xt) {
if (t === Jt) {
var A = $("#screen"), T = parseInt(A.css("opacity"));
A.stop().animate({
opacity: 0
}, T / .8 * at, sc("#screen", 0));
m = n;
r.$ps(m), i = qt;
}
} else e(0);
i === qt && r.$jk !== qt ? (jc("sdkGameLoadingStop"), jc("gameplayStart")) : r.$jk === qt && i !== qt && jc("gameplayStop"), 
r.$jk = i, i === Vt && r.$p3();
}
}, _o.prototype.$p9 = function(e, t) {
var n = this;
return 1 === nn ? 0 : kr((t + n.$id) * n.$ns | 0, 0, nn - 1) * nn + kr((e + n.$id) * n.$ns | 0, 0, nn - 1);
}, _o.prototype.$pa = function() {
for (var e = this, t = e.$je, n = e.$p9(e.$lo[0], e.$lo[1]), r = e.$p9(e.$lo[2], e.$lo[3]), i = n % nn, a = r % nn, o = 0, s = n / nn | 0, c = 0; o < s; ++o) for (var l = 0; l < nn; ++l, 
++c) t[c] && (t[c].visible = !1);
for (s = r / nn | 0; o <= s; ++o) {
for (l = 0; l < i; ++l, ++c) t[c] && (t[c].visible = !1);
for (;l <= a; ++l, ++c) t[c] && (t[c].visible = !0);
for (;l < nn; ++l, ++c) t[c] && (t[c].visible = !1);
}
for (;o < nn; ++o) for (l = 0; l < nn; ++l, ++c) t[c] && (t[c].visible = !1);
}, _o.prototype.$pb = function() {
var e = this, t = e.$hk, n = t.position, r = e.$lo;
if (r[0] = e.$j4 * (t.left + n.x), r[1] = e.$j4 * (t.bottom + n.y), r[2] = e.$j4 * (t.right + n.x), 
r[3] = e.$j4 * (t.top + n.y), e.$pa(), e.$jl) {
for (var i = 1; i < 4; i += 2) for (var a = 0; a < 4; a += 2) if (Dr(r[a] * e.$i8) + Dr(r[i] * e.$i8) >= Dr(e.$i6)) return e.$jl.visible = !0, 
void (e.$lz.length > 1 && (e.$lz[1].visible = !0));
e.$lz.length > 1 && (e.$lz[1].visible = !1), e.$jl.visible = !1;
}
}, _o.prototype.$pc = function() {
var e = this;
Wr(e.$hk), e.$hk = new $3.OrthographicCamera(-1, 1, 1, -1, -2, 2), e.$hk.frustumCulled = !1, 
e.$hg.add(e.$hk), e.$j2 = Me(e.$p6(e.$ij), e.$j1[1] * ct), e.$j3 = 1, e.$ms = 1;
};
var So = 2 * cn;
_o.prototype.$pd = function(e) {
if (!(e < this.$m5)) {
var t = this, n = t.$pf();
0 !== t.$m5 && e > t.$m5 + 3e3 && (t.$m6 = null), null == t.$m6 && null == t.$m4 && (t.$m5 = 0), 
t.$m4 === n || null == t.$m4 && t.$m6 == n || !(0 === t.$m5 || e > t.$m5 + 3e3) || (t.$m5 = e, 
t.$m4 && (t.$m6 = t.$m4), t.$m4 = n);
for (var r = 0 === t.$m5 ? 1 : (e - t.$m5) / 500, i = Me(1, r), a = 0; a < 2; ++a) {
var o = 0 === a ? t.$m6 : t.$m4;
if (!(l = t.$m7[a])) {
var l, u = .5 * (1.6 - .85), h = Ne(1.225 * Be / (2 * u * 1.1)), d = (l = t.$m7[a] = G(1.6 * t.$ih * (t.$ie + t.$ig) >= t.$lb, null, 6 * h, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendSrcAlpha: $3.OneFactor
}, 4)).userData.$j9 = ii();
(v = Wn.$8n()).$aa = -1.225, v.$9w = u, v.$a9 = So, v.$a3 = 0, v.$a8 = .12 / u, 
v.$a5 = v.$a4 = 0;
for (var p = 0, f = -1 / h; p < h; ++p) {
v.$9w = u, v.$aa = -1.225, v.$a7 = p * f;
for (var m = 0; m < 3; ++m) d.push(l.$8e(v, new s(), c));
m = 1;
for (var g = -f / 6; m <= 5; ++m) v.$9w = u * Ur(.7, 1, Dr(2 * Pe(m / 6 - .5))), 
v.$aa = -(1.225 - (u - v.$9w)), v.$a7 = p * f + m * g, v.$a8 = .12 / v.$9w, d.push(l.$8e(v, new s(), c));
}
t.$ke.add(l);
}
if (!o || !o.$fi() || o.$dh.$e6 || 0 === a && 1 === i) l.visible = !1, t.$m8[a] = 0; else {
var v, y = Dr(0 === a ? i : 1 - i), $ = Ur(1, .625, y), b = .5 * (1 + Ae(o.$dh.$et * Be)), x = 1 + .5 * b;
t.$m8[a] = 1 - y, (v = Wn).$9z = $e((o.$dh.$ew << 8 | 176 * $) >>> 0, 4294967295, .2 * b * .5);
for (p = (d = l.userData.$j9).length - 1; p >= 0; --p) d[p].$8p(v, 2048), v.$9w = v.$9x * x, 
d[p].$8o(v, 1028);
l.scale.x = l.scale.y = o.$dh.$ei * t.$i8 * t.$ih * $, l.position.set(o.$dh.$e8[0] * t.$i8, o.$dh.$e8[1] * t.$i8, .1), 
l.visible = !0;
}
}
}
};
var Ao = 10;
_o.prototype.$pe = function(e, t, n, r) {
var i = this, a = i.$hf.$b0, o = .25, s = zr(Me(Ue, Pe(n - t)), 0, Ue), c = Ao * (r ? 1 : .8) * Ur(1, .6, Dr(s)), l = c / (Be * i.$i6) * i.$kc.length | 0, u = i.$i6 + i.$k2, h = Be / l, d = Wn, p = i.$kc.length * (t / Be - e * on / i.$kc[0].$8p(d, 128).$a9 % 1) - .5 * l | 0, f = c * Ur(.12, .08, s), m = r ? .7 : .5;
p %= i.$kc.length, p += (p < 0) * i.$kc.length;
var g = ii();
if (p + l > i.$kc.length ? g.push([ p, i.$kc.length ], [ 0, p + l - i.$kc.length ]) : g.push([ p, p + l ]), 
!i.$ll.some(function(e) {
return g.some(function(t) {
return e[1] > t[0] && e[0] < t[1];
});
})) {
i.$ll = i.$ll.concat(g);
var v = i.$pm(e, 800, function(e) {
for (var t = 1 == e ? 0 : Ae(Ur(o, 1, e) * Re), n = f * Oe(-4 * e) * .5 * (1 - Se(50 * e)), r = i.$kc, s = r.length, c = 0, v = p; c < l; ++c, 
++v, v *= v < s) {
var y = .5 * (1 - Se(c * h));
d.$aa = u + n * y, d.$9z = $e(a[0], a[1], (1 - (1 - t) * (1 - t)) * y) << 8 | 255, 
d.$9w = i.$k2 * (1 + m * t * y), r[v].$8o(d, 1540);
}
if (1 === e) {
var $ = i.$kd.indexOf(this);
i.$kd.splice($, 1), i.$gp.$gs(this), i.$k9.anim.$ap(this), i.$ll = i.$ll.filter(function(e) {
return g.indexOf(e) < 0;
});
}
}, 1);
i.$kd.push(v), i.$gp.$gr(v);
}
}, _o.prototype.$pf = function() {
for (var e = this, t = 0; t < e.$nw.length; ) {
var n;
if (n = e.$jq.$cv(e.$nw[t][0])) return n;
++t;
}
return null;
};
function To(e) {
return Ur(rt, 1, 1 - Nr(1 - e.$gl * e.$gm));
}
function Lo(e, t) {
e && !e.$86 && (e.$87.uniforms.w2p.value = t);
}
_o.prototype.$pg = function(e) {
var t = this, n = t.$jq.$cr;
if (n && n.$d8[1] <= e) {
var r = n.$d8, i = n.$fr(e, !0), a = r[i + 5] << 2;
t.$l9[0] = t.$i8 * (r[i + 3] + (e - r[i + 1]) * t.$lp[a + 2]), t.$l9[1] = t.$i8 * (r[i + 4] + (e - r[i + 1]) * t.$lp[a + 3]);
}
t.$hk.position.set(t.$l9[0], t.$l9[1], 0), t.$pb();
};
var Co = new $3.Vector2();
_o.prototype.$ph = function(e) {
var t, n, r = this, i = (r.$hl.getSize(Co), Co.x), a = i / Co.y, o = this.$hk, s = r.$mr ? r.$mr.$gl * r.$mr.$gm : 1, c = r.$mu ? r.$mu.$gl * r.$mu.$gm : 1, l = r.$mx ? r.$mx.$gl * r.$mx.$gm : 1, u = (r.$mr ? To(r.$mr) : 1) * r.$ms * Ur(1, 1.25, r.$mt) * (r.$mx ? Ur(1, _e(1, 1.4 / r.$ms), r.$mx.$gl * r.$mx.$gm) : 1) * (1 === c ? 1 : 1 - .35 * r.$mv * zr(Oe(-3 * ke(c, 1)), Oe(-3), 1) * .5 * (1 - Se((1 - ke(1 - c, 1.5)) * Be * 15))), h = .5 * Me(r.$j2 * u, r.$j1[1] * ct);
r.$j3 = 2 * h / r.$j2, a > 1 ? t = (n = a > 16 / 9 ? h / .5625 * (1 / a) : h) * a : n = (t = a < .5625 ? h / .5625 * a : h) / a;
var d = 1 / (2 * t), p = i * d * Oo((r.$k0 || GLOB[gn[16]]()).graph_qual || 0);
o.left = -t, o.right = t, o.top = n, o.bottom = -n, o.updateProjectionMatrix(), 
r.$pb();
for (var f = r.$je, m = 0; m < f.length; ++m) Lo(f[m], p);
Lo(r.$jg, p), Lo(r.$jf, p), Lo(r.$jl, p), Lo(r.$n8, p);
var g = 2 * Me(t, n), v = .1 * g;
e && r.$k7 && (Wr(r.$k7), r.$k7 = null), r.$kr || (r.$k7 ? r.$k7.$gx(v, t - (v + .02 * g), -n + v + .02 * g) : (r.$hk.add(r.$k7 = new bo(r, v, t - (v + .02 * g), -n + v + .02 * g)), 
r.$k7.position.z = gt - r.$hk.position.z), r.$k7.$hq.$87.uniforms.w2p && (r.$k7.$hq.$87.uniforms.w2p.value = i * d)), 
r.$k4 && r.$k4.$r6(o);
var y = c / .2, $ = r.overlay_mesh.material, b = r.$jq.$cr;
r.$k0 && r.$k0.show_flashes && c < 1 && y < 1 && (!b || 0 !== b.$dh.$f7) ? (c = zr(Oe(-3 * ke(y, 1)), Oe(-3), 1) * Se(3.75 * y * Be)) > 0 ? ($.color = Hn, 
$.opacity = (b ? Ur(b.$dh.$f7, .4, .6) : .8) * (1 - Dr(1 - c))) : ($.color = Xn, 
$.opacity = (b ? Ur(b.$dh.$f7, .6, .8) : 1) * (1 - Nr(1 + c))) : s < 1 ? ($.color = Xn, 
$.opacity = .8 * Nr(1 - Me(1, s / ot))) : l < 1 ? ($.color = Xn, $.opacity = .8 * l) : $.opacity = 0;
r.overlay_mesh.visible = $.opacity > 0, Qo(Jc.$o9, Cs);
};
var Eo = 2500, Po = 1 / Eo;
function ko(e) {
return e * e * .5;
}
function Oo(e) {
return _e(1, Ur(1, window.devicePixelRatio, 0 === e ? window.devicePixelRatio <= 2 ? 0 : .2 : .5));
}
function Do(e, t) {
var n = e, r = -t - (e >> 1);
return Int32Array.of(n, -(n + r), r);
}
_o.prototype.$pi = function(e) {
var t, n = this, r = n.$jq.$cr, i = n.$mt;
if (r) {
var a = n.$p6(r.$d5[6]);
if (n.$j2 !== a) {
var o = e - n.$ki, s = a - n.$j2;
n.$j2 = (s > 0 ? Me : _e)(n.$j2 * (1 + je(s) * o / 1e4), a), t = !0;
}
for (var c = r.$d8, l = r.$fr(e, !0), u = 0, h = _e(c[1], e - Eo), d = ko((e - h) * Po), p = e, f = ko(1) - d; l >= 0 && p >= h; ) {
var m = ko(((p = _e(h, c[l + 1])) - h) * Po);
u += p > r.$di + n.$m3 && c[l + 5] & ar ? d - m : 0, f += d - m, d = m, l -= 9;
}
n.$mt = 0 === f ? 0 : u / f;
}
(t || n.$mr || n.$mu || n.$mx || i !== n.$mt) && n.$ph(), n.$ki = e;
}, _o.prototype.$pj = function(e, t) {
var n = this;
n.$mu && (n.$gp.$gs(n.$mu), n.$k9.anim.$ap(n.$mu)), n.$gp.$gr(n.$mu = n.$pm(e, t, function(e) {
1 === e && (n.$mu = null);
}, 1));
}, _o.prototype.$pk = function() {
var e = this, t = e.$jq.$cr;
if (On && 1 === e.$k0.controls) {
if (t && e.$k4) {
var n = e.$k4.$r3;
if (n > 0) {
for (var r = Wn.$8n(), i = r.$9v = zn, a = Ur(Ur(.6, 1, Me(1, e.$k4.$r4)), 1.7, n < 1 ? 0 : Dr(n - 1)), o = zr(a, .6, 1.7), l = a * Me(e.$hk.right, e.$hk.top) * (Nn ? .4 : .27), u = Re * Ur(.6, .5, Dr(o)); e.$na < 22; ) e.$na === e.$n9.length && e.$n9.push(new s()), 
e.$n8.$8e(r, e.$n9[e.$na++], c);
r.$9z = t.$dh.$ew << 8 | (n < 1 ? Ur(128, 255, n) : Ur(255, 64, Dr(n - 1))), r.$a3 = r.$a9 = r.$a5 = r.$a4 = 0;
for (var h = n <= 1 ? 1 : Ur(1, 1.2, n - 1), d = 2 * Me(e.$hk.right, e.$hk.top) / Me(window.screen.width, window.screen.height) * Rn * h * (1 + .15 * t.$dh.$ep - .2 * (1 - Me(1, e.$k4.$r4))), p = -1, f = 0; p <= 1; p += 2) for (var m = 0; m < 11; ++m) {
var g = .5 + m, v = .5 * g * d;
i[0] = e.$hk.position.x + l * Se(e.$k4.$pt) - v * Se(e.$k4.$pt + p * u * .5), i[1] = e.$hk.position.y + l * Ae(e.$k4.$pt) - v * Ae(e.$k4.$pt + p * u * .5), 
i[2] = 0, r.$a8 = (m < 10 ? .4 : .3) / h, r.$9w = Ur(1, .7, g / 11) * d, e.$n9[f++].$8o(r, 13796);
}
return;
}
}
for (m = 0; m < e.$na; ++m) e.$n9[m].$8q();
e.$na = 0;
}
}, _o.prototype.$pl = function(e) {
var t = this, n = e * on;
t.$jg.$8h(), nt && t.$jh.$8h();
for (var r = t.$je.length - 1; r >= 0; --r) t.$je[r] && (t.$je[r].$8b(n), t.$je[r].$8h());
t.$jf.$8b(n), t.$jl && t.$jl.$8b(n), t.$n8 && t.$n8.$8b(n);
for (r = 0; r < t.$m7.length; ++r) t.$m7[r] && t.$m7[r].$8b(n);
t.$k7 && t.$k7.$hq.$8b(n);
}, _o.prototype.$pm = function() {
var e = this.$k9.anim.$ar();
return e.$go.apply(e, arguments);
}, _o.prototype.$pn = function() {
var e = this, t = e.$hk, n = (e.$hl.getSize(Co), Co.x / ((t.right - t.left) / e.$j3));
e.$k3 = 96 / 2.54 * .07 / (e.$if * n), e.$lm = _e(2, De(2 * e.$it / e.$ie)), e.$ln = Ne(e.$lm * e.$ig / e.$ie), 
si.prototype.$dt = new e.$lc(2 * Ne(e.$lv * (e.$lm + e.$ln))), function(e) {
if (e |= 0, !Ve || e > Ve.length + 1) {
Ve = new Float64Array(e + 1);
for (var t = 1; t <= e; Ve[t] = 1 / t, ++t) ;
}
}(si.prototype.$dt.length >>> 1), e.$m0 = new Float32Array(6);
for (var r = [ 0, .4, 1 ], i = 0; i < 3; ++i) e.$m0[i << 1] = Ur(1, e.$lu, r[i]), 
e.$m0[1 + (i << 1)] = 0 === i ? 1.2 : (2 === i ? 1 : e.$m0[1]) / e.$m0[i << 1];
var a = e.$no[e.$im] + 1, o = Ne((a + e.$lv - 1) * (3 + 5 * (2 * (e.$lm + e.$ln) + 1) + 1)), s = !e.$nc || e.$nc.byteLength !== o << 2;
if (s && (e.$nc = new ArrayBuffer(o << 2)), s || !e.$nb || e.$nb.length !== a) {
for (var c = e.$nb = new Array(a), l = e.$nc, u = 0, h = e.$lm + e.$ln; u < a; ++u) {
var d, p = ii(), f = 1 + 5 * (u > 1 ? h : 0 === u ? 1 : 0 | Ne(h * e.$lv)), m = 0 === u ? 0 : c[u - 1][3].byteOffset + c[u - 1][3].byteLength;
p.push(d = new Float32Array(l, m, f)), d.dv = new DataView(d.buffer, m, d.byteLength), 
m += d.byteLength, p.push(d = new Float32Array(l, m, f)), d.dv = new DataView(d.buffer, m, d.byteLength), 
m += d.byteLength, p.push(d = new Float32Array(l, m, 6)), d.dv = new DataView(d.buffer, m, d.byteLength), 
m += d.byteLength, p.push(d = new Float32Array(l, m, 1)), d.dv = new DataView(d.buffer, m, d.byteLength), 
c[u] = p;
}
e.$nd = new Uint8Array(a);
}
}, _o.prototype.$po = function() {
var e = this, t = window.innerWidth, n = window.innerHeight, r = Oo(GLOB[gn[16]]().graph_qual), i = se("main-canvas");
e.$hl.setSize(t, n, !0), e.$hl.setPixelRatio(r), e.$k8 = i.getBoundingClientRect(), 
e.$ph();
}, _o.prototype.$pp = function() {
var t = this, n = Wn.$8n(), r = t.$k2 = 1.7 * t.$ov(t.$h2), i = t.$k3 * t.$if / r, a = Ne(Be * t.$i6 / r * 1.5), o = Be / a, l = 4 * r >= t.$lb, u = G(l, null, a, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendEquation: $3.AddEquation,
blendEquationAlpha: $3.MaxEquation
}, 3, 1, k & ~P);
n.$9v = oi, n.$9z = n.$a0 = Ii(t.$hf.$b0[0]), n.$aa = t.$i6 + t.$k2, n.$9w = n.$9x = r, 
n.$a8 = i, n.$a9 = Be * n.$aa / 1e-6 * cn, n.$a3 = 0, n.$a5 = 0, Wr(t.$jl), t.$jl = u, 
u.position.z = .2, t.$ke.add(u), t.$kc && t.$kc.length === a || (t.$kc = ii());
for (var h = 0, d = 0; d < a; h += o) n.$a7 = -h * ze, t.$kc.push(u.$8e(n, t.$kc[d] || new s(), c)), 
++d;
t.$kd.forEach(function(e) {
e.$ct(e.$d4 + e.$gj);
}), e(0 === t.$kd.length);
}, _o.prototype.$pq = function(e) {
var t = this, n = "Game over...";
if (t.$l5) for (var r = t.$l5.lbrd, i = t.$l5.size, a = t.$l5.size, o = 0, s = r.length; o < s; ++o) {
var c = r[o][1], l = c.findIndex(function(t) {
return t[1] < e;
}), u = (l >= 0 ? l : c.length) + 1;
u < a && (c.splice(l >= 0 ? l : c.length, 0, [ $("#nick-input")[0].value, e ]), 
!0), u < a && l <= i && (n = "Well played!<br><span>#" + u + "</span> " + r[o][0].toLowerCase() + " best result!", 
i = u);
}
return n;
};
var No = 0;
function Io(e) {
return e && e.readyState === WebSocket.OPEN;
}
_o.prototype.$pr = function() {
var e = this, t = 4, n = .55 * e.$ov(e.$h2), r = 2 * Me(window.screen.height, window.screen.width) * window.devicePixelRatio / e.$j1[0] * n, i = qr({
antialias: !1,
alpha: !0,
depth: !1,
stencil: !1
}), a = 1 << De(Me(Ee(i.capabilities.maxTextureSize), Ee(r * Ye * t * 12) - .5)), o = wo(a, a, "wegbl"), l = (i = qr({
canvas: o,
antialias: !1,
alpha: !0,
depth: !1,
stencil: !1
}), new $3.WebGLRenderTarget(a, a, {
depthBuffer: !1,
stencilBuffer: !1,
format: $3.RGBAFormat
})), u = new $3.OrthographicCamera(0, 18 * t, 1.5 * Ye * 12 * t, 0, -1, 1), h = {
blendSrc: $3.SrcAlphaFactor,
blendSrcAlpha: $3.OneFactor,
blendDst: $3.OneMinusSrcAlphaFactor
}, d = G(!0, null, 100, 1, 0, an, h), p = zn, f = Wn.$8n(), m = 18 * t, g = 12 * t, v = new Uint8Array(m * g);
No = -Br(1, 1.1) * Re / 12, f.$9z = Ii(e.$hf.$ay[3]), f.$9v = p, f.$a8 = .2;
for (var y = 0; y < v.length; ++y) v[y] = 0 | Br(ln[0], ln[1]);
p[2] = 0;
for (var $, b, x = new Array(), w = new Array(), _ = (y = 0, 0); y <= g; y += 12, 
++_) for (var M = 18 * (1 & _); M <= m; M += 36) x.push(Do(y, M));
for (y = 0; y <= g; ++y) for (M = 0; M <= m; ++M) {
p[0] = 1.5 * y, p[1] = Ye * (M - .5 * (1 & y));
for (var S = x.length - 1; S >= 0 && 12 !== ($ = Do(y, M), b = x[S], _e(Pe($[0] - b[0]), Pe($[1] - b[1]), Pe($[2] - b[2]))); --S) ;
var A = v[y % g * m + M % m];
f.$9z = f.$9z >>> 8 << 8 | (S >= 0 ? 160 : A), f.$9w = S >= 0 ? un[1] : Br(.7, 1) * un[0], 
f.$a8 = hn[S >= 0 ? 1 : 0], w.push(d.$8e(f, new s(), c)), 0;
}
e.$lz.map(Wr), e.$lz = ii(), i.setSize(o.width = l.width, o.height = l.height);
y = 0;
for (var T = [ e.$i6 + e.$k2, He * (e.$i6 + e.$j1[1] * (16 / 9) * 1.4 * .5) ], L = [ Ne(Re / Le(2 * e.$k2 / T[0])), 4 ]; y < 2; ++y) {
if (0 === y) i.setClearColor(e.$hf.$ay[2], 1); else {
i.setClearColor($e(e.$hf.$ay[2], 0, .33), 1);
var C = Wn;
for (M = 0; M < w.length; ++M) w[M].$8p(C, 1), C.$a1 *= 1 - .33, w[M].$8o(C, 1);
}
var E = new Uint8Array(l.width * l.height * 4), P = new $3.DataTexture(E, l.width, l.width, $3.RGBAFormat, $3.UnsignedByteType, $3.UVMapping, $3.RepeatWrapping, $3.RepeatWrapping, $3.LinearFilter, $3.LinearMipMapLinearFilter, 1);
P.generateMipmaps = !0, P.repeat.set(2 * T[y] / (n * u.right), 2 * T[y] / (n * u.top)), 
P.offset.set(-.5 * P.repeat.x % 1, -.5 * P.repeat.y % 1), i.clear(), i.setRenderTarget(l), 
i.render(d, u), i.readRenderTargetPixels(l, 0, 0, l.width, l.height, E), P.needsUpdate = !0;
var k = {
map: P,
transparent: !0,
blending: $3.CustomBlending,
blendSrc: $3.SrcAlphaFactor,
blendSrcAlpha: $3.OneFactor,
blendDst: $3.ZeroFactor
}, O = new $3.Mesh(new $3.CircleBufferGmtr(T[y], L[y]), new $3.MeshBasicMtrl(k));
O.position.set(0, 0, .1 + .001 * (-y - 1)), O.renderOrder = 0, O.quaternion.setFromAxisAngle(Je, No), 
e.$lz.push(O), e.$hg.add(O), d.$87.setValues(h);
}
t = 1, i = qr({
canvas: o = wo(a = 1 << Me(De(Ee(i.capabilities.maxTextureSize)), Ne(Ee(r * Ye * t * 12))), a, "wegbl"),
antialias: !1,
alpha: !0,
depth: !1,
stencil: !1
}), l = new $3.WebGLRenderTarget(a, a, {
depthBuffer: !1,
stencilBuffer: !1,
format: $3.RGBAFormat
}), u = new $3.OrthographicCamera(0, 18 * t, 1.5 * Ye * 12 * t, 0, -1, 1), E = new Uint8Array(l.width * l.height * 4), 
e.$nv = P = new $3.DataTexture(E, l.width, l.width, $3.RGBAFormat, $3.UnsignedByteType, $3.UVMapping, $3.RepeatWrapping, $3.RepeatWrapping, $3.LinearFilter, $3.LinearFilter, 1), 
P.generateMipmaps = !0, P.repeat.set(n * u.right, n * u.top), P.offset.set(0, 0), 
(f = C).$8n(), f.$9w = f.$9x = .75 * un[0], f.$a8 = .5, f.$9z = e.$hf.$az << 8 | 192;
for (M = 0; M < w.length; ++M) w[M].$8o(f, 3140);
i.setClearColor(e.$hf.$ay[2], 1), i.clear(), i.setRenderTarget(l), i.render(d, u), 
i.readRenderTargetPixels(l, 0, 0, l.width, l.height, E), P.needsUpdate = !0;
}, _o.prototype.$ps = function(t) {
var n = this, r = n.$jq.$cr, i = n.$k0, a = $("#nick-input")[0].value;
$("*").stop(), $(".topscores-table").remove(), Uo = 0, i.last_nick = window.btoa(unescape(encodeURIComponent(a))), 
ue.push("sg " + (0 | Ar()) + " " + (0 | n.$l7)), n.$jp = 0, n.$lg = Number.MAX_SAFE_INTEGER, 
e(r && r.$d5), n.$mf = n.$mg = n.$mh = n.$nk = -0, n.$k1 = Number.MIN_SAFE_INTEGER, 
n.$kb = ri(a) !== a, n.$jt = r.$di - n.$jn, n.$kq = !i.show_nicks, n.$kr = !i.show_map, 
n.$mw = n.$ov(n.$oy(r.$d5[6])), n.$qk(r), n.$jq.$cs = Array.of(r.$di + n.$m3 - 1, r.$di + n.$m3), 
hs._cnt = hs._cnt2 = hs._tries = 0;
for (var o = [ n.$mr, n.$mx, n.$mu ], s = 0; s < 3; ++s) o[s] && (n.$gp.$gs(o[s]), 
n.$k9.anim.$ap(o[s]));
n.$mr = n.$mu = n.$mx = null, n.$kk = n.$dk = n.$dl = -0, n.$ms = 1, n.$mt = -0, 
n.$ni && (clearTimeout(n.$ni), n.$ni = 0), n.$ml = -0, n.$nz.length = 0, n.$pg(r.$d4), 
n.$j2 = n.$p6(n.$ij), n.$ki = r.$d4, n.$ph(!0), n.$hl.setClearColor(n.$hf.$ax[0], 1), 
n.$lw = null, On && (Js.prototype.$pt = Math.atan2(n.$kg[1], n.$kg[0])), n.$mz = !!i.low_fps, 
ee.$8n(1e3 / Ze), GLOB[gn[3]](), n.$oc = null, si.prototype.$fj.clear(), n.$p5(hr), 
n.$oq = 4294967295, vr("start_game: low fps = " + i.low_fps);
}, _o.prototype.$pu = function(e) {
if (Io(this.$cl)) for (var t = 0; t < e; ++t) this.$cl.send(xa);
}, _o.prototype.$pv = function(e, t) {
var n = this, r = null;
if (e.constructor === Uint8Array.prototype.constructor && (e = (r = e).buffer), 
sr) n.$n7 && (e = e.slice(), n.$n7.postMessage(e, [ e ])); else if (t && n.$n6.length && e.byteLength < 256 && n.$jk === qt && n.$jq.$cr) {
n.$oo = n.$oo + 1 >>> 0;
var i = n.$oo <= 63 ? 1 : n.$oo <= 16383 ? 2 : n.$oo <= 4194303 ? 3 : 4, a = 2 + i + e.byteLength, o = (jo[a] || (jo[a] = function(e) {
var t = new ArrayBuffer(e);
return Array.of(new Uint8Array(t), new DataView(t));
}(a)))[0];
jo[a][1];
o[0] = 126, o[It] = i - 1 << 6 | 63 & n.$oo;
for (var s = 1; s < i; ++s) o[It + s] = n.$oo >>> 8 * s - 2;
o[It + i] = e.byteLength, r = r || new Uint8Array(e);
s = 0;
for (var c = It + i + 1; s < r.length; ++s, ++c) o[c] = r[s];
Io(n.$cl) && n.$cl.send(o.buffer), o[0] = 127;
for (s = 0; s < n.$n6.length; ++s) Io(n.$n6[s][0]) && n.$n6[s][0].send(o.buffer);
} else Io(n.$cl) && n.$cl.send(e);
}, _o.prototype.$pw = function(e, t, n) {
for (var r = this.$jx, i = r.length; i > 0 && r[i - 1][0] > e; ) --i;
r.splice(i, 0, [ e, t, n ]);
}, _o.prototype.$px = function(e, t) {
this.$pw(e, Uint8Array.of(44 + (t >> 8), 255 & t), [ 4, e + this.$jn, t ]), hs._cnt2 = 0;
}, _o.prototype.$py = function(e) {
for (var t = this.$jx; t.length && t[0][0] < e; ) t.shift();
}, _o.prototype.$pz = function() {
var e = this, t = e.$qc("#stats-ping");
if (t.length) {
(i = Me(e.$ny, e.$nx.length)) === e.$nx.length ? e.$nx.sort(Ra) : e.$nx = e.$nx.slice(0, i).sort(Ra).concat(e.$nx.slice(i)), 
zn[0] = zn[1] = 0;
for (var n = .1 * i | 0, r = n, i = i - r; r < i; zn[0] += e.$nx[r][0], zn[1] += e.$nx[r][1], 
++r) ;
Hr(t[0], e.$ju[0] + "~" + e.$ju[1] + (e.$ny < 100 ? "" : "/" + (zn[0] / (i - n) | 0) + "/" + (zn[1] / (i - n) | 0)) + (e.$o0 ? " (@" + (e.$nn === fr(Oa()[2]) ? Oa()[2] : e.$nn) + ")" : ""));
}
};
var Ro = ii(), jo = ii(), Uo = 0;
_o.prototype.$q0 = function(t) {
var n, r, i = this, a = i.$q4(i.$kp), o = a >= 0 ? i.$kn[a + 1] + i.$jn : Math.MAX_SAFE_INTEGER, s = i.$o1, c = i.$jx, l = Lr(_e(Ne(Me(Tr(), t - 1e3 / Ze)), i.$jq.$cs[0], i.$jq.$cs[1])), u = t - i.$nk > i.$o2, h = i.$jq.$cr;
if (t <= o) te.$am(i.$l7, i.$kp, t, i.$nk, o, i.$n0, 0, 0, 0); else {
if (c.length && c[0][0] < l) {
for (var d = l - c[0][0], p = i.$jq.$cs, f = 0; f < c.length; ++f) {
(k = c[f])[0] += d, k[2][1] += d, k[2][0] === xt ? p[0] = _e(p[0] + d, p[1] + 1) : k[2][0] === wt ? p[1] = _e(p[1] + d, p[0] + 1) : 4 === k[2][0] && (i.$kg[2] = _e(i.$kg[2], k[0]));
}
l = _e(l, Lr(_e(p[0], p[1])));
}
var m = Or(i.$kh);
if (m[3] < 2) {
for (var g = h.$d8, v = 0, y = 6; y < h.$da; v = _e(v, g[y]), y += 9) ;
var $ = h.$fr(o, !0), b = i.$jq.$cs[0] > i.$jq.$cs[1] && t - h.$d4 > i.$m3 + i.$jn && t >= i.$jq.$cs[0] && h.$dh.$ef > i.$ik, x = _e(l, Lr(i.$kg[2] + (b ? i.$jb : i.$ja))), w = i.$p0(v) * Ur(1, .6 + .3 * (h.$dh.$ei - i.$ie) / i.$ig, h.$dh.$ex);
for (e($ === h.$fr(o, !1)); x < t; ) {
var _ = Ce(m[1], m[0]), M = Ce(i.$kg[1], i.$kg[0]), S = _ - M;
if (Pe(S) > Re && (S -= Be * je(S)), Pe(S) <= w) {
var A = i.$qj(_);
m[0] = s[A << 1], m[1] = s[1 + (A << 1)], n = i.$kg, r = m, (n[0] !== r[0] || n[1] !== r[1]) && (i.$px(x, A), 
i.$kg = m.slice()), i.$kg[2] = x, m[3] = 2;
break;
}
var T = M + je(S) * w;
A = i.$qj(T);
i.$kg[0] !== s[A << 1] || i.$kg[1] !== s[1 + (A << 1)] ? (i.$px(x, A), i.$kg = Float64Array.of(s[A << 1], s[1 + (A << 1)], x), 
m[3] = 1) : i.$kg[2] = x, x += b ? i.$jb : i.$ja;
}
}
}
var L = new DataView(i.$jw.buffer), C = It + 2 * Pt;
if (u) {
if (c.length > 0) {
f = 0;
var E = c.length, P = i.$jy;
P.$gx();
for (f = 0; f < E; ++f) {
var k;
if ((k = c[f])[2][1] < h.$dh.$es - i.$jn + i.$o2 && de("/fc1_" + k[2][0] + "_" + k[2][1] + "_" + h.$dh.$es), 
k[0] < i.$jt && de("/fc2_" + k[2][0] + "_" + k[0] + "_" + i.$jt), h.$ft.apply(h, k[2])) {
var O = 0;
if (k[1][0] >= 44 && k[1][0] < 60) {
for ($ = h.$da - 9, g = h.$d8; $ >= 0 && 4 !== g[$]; ) $ -= 9;
O = $ < 0 ? 0 : k[0] + i.$jn - g[$ + 1] === i.$ja ? 1 : k[0] + i.$jn - g[$ + 1] === i.$jb ? 2 : 0;
}
if (O > 0) var D = k[1][k[1].length - 1], N = Uint8Array.of(k[1][0] + (O << 4), D), I = C + N.length; else {
var R = P.$gv(k[0]);
I = C + k[1].length + R[0] + R[1];
}
if (i.$jw.length < I) (U = new Uint8Array(I)).set(i.$jw, 0), L = new DataView((i.$jw = U).buffer);
O > 0 ? (i.$jw.set(N, C), C += N.length) : (R[1] && (i.$jw[C++] = ba[R[0]]), i.$jw[C++] = k[1][0], 
C += P.$gw(L, C, k[0]), i.$jw.set(k[1].subarray(1), C), C += k[1].length - 1);
}
}
f > 0 && (i.$jt = c[f - 1][0]);
for (var j = 0; j < f; ++j, c.shift()) ;
}
if (te.$am(i.$l7, i.$kp, t, i.$nk, o, l, i.$n0, u ? 1 : 0), Xi(L, It, o - i.$jn), 
Xi(L, It + Pt, Uo = 0 | _e(Tr(), Uo)), Ca) {
var U;
if (i.$jw.length < C + Aa.byteLength) (U = new Uint8Array(C + Aa.byteLength)).set(i.$jw, 0), 
L = new DataView((i.$jw = U).buffer);
Xi(Ta, It + Pt, qi(Ta, It) + Ar() - Ca), i.$jw.set(La, C), C += Aa.byteLength, Ca = 0;
}
var B = Ro[C];
B || (B = Ro[C] = ii());
var z = B[i.$js % 128];
if (z) for (f = 0; f < C; z[f] = i.$jw[f], ++f) ; else z = B[i.$js % 128] = i.$jw.slice(0, C);
i.$pv(z, t < i.$oq), i.$os && (i.$l7 || i.$pv(xa), i.$os = 0), t - h.$di > 1e3 && hs._cnt > 0 && hs._cnt === hs._cnt2 && hs._tries > 10 && hs._report && Or(i.$kh)[3], 
++hs._tries, i.$nk = 0 | t;
}
}, _o.prototype.$q1 = function() {
var e = this;
e.$jt = -0, e.$oo = 0, e.$jx = ii(), e.$jy = new wa(), e.$oi = 0, e.$oj = -0, Ca = 0, 
e.$k4 && (e.$k4.$ra(), e.$k4 = null, e.$pk()), e.$p7(!1), ue.push("odc " + (0 | Ar()));
}, _o.prototype.$q2 = function() {
var e = new ArrayBuffer(It + 4), t = new DataView(e);
return t.setUint8(0, 114), t.setUint32(It, this.$or, Qe), e;
};
var Bo = Ze;
_o.prototype.$gx = function(e) {
var t = this;
t.$q1(), e || (t.$ju = new Float64Array(2), t.$jv = null, t.$n0 = t.$n1 = t.$n5 = t.$n3 = t.$n4 = -0, 
t.$n3 = t.$n4 = Ia(), t.$cl && (t.$cl.onopen = t.$cl.onerror = t.$cl.onmessage = ne, 
t.$cl.onclose = no, t.$cl.readyState !== WebSocket.CLOSED && t.$cl.readyState !== WebSocket.CLOSING && t.$cl.close(), 
t.$cl = null, t.$n6.forEach(function(e) {
e[0].onclose = ne, e[0].close();
}), t.$n6.length = 0, t.$mm = t.$mn = -0, t.$ol = Number.MIN_VALUE), t.$q3(), ue.push("cc " + (0 | Ar()))), 
t.$d2 = 0, t.$jq.clear(), t.$nu = ii(), t.$jm = new Map(), t.$nt = ii(), t.$of = new Map(), 
t.$nw = ii(), t.$jr.clear(), t.$gp = new zi(), t.$m1 = new Map(), t.$m2 = 0, t.$hg = new $3.Scene(), 
t.$ke = t.$hg, t.$jl = t.$kc = null, t.$lz = ii(), t.$kd = ii(), t.$ll = ii(), t.$m7 = new Array(2), 
t.$m8 = Float32Array.of(0, 0), t.$m5 = -0, t.$m4 = t.$m6 = null, si.prototype.$fj.clear(), 
t.$o9 = new Map();
for (var n = 0; n < t.$md.length; ++n) t.$ke.add(t.$md[n][0]), t.$md[n][0].visible = t.$md[n][1] = !1;
(t.$jw = new Uint8Array(1024))[0] = 15, t.$os = 0, t.$nz = ii(), t.$oc = null, t.$kn = new Array(), 
t.$ko = t.$kp = -1, t.$mi = [ new Float64Array(Bo), new Float64Array(Bo) ], t.$mi[0].fill(1e3 / Ze), 
t.$mi[1].fill(1e3 / Ze), t.$mj = Uint32Array.of(1, 1), t.$o4 = Number.MAX_VALUE, 
t.$o6 = t.$o5 = t.$o3 = -1, t.$nf = t.$o7 = -0, t.$od = !1, t.$ks = new Map(), t.$oi = t.$og = t.$oh = 0, 
t.$oj = -0, t.$on = Number.MIN_VALUE;
}, _o.prototype.$q3 = function() {
var e = this.$n7;
e && (e.postMessage([ "close" ]), this.$n7 = null, setTimeout(function() {
e.terminate();
}, 1e3));
}, _o.prototype.$q4 = function(e) {
for (var t = this.$kn, n = 0; n < t.length && t[n] !== e; n += 3) ;
return n < t.length ? n + 1 : -1;
}, _o.prototype.$q5 = function(e, t, n) {
for (var r = this.$kn, i = 0; i < r.length && null !== r[i]; i += 3) ;
i === r.length ? r.push(e, t, n) : (r[i++] = e, r[i++] = t, r[i] = n);
}, _o.prototype.$q6 = function(e) {
for (var t = this.$kn, n = 0; n < t.length && null !== t[n] && t[n] < e; n += 3) ;
if (n > 0 && n < t.length) {
for (var r = n; n < t.length; t[n - r] = t[n], ++n) ;
for (n = t.length - r; n < t.length; t[n] = null, ++n) ;
}
}, _o.prototype.$q7 = function(e) {
var t = this, n = (t.$jq.$cr, t.$mi[e]);
if (t.$mz) for (var r = 0, i = 0; r < n.length; i += n[r], ++r) ; else {
r = 0, i = 0;
for (var a = 0; r < n.length; i += n[r], a = Me(a, n[r]), ++r) ;
}
return Me(Ze * (t.$mz ? .5 : 1) | 0, Ne(1e3 / (i / n.length)));
};
var zo = [ 1024, 128 ], Fo = (Nn ? 17 : 18) * window.devicePixelRatio | 0, Go = 9 * window.devicePixelRatio | 0, Vo = Array.of(Ur(1, 1.85, .33), 1.85), Wo = new Map(), qo = 0, Ho = [ Fo + 6 * window.devicePixelRatio | 0, Fo + 10 * window.devicePixelRatio | 0 ], Xo = 1e3, Yo = 20;
function Jo(e) {
return e + 2 * window.devicePixelRatio;
}
function Zo(e, t) {
return "rgba(" + (e >>> 16 & 255).toString() + "," + (e >>> 8 & 255).toString() + "," + (255 & e).toString() + "," + t / 255 + ")";
}
function Ko(e, t) {
return e.$fg() < t.$fg() ? -1 : 1;
}
function Qo(e, t) {
for (var n = e.values(); ;) {
var r = n.next();
if (r.done) break;
t(r.value);
}
}
_o.prototype.$q8 = function(e, t) {
var n = this.$m9, r = n.getContext("2d", xo), i = e.$fg(), a = $e((e.$df[1] << 8 | e.$dj) >>> 0, 4294967295, .5);
t && r.clearRect(e.$db[0] * n.width, (1 - (e.$db[1] + e.$db[3])) * n.height, e.$db[2] * n.width, e.$db[3] * n.height), 
Wo.has(a) ? r.fillStyle = Wo.get(a) : Wo.set(a, r.fillStyle = Zo(a >>> 8, e.$dj)), 
r.fillText(i, e.$db[0] * n.width + Go | 0, (1 - (e.$db[1] + .5 * e.$db[3])) * n.height | 0);
};
var es = $r(function(e) {
return e = e.toUpperCase(), ":AD:AE:AF:AG:AI:AL:AM:AO:AQ:AR:AS:AT:AU:AW:AX:AZ:BA:BB:BD:BE:BF:BG:BH:BI:BJ:BL:BM:BN:BO:BQ:BR:BS:BT:BV:BW:BY:BZ:CA:CC:CD:CF:CG:CH:CI:CK:CL:CM:CN:CO:CR:CU:CV:CW:CX:CY:CZ:DE:DJ:DK:DM:DO:DZ:EC:EE:EG:EH:ER:ES:ET:EU:FI:FJ:FK:FM:FO:FR:GA:GB:GD:GE:GF:GG:GH:GI:GL:GM:GN:GP:GQ:GR:GS:GT:GU:GW:GY:HK:HM:HN:HR:HT:HU:ID:IE:IL:IM:IN:IO:IQ:IR:IS:IT:JE:JM:JO:JP:KE:KG:KH:KI:KM:KN:KP:KR:KW:KY:KZ:LA:LB:LC:LI:LK:LR:LS:LT:LU:LV:LY:MA:MC:MD:ME:MF:MG:MH:MK:ML:MM:MN:MO:MP:MQ:MR:MS:MT:MU:MV:MW:MX:MY:MZ:NA:NC:NE:NF:NG:NI:NL:NO:NP:NR:NU:NZ:OM:PA:PE:PF:PG:PH:PK:PL:PM:PN:PR:PS:PT:PW:PY:QA:RE:RO:RS:RU:RW:SA:SB:SC:SD:SE:SG:SH:SI:SJ:SK:SL:SM:SN:SO:SR:SS:ST:SV:SX:SY:SZ:TC:TD:TF:TG:TH:TJ:TK:TL:TM:TN:TO:TR:TT:TV:TW:TZ:UA:UG:UM:US:UY:UZ:VA:VC:VE:VG:VI:VN:VU:WF:WS:XK:YE:YT:ZA:ZM:ZW:".indexOf(e) >= 0 ? e.split("").map(function(e) {
return String.fromCodePoint(e.codePointAt(0) + 127397);
}).join("") : "";
}), ts = !1, ns = !1;
function rs(e, t) {
return null === t[0] ? null === e[0] ? 0 : -1 : null === e[0] ? 1 : t[2] - e[2] + .5 * (t[1] - e[1]);
}
_o.prototype.$q9 = function() {
if (this.$kq) return !0;
var e = this, t = e.$m9, n = t.getContext("2d", xo), r = 0, i = 0, a = 2 * Go + Fo, o = 1 / t.width, s = 1 / t.height, c = a * s, l = e.$jq.$cr, u = e.$nt, h = e.$nu;
try {
n.font = Fo + "px sans-serif";
} catch (e) {
return ts = !0, !1;
}
ts && !ns && (ns = !0);
for (var d = e.$jq.$cq.values(), p = 0, f = d.next(); !f.done; f = d.next()) (f = f.value) !== l && (p === h.length ? h.push(f) : h[p] = f, 
++p);
h.splice(p, h.length), h.sort(Ko);
for (var m = 0, g = !0; m < h.length; ++m) {
var v, y = (f = h[m]).$fg(), $ = f.$db;
if (m === u.length) u.push(v = new Array(4)); else {
if ((v = u[m])[0] === y && $[2] * $[3] != 0) {
r = v[1], i = v[2];
continue;
}
g && (n.clearRect(r, i, t.width - r, a), n.clearRect(0, i + a, t.width, t.height - (i + a)), 
g = !1);
for (var b = u.length - 1; b > m; u[b--][0] = null) ;
}
v[0] = y;
var x = n.measureText(y).width, w = Ne(x + 2 * Go);
if (r + w > t.width) {
if (r > 0 && (r = 0, (i += a) > t.height - a)) {
n.clearRect(0, 0, t.width, t.height *= 2);
for (b = u.length - 1; b >= 0; u[b--][0] = null) ;
return e.$q9();
}
w = Me(w, t.width);
}
$[2] = w * o, $[3] = c, $[0] = r * o, $[1] = 1 - (i * s + $[3]), e.$q8(f, !1), v[1] = r += w, 
v[2] = i, v[3] = w;
}
return e.$ma.needsUpdate = !0, !0;
}, _o.prototype.$qa = function(e) {
if (!this.$kq) for (var t = this, n = t.$m9, r = (t.$hk.right - t.$hk.left) / (t.$k8.width * window.devicePixelRatio), i = t.$jq.$cr, a = t.$jq.$cq.values(), o = a.next(); !o.done; o = a.next()) if ((o = o.value).$fi() && o.$dh.$e6) for (var s = 0; s < o.$dr.length; ++s) o.$dr[s].$d1 && (o.$dr[s].$d1[0].visible = !1); else if (o !== i) {
var c = !o.$dd;
o.$dd || (o.$dd = new $3.Mesh(new $3.PlaneGmtr(1, 1), t.$oa), t.$ke.add(o.$dd), 
o.$dd.renderOrder = 7);
var l = o.$dd.geometry.faceVertexUvs[0];
(c || 255 !== o.$dj) && (o.$dj = 255, t.$q8(o, !0), t.$ma.needsUpdate = !0);
var u = o.$db;
!c && Ir(u, o.$dc) || (l[0][0].set(u[0], u[1] + u[3]), l[0][1].set(u[0], u[1]), 
l[0][2].set(u[0] + u[2], u[1] + u[3]), l[1][0].copy(l[0][1]), l[1][1].set(u[0] + u[2], u[1]), 
l[1][2].copy(l[0][2]), o.$dc.set(o.$db), o.$dd.geometry.uvsNeedUpdate = !0), o.$dd.scale.set(u[2] * n.width * r, u[3] * n.height * r, 1), 
o.$fi() && u[2] * u[3] ? o.$dd.position.set(o.$dh.$e8[0] * t.$i8, (o.$dh.$e8[1] - o.$dh.$ei * t.$ih * Ur(Vo[0], Vo[1], Dr(o === t.$m4 ? t.$m8[1] : o === t.$m6 ? t.$m8[0] : 0))) * t.$i8 - .5 * u[3] * n.height * r, ft) : o.$dd.visible = !1;
}
}, _o.prototype.$qb = function(e) {
return e * this.$l6;
}, _o.prototype.$qc = function(e, t) {
var n;
return !t && this.$ks.get(e) || (this.$ks.set(e, n = $(e)), n);
}, _o.prototype.$qd = function() {
this.$ks = new Map();
}, _o.prototype.$qe = function() {
var e = this, t = $("#lbrd-entries"), n = t.children().eq(0).eq(0).children(), r = ss && is && as || n.eq(1).width(), i = kr(256, .1 * window.innerWidth, .2 * window.innerWidth);
r += Me(.5 * r, 24), e.$lx && e.$lx[0] === i && e.$lx[1] === r || (t.find(".lbrd-entry > span:nth-child(1)").css("width", i).find("span").css("width", i - r).css("max-width", i - r), 
e.$lx || (e.$lx = new Float64Array(2)), e.$lx[0] = i, e.$lx[1] = r);
}, _o.prototype.$qf = function() {
for (var e = this, t = e.$jq.$cq, n = e.$nw, r = t.values(), i = r.next(), a = 0; !i.done; i = r.next()) if (0 !== (i = i.value).$ds) {
a === n.length && n.push(new Array(4));
var o = n[a];
o[0] = i.$d2, o[1] = i.$d2 === e.$d2, o[2] = (o[1], i.$ds), o[3] = i.$do === Kn ? null : i.$do, 
++a;
}
for (;a < n.length; ++a) n[a][0] = null, n[a][1] = !1, n[a][2] = -1;
n.sort(rs), e.$od = !0;
};
var is = null, as = 0;
function os(e) {
ss && e && e !== is && (is && ss.unobserve(is), ss.observe(is = e));
}
var ss = "ResizeObserver" in window ? new ResizeObserver(function(e) {
for (var t of e) t.target === is && (as = t.contentRect.width);
}) : null;
function cs(e, t) {
return function() {
for (var n = new Array(), r = new Array(), i = 1; i < e; ++i) n.push(".topscores-table:nth-child(" + i + ")"), 
r.push(".topscores-tabs span:nth-child(" + i + ")");
for (i = e + 1; i <= t; ++i) n.push(".topscores-table:nth-child(" + i + ")"), r.push(".topscores-tabs span:nth-child(" + i + ")");
sc(n.join(","), ".topscores-table:nth-child(" + e + ")", "flex")(), $(r.join(",")).removeClass("topscores-active-tab").css("color", ""), 
$(".topscores-tabs span:nth-child(" + e + ")").addClass("topscores-active-tab"), 
$(".topscores-active-tab, .topscores-table span:nth-child(1)").css("color", Zc().$hf.$bj);
};
}
function ls(e) {
e.lbrd && (e.lbrd = e.lbrd.filter(function(e) {
return "Weekly" !== e[0];
}));
}
_o.prototype.$qg = function(e) {
var t = this, n = t.$nw, r = t.$k0.show_flags;
if (t.$k0.show_lbrd) {
for (var i = 0; i < n.length && null !== n[i][0]; ++i) ;
for (var a = 0; a < i && n[a][0] !== t.$d2; ++a) ;
if (a < i && a >= In) {
var o = n[In - 1];
n[In - 1] = n[a], n[a] = o;
}
var s = $("#lbrd-entries"), c = s.children(), l = c.length, u = Me(In, i), h = !1;
u < l && c.slice(l = u).remove();
for (i = 0; i < l; ++i) {
var d = n[i], p = (m = c.eq(i)).children(), f = t.$jq.$cv(d[0]).$d7;
d[0] === t.$d2 ? t.$lw && t.$lw[0] === m[0] || ($("#my-lbrd-entry").removeAttr("id"), 
m.attr("id", "my-lbrd-entry"), t.$lw = m, h = !0) : p.css("color", ""), Hr(p[0].firstChild, (d[0] === t.$d2 ? a + 1 : i + 1) + ". " + (r && d[3] ? es(d[3]) + " " : "") + ti(t.$kb && d[0] === t.$d2 ? f : t.$jm.get(f))), 
Hr(p[1], d[2]), 0 === i && (m[0].children[1] || de("/so1_[" + d + "] " + l + " " + u), 
os(m[0].children[1]));
}
for (;i < u; ++i) {
d = n[i], f = t.$jq.$cv(d[0]).$d7;
var m, g = d[0] === t.$d2;
g && $("#my-lbrd-entry").attr("id", ""), Hr((p = (m = $(v(d))).children())[0].firstChild, (g ? a + 1 : i + 1) + ". " + (r && d[3] ? es(d[3]) + " " : "") + ti(t.$kb && g ? f : t.$jm.get(f))), 
g && (t.$lw = m, h = !0), s.append(m), 0 === i && (m[0].children[1] || de("/so2_[" + d + "] " + l + " " + u), 
os(m[0].children[1]));
}
t.$lw && h && t.$lw.children().css("color", t.$hf.$be[2]), 0 === u ? sc("#lbrd", "")() : t.$qe();
}
function v(e) {
t.$jq.$cv(e[0]) || de("/ulb0_[" + e + "]");
var n = t.$jq.$cv(e[0]).$d7, o = e[0] === t.$d2;
return (o ? '<div id="my-lbrd-entry"' : "<div") + ' class="lbrd-entry"><span><span>' + (o ? a + 1 : i + 1) + ". " + (r && e[3] ? es(e[3]) + " " : "") + ti(t.$kb && o ? n : t.$jm.get(n)) + "</span></span><span>" + e[2] + "</span></div>";
}
}, _o.prototype.$qh = function() {
if (this.$l5) {
for (var e = "", t = "", n = this.$l5.lbrd, r = n.length, i = 0, a = new Array(3); i < r; ++i) {
var o = n[i];
a[0] = a[1] = a[2] = "", t += '<div class="topscores-table">', e += '<span style="text-align: center">' + o[0] + "</span>";
for (var s = 0, c = o[1], l = c.length; s < l; ++s) a[0] += "<div>" + (s + 1) + ".</div>", 
a[1] += "<div>" + ri(c[s][0]) + "<br></div>", a[2] += "<div>" + c[s][1] + "</div>";
t += "<span>" + a[0] + "</span><span>" + a[1] + "</span><span>" + a[2] + "</span></div>";
}
$(".topscores-tabs").html(e), $("#topscores .body .text").html(t);
for (i = 1; i <= r; ++i) $(".topscores-tabs span:nth-child(" + i + ")").on("click", cs(i, r));
cs(1, r)();
}
}, _o.prototype.$qi = function() {
var e = this, t = $.getJSON("/lbrd.json", function(n) {
ae(t), e.$l5 && n && ls(e.$l5 = n);
}).fail(function() {
ae(t), console.error("Cannot get/parse leaderboard data");
});
he.push(t);
};
var us = 1 / (2 * Math.PI / or);
_o.prototype.$qj = function(e) {
return (e = e * us | 0) >= 0 ? e & or - 1 : or - 1 - (-e & or - 1);
}, _o.prototype.$qk = function(e) {
var t = this, n = t.$lp, r = e.$d5[5] << 2;
t.$kg = Float64Array.of(n[r + 0], n[r + 1], e.$di), t.$kh = Array.of(Float64Array.of(n[r + 0], n[r + 1], e.$di, 2));
};
var hs = {
_cnt: 0,
_cnt2: 0,
_tries: 0,
_report: Math.random() < 1
};
function ds(e, t, n, r, i) {
return (i = i || new Float64Array(2))[0] = (1 - e) * ((1 - e) * t[0] + e * n[0]) + e * ((1 - e) * n[0] + e * r[0]), 
i[1] = (1 - e) * ((1 - e) * t[1] + e * n[1]) + e * ((1 - e) * n[1] + e * r[1]), 
i;
}
function ps(e) {
return e.map(function(e) {
return "[object Array]" === Object.prototype.toString.call(e) ? ps(e) : e;
});
}
_o.prototype.$ql = function(e, t) {
var n = this, r = n.$qj(e), i = n.$o1[r << 1], a = n.$o1[1 + (r << 1)], o = Or(this.$kh);
o[0] === i && o[1] === a || (o[3] < 2 ? (o[0] = i, o[1] = a, o[2] = t) : (n.$kh.push(Float64Array.of(i, a, t, 0)), 
n.$kh.length > 1 && n.$kh.shift()), ++hs._cnt, ++hs._cnt2);
}, _o.prototype.$qm = function(e) {
for (;this.$m1.has(this.$m2 = (this.$m2 + 1) * (this.$m2 < 2147483647)); ) ;
return this.$m1.set(this.$m2 = (this.$m2 + 1) * (this.$m2 < 2147483647), e), this.$m2;
}, _o.prototype.$qn = function(t) {
e(this.$m1.has(t)), this.$m1.delete(t);
}, _o.prototype.$qo = function() {
var e = this, t = e.$n4, n = Ia(4);
if (Pe(t - n) > 5) {
if (n = Ia(), Pe(t - n) > 100) {
}
if (Pe(t - n) > 5) return e.$qp(0 | Pe(t - n)), te.$an(n, t), e.$n4 = n, !0;
}
return !1;
}, _o.prototype.$qp = function(e) {
var t = this;
t.$jk !== qt && t.$jk !== Ht || (0 === t.$og && t.$n0 && (t.$pv(Uint8Array.of(4)), 
t.$on = Ar()), t.$og = e || 1);
};
var fs = [ 0, 1, 1, 1 ], ms = [ 0, .9, 1, .9 ], gs = [ 0, 1, 1, 1.5 ], vs = function(e, t, n, r) {
return [ e ].concat(r.map(function(e) {
return [ t, n ].concat(e);
}));
}, ys = [ 639, 100 ], $s = ys[0] / ys[1], bs = 1300, xs = 500, ws = 1100, _s = [ 2500, 5e3 ], Ms = 1.5 / $s, Ss = 1 / Ms, As = [ vs(0, 0, .33, [ [ fs, gs, [ 10, 80, 0, 70, 0, 26, 20, 6, 60, 6, 70, 16 ], [ .5, .5, .5 ] ] ]), vs(0, (1 - .33) / 12 * 1, .33, [ [ fs, gs, [ 35, 48, 70, 48 ], [ 70, 48, 70, 80 ], [ 70, 80, 60, 90, 20, 90, 11.5, 81 ], [ .5 ] ] ]), vs(95, (1 - .33) / 12 * 1, .33, [ [ fs, gs, [ 36, 90, 0, 90, 0, 14, 0, 6 ], [ .5 ] ] ]), vs(95, (1 - .33) / 12 * 2, .33, [ [ fs, gs, [ 74, 6, 74, 14, 74, 90, 38, 90 ], [ .5 ] ] ]), vs(196, (1 - .33) / 12 * 3, .264, [ [ fs, gs, [ 0, 90, 0, 6 ] ] ]), vs(196, (1 - .33) / 12 * 4, .264, [ [ fs, gs, [ 62, 90, 2, 90 ] ] ]), vs(282, (1 - .33) / 12 * 4, .264, [ [ fs, gs, [ 0, 90, 0, 8 ] ] ]), vs(282, (1 - .33) / 12 * 5, .33, [ [ fs, gs, [ 2, 6, 30, 6 ], [ 31, 6, 62, 6, 62, 60, 31, 60 ], [ .5 ], [ 30, 60, 2, 60 ] ] ]), vs(369, (1 - .33) / 12 * 5, .33, [ [ fs, gs, [ 47, 48, 0, 48 ], [ 0, 48, 0, 7 ], [ 0, 7, 62, 7 ] ] ]), vs(369, (1 - .33) / 12 * 6, .33, [ [ fs, gs, [ 62, 89, 0, 89 ], [ 0, 89, 0, 50 ] ] ]), vs(456, (1 - .33) / 12 * 6, .264, [ [ fs, gs, [ 0, 90, 0, 8 ] ] ]), vs(456, (1 - .33) / 12 * 7, .495, [ [ fs, gs, [ 2, 6, 25, 6 ], [ 27, 6, 56, 6, 56, 54, 27, 54 ], [ .5 ], [ 25, 54, 2, 54 ], [ 26, 56, 64, 90 ] ] ]), vs(539, 1 - .33, .33, [ [ [ 0, .6, 1, .6 ], gs, [ 6, 80, 12, 80, 12, 92, 0, 92, 0, 80, 6, 80 ], [ .5, .5, .5 ] ] ]), vs(564, .5025, .198, [ [ [ 0, .85, 1, .85 ], gs, [ 5, 90, 5, 35 ] ] ]), vs(589, (1 - .33) / 12 * 10, .264, [ [ ms, [ 0, 1, 1, 3 ], [ 22, 35, 44, 35, 44, 60.5 ], [] ], [ ms, [ 0, 1, 1, 3 ], [ 22, 90, 0, 90, 0, 64.5 ], [] ] ]), vs(589, (1 - .33) / 12 * 10 + .264 * 800 / (800 + bs), .264, [ [ ms, [ 0, 3, 1, 0 ], [ 44, 62.5, 44, 90, 24, 90 ], [] ], [ ms, [ 0, 3, 1, 0 ], [ 0, 62.5, 0, 35, 20, 35 ], [] ] ]) ], Ts = ps(As);
function Ls(e) {
return e;
}
function Cs(e) {
return e();
}
var Es = [ .22 / .8, .22 / .8 * 1.2 ], Ps = 1.94 - .6 + Es[1] + .1, ks = .88 / Ps;
function Os(e) {
var t = Zc(), n = se("clr-select-area").getBoundingClientRect(), r = (e.clientX - n.left) / n.width - .5, i = (e.clientY - n.top) / n.height - .5, a = we(Dr(r) + Dr(i)) / (.5 * (t.$o3 >= 0 ? 1 : 1 / Ps));
return a <= 1 ? [ Ce(-i, r), a ] : null;
}
function Ds(e) {
var t = Zc(), n = e;
"touchstart" === e.type && t.$o4 === Number.MAX_VALUE && e.changedTouches.length && (t.$o4 = (e = e.changedTouches.item(0)).identifier);
var r = Os(e);
return r && (t.$o3 = r[1]), Is(n);
}
function Ns(e) {
var t = Zc();
return "touchend" === e.type && Zs(e.changedTouches, t.$o4) && (t.$o4 = Number.MAX_VALUE), 
t.$o3 = -1, Is(e);
}
function Is(e) {
var t = Zc(), n = e;
if (e.type.startsWith("touch") && !(e = Zs(e.changedTouches, t.$o4))) return Gc(n, tr);
var r = Os(e);
if (t.$o5 >= 0 != !!r && t.$qc("#clr-select-area").css("cursor", r ? "" : "default"), 
r) {
if (t.$o3 >= 0) {
var i = r[0];
i -= Ue, i *= -1, i += Be * (i < 0), t.$o5 = Ie(180 * i / Re) % 360, t.$o3 = r[1];
}
} else t.$o5 = t.$o3 = -1;
return Gc(n, tr);
}
function Rs(e) {
return e.shiftKey || e.altKey || e.ctrlKey || e.metaKey;
}
_o.prototype.$qq = function() {
var t = this, n = Ar(), r = window.innerWidth, i = window.innerHeight, a = r / i, o = 2 * (On ? Me(Nn ? .35 : .2, (Nn ? .9 : .7) * a / $s, 1.3 / $s) : .145), l = Nn ? .4 : On && a > 1 ? .35 : .45, u = .09 * o, h = 7 / i, d = !1, p = t.$dy;
if (p) p.$l2 === r && p.$l3 === i || (p.$l2 = r, p.$l3 = i, d = !0); else {
(p = t.$dy = {}).$hg = new $3.Scene(), p.$hq = G(!0, null, 1024, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor,
blendSrcAlpha: $3.OneFactor
}), p.$hg.add(p.$hq), p.$j9 = null, p.$nr = G(!0, null, 366, 1, 0, an, {
blendSrc: $3.SrcAlphaFactor,
blendDst: $3.OneMinusSrcAlphaFactor
}), p.$hg.add(p.$nr);
var f = new $3.CircleGmtr(1, 256);
p.$ly = new $3.Mesh(f, new $3.MeshBasicMtrl({
vertexColors: $3.VertexColors
})), p.$ly.position.y = .1, p.$hg.add(p.$ly), p.$l0 = n, p.$l1 = -0, p.$l4 = -0, 
p.$l2 = r, p.$l3 = i;
}
var m = _e(0, n - (t.$dy.$l0 + 500)) / (800 + bs), g = m > 1 ? 1 : 0, v = o * ys[0] / ys[1] * -.5, y = ys[1] / o, b = 1 / y, x = [ l + ys[1] * b * .5, 1 / (ys[1] * b) ], w = [ v, 1 / (-2 * v) ], _ = t.$hf.$aw;
1 === g && ((!t.$dy.$l1 || n - t.$dy.$l1 > 2500) && (t.$dy.$l1 = n + Br(_s[0], _s[1])), 
n < t.$dy.$l1 ? (g = 0, m = 1) : m = (n - t.$dy.$l1) / 2500);
var M = (_e(0, n - 0) - t.$dy.$l0) / 4e3, S = 1 - ke(1 - (M >= 1 ? 1 : M), 2), A = Bn;
A[0] = A[1] = new $3.Color(t.$hf.$ay[0]), A[2] = new $3.Color($e(t.$hf.$ay[0], t.$hf.$ay[1], S));
for (var T = 0, L = (f = t.$dy.$ly.geometry).faces; T < L.length; ++T) L[T].vertexColors.length > 0 ? (L[T].vertexColors[0].copy(A[0]), 
L[T].vertexColors[1].copy(A[1]), L[T].vertexColors[2].copy(A[2])) : L[T].vertexColors = A.slice(0, 3);
f.colorsNeedUpdate = !0, t.$dy.$ly.scale.x = (a > 1 ? .5 * (1 + a) : 1) * (t.$dy.$ly.scale.y = Ur(1.2, 2.4, S) * _e(1, .5 * (1 + a)));
var C = t.$dy.$hq, E = 3 * y / i, P = t.$le, k = t.$dy.$hk = go(P), D = t.$dy.$j9;
function N() {
P && (P.setClearColor(t.$hf.$ay[0], 1), P.render(t.$dy.$hg, k));
}
var I = kr(.1, 96 / 2.54 * 1.2 / i, 96 / 2.54 * 1.6 / i), R = .18 * Re, j = 2 / i, U = I * (1.94 - .6), B = I * Ps, z = [ 10, 20, 1 ], F = .1 * I, V = t.$dy.$nr, W = zn, q = g > 0 ? 1 : kr(Ur(-1, 3, Dr(m)), 0, 1), H = 2 * j, X = Wn;
if (V.clear(), X.$8n(), X.$9v = W, W[0] = W[1] = W[2] = 0, t.$o6 >= 0 && t.$o6 < 360) if (t.$o3 < 0) t.$o7 = -0; else {
var Y = kr(zr(t.$o3, ks, (1 + Es[1]) / Ps), 0, 1);
if (0 === Y) t.$o7 && (t.$o6 += .06 * (n - t.$o7) * z[2]), t.$o7 = n; else {
if (t.$o5 >= 0 && t.$o6 !== t.$o5) {
var J = t.$o5 - t.$o6;
Pe(J) > 180 && (J -= 360 * je(J));
var Z = Ur(z[0], z[1], (1 - ke(1 - Pe(J) / 180, 2)) * Y);
Z >= Pe(J) ? t.$o6 = t.$o5 : t.$o6 += je(J) * Z;
}
t.$o7 = -0;
}
t.$o6 += 360 * (t.$o6 < 0), t.$o6 %= 360;
var K = GLOB[gn[16]]();
K.player_hue = Ie(t.$o6), GLOB[gn[17]](K);
} else t.$o6 = GLOB[gn[16]]().player_hue, t.$o7 = -0, t.$o6 >= 0 && t.$o6 < 360 || de("/qwert_" + JSON.stringify(GLOB[gn[16]]()));
if (t.$o3 >= 0) {
for (var Q = 0, ee = (T = 0, Be / 360); T < 360; ++T, Q += ee) W[0] = U * Se(-Q + Ue), 
W[1] = U * Ae(-Q + Ue), X.$9w = .06 * I, X.$a8 = 3 * H / X.$9w, X.$9z = Ii(t.$hf.$b9[T][1], q), 
V.$8e(X, new s(), c);
var te = Ur(.8, 1, _e(0, zr(t.$o3, ks, 1)));
X.$9w = I * Es[1] * te, X.$a8 = H / X.$9w, X.$9z = 255, W[0] = U * Se(-t.$o6 / 180 * Re + Ue), 
W[1] = U * Ae(-t.$o6 / 180 * Re + Ue), V.$8e(X, new s(), c), X.$9w -= I * (Es[1] - Es[0]), 
X.$a8 = H / X.$9w, X.$9z = Ii(t.$hf.$b9[Ie(t.$o6)][1], q), V.$8e(X, new s(), c);
}
var ne = Ii($e(t.$hf.$b9[Ie(t.$o6)][1], 16777215, .5 * (1 - q)), q);
X.$8n(), X.$9v = W, W[0] = W[1] = W[2] = 0, X.$9w = I + 0, X.$a8 = H / X.$9w, X.$9z = ne, 
V.$8e(X, new s(), c), X.$9w = .88 * I + 0, X.$a8 = H / X.$9w, X.$9z = q ? 255 : 0, 
V.$8e(X, new s(), c), X.$9w = .22 * I + 0, X.$a8 = H / X.$9w, X.$9z = ne;
var re = .6 * I + 0 * (n < 0 ? function(e) {
return 1 - (1 - e) * (1 - e);
} : Ls)(0), ie = .22 * -I;
W[0] = re * Se(.5 * Re - R), W[1] = ie + re * Ae(.5 * Re - R), V.$8e(X, new s(), c), 
W[0] = re * Se(.5 * Re + R), W[1] = ie + re * Ae(.5 * Re + R), V.$8e(X, new s(), c);
var ae = t.$qc("#clr-select-area");
0 === ae.length && ((ae = $('<div id="clr-select-area"></div>')).on("mousedown" + (On ? " touchstart" : ""), Ds).on("mouseup" + (On ? " touchend" : ""), Ns).appendTo("#root").css("right", 0).css("bottom", 0).on("mousemove" + (On ? " touchmove" : ""), Is), 
ae = t.$qc("#clr-select-area", !0));
var oe = 2 * (B + F) * .5 * i | 0, se = .5 * (B + F - I) * i | 0;
if (ae[0].getBoundingClientRect().height != oe && (ae.width(oe).height(oe), t.$qc("#to-top-btn").css("right", se).css("bottom", se).width(oe - 2 * se).height(oe - 2 * se)), 
V.position.set(a - (B + F), B + F - 1, 0), t.$dy.$l4 !== g + m || d) {
t.$dy.$l4 = g + m, d && (C.clear(), D = t.$dy.$j9 = null);
X = Wn.$8n();
if (!D) {
D = t.$dy.$j9 = ii(), Ts = ps(As);
for (var ce = 0; ce < Ts.length; ++ce) for (var le = Ts[ce], ue = 1; ue < le.length; ++ue) {
for (var he = le[ue], pe = 4, fe = new Array(); pe < he.length; ) {
var me = he[pe];
if (e(me.length >= 4), 4 === me.length) fe.push([ me.slice(0, 2), me.slice(2, 4), me.slice(2, 4) ]), 
++pe; else {
var ge = he[pe + 1], ve = me.slice(0, 2);
null == ge && de("/rbm_" + ce + "_" + ue + "_" + pe + "_" + me.map(function(e) {
return typeof e;
})), ge.push(1), e(ge.length === (me.length >> 1) - 2);
T = 2;
for (var ye = 0; T < me.length - 2; T += 2, ++ye) fe.push([ ve, me.slice(T, T + 2), [ Ur(me[T], me[T + 2], ge[ye]), Ur(me[T + 1], me[T + 3], ge[ye]) ] ]), 
ve = fe[fe.length - 1][2];
pe += 2;
}
}
le[ue] = he.slice(0, 4).concat(fe);
}
X.$9v = W;
for (ce = 0; ce < Ts.length; ++ce) for (le = Ts[ce], ue = 1; ue < le.length; ++ue) {
var be = ii(), xe = (he = le[ue])[3];
D.push(be), be.push(he[0], he[1], xe);
T = 2;
for (var Te = 0; T < xe.length; T += 2) {
Te += (st = xe[T] - xe[T - 2]) * (xe[T - 1] + .5 * st * (xe[T + 1] - xe[T - 1]));
}
T = 1;
for (var Le = 1 / Te; T < xe.length; xe[T] *= Le, T += 2) ;
he = le[ue];
for (var Ce = 4; Ce < he.length; ++Ce) for (var Ee = 0, ze = 2 * (pe = he[Ce])[0][0] - 4 * pe[1][0] + 2 * pe[2][0], Fe = 2 * (pe[1][0] - pe[0][0]), Ge = 2 * pe[0][1] - 4 * pe[1][1] + 2 * pe[2][1], Ve = 2 * (pe[1][1] - pe[0][1]); Ee <= 1; ) {
if (ds(Ee, pe[0], pe[1], pe[2], W), W[0] = v + (W[0] + le[0]) * b, W[1] = l + ys[1] * b * .5 - W[1] * b, 
(Ee += st = E / we(Dr(Ee * ze + Fe) + Dr(Ee * Ge + Ve))) - 1 > .7 * st && Ce < he.length - 1) break;
for (T = 1 + Number(Ee - st == 0 && 4 === Ce || Ee > 1); T > 0; --T) {
var We = new s();
We.$8l = Float32Array.of(W[0], W[1], (x[0] - W[1]) * x[1]), be.push(C.$8e(X, We, c));
}
}
T = 3;
for (var qe = be.length - 1, He = (ye = 0, 2), Xe = 1 / (be.length - 3 - 1), Ye = he[2], Je = new O(); T <= qe; ++T, 
ye += Xe) {
for (;ye > Ye[He]; ) He += 2;
var Ze = Ur(Ye[He - 1], Ye[He + 1], (ye - Ye[He - 2]) / (Ye[He] - Ye[He - 2]));
Je.$a8 = h / (Je.$9w = Je.$9x = u * Ze), be[T].$8o(Je, 3136);
}
}
}
var Ke = 0 === g ? 1 : 5, Qe = 0 === g ? Ur(.5 * -Ms, 1 + Ms, m) : Ur(-Ms, 1 + Ms * (2 * Ke - 1), m), et = 1 / ($s * Ms), tt = 2 * Ke - 1;
if (0 === g) {
T = 0;
for (var nt = D.length - 6; T < D.length; ++T) {
xe = (be = D[T])[2];
var rt = kr((m - be[0]) / be[1], 0, 1), it = Me(1, rt * (800 + bs) / 800), at = it, ot = 0;
X.$a1 = 255, X.$9v = W;
for (ye = 2; ye < xe.length && xe[ye] < at; ye += 2) {
var st;
ot += (st = xe[ye] - xe[ye - 2]) * (.5 * st * (xe[ye + 1] - xe[ye - 1]) + xe[ye - 1]);
}
if (ye >= xe.length) it = 1; else {
var ct = .5 * (xe[ye + 1] - xe[ye - 1]);
if (0 === ct) it = xe[ye - 2] + (it - xe[ye - 2]) / xe[ye - 1]; else {
var lt = xe[ye - 1], ut = it - xe[ye - 2];
it = ot + ut * (ct * ut + lt);
}
}
for (var ht = _[T >= nt ? 1 : 0][0], dt = _[T >= nt ? 1 : 0][1], pt = _[T >= nt ? 1 : 0][2], ft = 1 / (1 - (_t = T < nt ? .2 : .4)), mt = (ye = Mt = 3, 
be.length - Mt), gt = De(mt * bs / 800), vt = 1 / gt, yt = 1 / (1 * gt), $t = mt * rt * (1 + bs / 800), bt = Mt + Me(mt, Ne(it * mt)); ye < bt; ++ye) {
be[ye].$8p(X, 2056);
var xt = (((At = be[ye].$8l)[0] - w[0]) * w[1] - Qe) * Ss, wt = At[2];
X.$9z = $e($e(ht, dt, _e(0, wt - _t) * ft), pt, .7 * (1 - kr(($t - ye) * vt, 0, 1)));
Ze = kr(1 - ($t - ye) * yt, 0, 1);
Ze *= Ze, X.$9w = X.$9x * (1 + 1 * Ze), W[0] = At[0], W[1] = Pe(xt) >= 1 ? At[1] : At[1] + (Se(xt * Re) + 1) * (1 - wt) * o * .04, 
be[ye].$8o(X, 1284);
}
for (X.$a1 = 0, bt = be.length; ye < bt; ++ye) be[ye].$8o(X, 1);
}
} else {
X.$9v = W;
for (T = 0, nt = D.length - 6; T < D.length; ++T) {
be = D[T], ht = _[T >= nt ? 1 : 0][0], dt = _[T >= nt ? 1 : 0][1], pt = _[T >= nt ? 1 : 0][2];
var _t, Mt, St = _[T >= nt ? 1 : 0][3];
for (ft = 1 / (1 - (_t = T < nt ? .2 : .4)), ye = Mt = 3, bt = be.length; ye < bt; ++ye) {
be[ye].$8p(X, 2056);
var At;
xt = (((At = be[ye].$8l)[0] - w[0]) * w[1] - Qe) * Ss, wt = At[2];
if (X.$9z = $e(ht, dt, _e(0, wt - _t) * ft), Pe(xt) < 1) {
var Tt = _e(0, 1 - (xt * xt + Dr((wt - .5) * et)));
X.$9z = $e($e(X.$9z, pt, .45 * Tt), St, .15 * (1 - wt)), X.$9w = X.$9x * (1 + .15 * Tt);
} else X.$9w = X.$9x;
W[0] = At[0], W[1] = xt >= 1 || xt <= -tt ? At[1] : At[1] + (1 - wt) * Oe(.25 * (xt - 1)) * (Se(xt * Re) + 1) * o * .1, 
be[ye].$8o(X, 1284);
}
}
}
N();
} else N();
}, _o.prototype.$qr = function() {
var e = this;
e.$dy && (e.$dy.$l1 = -0), e.$qq(), e.$kz = jn(e.$qs.bind(e));
}, _o.prototype.$qs = function() {
var e = this;
e.$kz && (e.$qq(), e.$kz = jn(e.$qs.bind(e)));
}, _o.prototype.$qt = function() {
var e = this;
e.$kz && (Un(e.$kz), e.$kz = 0), e.$dy.$l4 = 0;
}, _o.prototype.$qu = function() {
return !(this.$jk === Vt || this.$jk === Ht);
};
var js = new Object();
function Us(e) {
var t = Zc(), n = (e.key ? e.key : String.fromCharCode(e.keyCode)).toUpperCase();
if (1 != js[n] && (js[n] = 1, t.$jk == qt && !Rs(e) && t.$jq.$cr)) {
Cr(e);
if (" " === n) return rc(e);
"ESCAPE" === n && (t.$jk === qt ? t.$p8(Qt) : t.$jk === Ht && t.$p8(Zt));
}
}
function Bs(e) {
var t = (e.key ? e.key : String.fromCharCode(e.keyCode)).toUpperCase();
if (1 == js[t]) return js[t] = 0, Zc().$jk != qt || Rs(e) || " " !== t ? void 0 : ac(e);
}
var zs = 0, Fs = 1, Gs = 2, Vs = [ .2, .2, .08 ], Ws = 105, qs = [ 400, 150 ], Hs = [ 400, 150 ], Xs = .67, Ys = .05;
function Js(e, t, n, r, i, a) {
var o = this;
o.$qv = e, o.$qw = t, o.$qx = n, o.$qz = n * r, o.$qy = n * i, o.$d5 = zs, o.$r0 = 0, 
o.$r1 = 1 - 1e-6, o.$r3 = -0, o.$r4 = -0, o.$hx = o.$r2 = null, o.$r5 = a;
}
function Zs(e, t) {
for (var n = e.length - 1; n >= 0; --n) if (e.item(n).identifier === t) return e.item(n);
return null;
}
function Ks(e) {
var t = Zc();
if (t.$jk !== qt || t.$k6) return Gc(e, tr);
t.$jq.$cs;
var n = t.$k8, r = Cr(e);
if (On) {
var i = t.$k4, a = Zs(e.changedTouches, t.$kx);
i && a && i.$r9(r, Float32Array.of((a.clientX - n.left) / n.width, 1 - (a.clientY - n.top) / n.height), t.$hk);
} else t.$ql(Ce(.5 * n.height - (e.clientY - n.top), e.clientX - n.left - .5 * n.width), r);
return Gc(e, tr);
}
Js.prototype.$pt = -0, Js.prototype.$r6 = function(t) {
if (this.$r5) {
var n = this;
Zc();
n.$r0 = .5 * (t.right - t.left), n.$d5 === Fs && (n.$hx.position.set(Ur(t.left, t.right, n.$qw[0]), Ur(t.bottom, t.top, n.$qw[1]), .7), 
n.$hx.scale.x = n.$hx.scale.y = n.$r1 * n.$r0), e(!n.$hx || t === n.$hx.parent);
}
}, Js.prototype.$r7 = function() {
var e = this;
return function(t) {
e.$r3 = t, e.$cp(t);
};
}, Js.prototype.$r8 = function() {
var e = this, t = Zc();
return function(n) {
e !== t.$k4 ? (e.$ra(), e.$r3 = 0, this.fn = null) : 1 === n ? (e.$ra(), e.$r3 = 0, 
t.$k4 = null, t.$pk()) : (e.$r3 = 1 + n, e.$cp(1 - n));
};
}, Js.prototype.$r9 = function(e, t, n) {
var r = this, i = Zc();
if (r.$d5 === zs && Rr(r.$qw, t) > .1 * (r.$qx - r.$qz) && (r.$d5 = Fs, r.$r5 && (r.$hx = new $3.Group(), 
r.$r2 = Qr(0, r.$qz + .5 * r.$qy, 0, r.$qy, Vs[0]), r.$hx.add(r.$r2), r.$hx.add(Qr(r.$qx - r.$qy, r.$qx + 3 * r.$qy, r.$qy, r.$qy, Vs[1])), 
r.$hx.add(Qr(0, r.$qx + 3 * r.$qy, 0, r.$qy, Vs[2])), n.add(r.$hx)), r.$cp(0), qs[r.$r5 ? 1 : 0] > 0 ? i.$gp.$gr(i.$pm(e, qs[r.$r5 ? 1 : 0], this.$r7(), 1)) : this.$r7()(null)), 
t[0] -= r.$qw[0], t[1] -= r.$qw[1], n.right > n.top ? (t[0] *= n.right / n.top, 
r.$r4 = jr(t) / (r.$qx - r.$qz) * n.right / n.top) : (t[1] *= n.top / n.right, r.$r4 = jr(t) / (r.$qx - r.$qz)), 
r.$d5 === Fs && (0 !== t[0] || 0 !== t[1])) {
var a = Js.prototype.$pt = Ce(t[1], t[0]);
i.$ql(a, e), r.$r6(n), r.$r5 && (r.$r2.position.x = (r.$qx - r.$qz) * Se(a), r.$r2.position.y = (r.$qx - r.$qz) * Ae(a));
}
}, Js.prototype.$ra = function() {
this.$r5 && this.$d5 !== zs && Wr(this.$hx), this.$r3 = -0;
}, Js.prototype.$cp = function(e) {
!this.$r5 || this.$d5 !== Fs && this.$d5 !== Gs || this.$hx.children.forEach(function(t, n) {
ei(t, Ii(14741759, e * Vs[n]));
});
}, _o.prototype.$rb = function(e, t, n) {
var r = Wn;
r.$9v = zn, r.$9v[0] = e, r.$9v[1] = t, r.$9v[2] = 0, r.$9z = 4294967168, r.$9w = 8 * this.$if * n, 
r.$a8 = .99, this.$jj.$8o(r, 1348);
};
var Qs = new Uint8Array([ 99 ]), ec = new Uint8Array([ 100 ]);
function tc(e, t, n) {
var r = Zc();
r.$pw(e, t, [ n, e + r.$jn ]);
}
function nc(e) {
var t = Zc(), n = t.$jq.$cs;
n[0] < n[1] && e >= n[0] + t.$iz && tc(n[0] = _e(e, t.$jt, n[1] + 1), Qs, xt);
}
function rc(e) {
var t = Zc();
if (t.$jk !== qt || t.$k6) return Gc(e, tr);
var n = Cr(e);
if (t.$l7 = -0, On) {
if (t.$kx === Number.MAX_VALUE) {
var r = e.changedTouches.item(0);
t.$kx = r.identifier;
var i = t.$k8, a = Float32Array.of((r.clientX - i.left) / i.width, 1 - (r.clientY - i.top) / i.height);
t.$k4 = new Js(n, a, Ws / i.width, Xs, Ys, 0 === t.$k0.controls);
} else if (t.$ky === Number.MAX_VALUE) {
r = e.changedTouches.item(0);
t.$ky = r.identifier, nc(n);
}
} else 0 !== e.button && "keydown" !== e.type || nc(n);
return Gc(e, tr);
}
function ic(e) {
return !(e.touches.length > 1) || Gc(e, tr);
}
function ac(e) {
var t = Zc();
if (t.$jk !== qt || t.$k6) return Gc(e, tr);
var n = Cr(e), r = t.$jq.$cs, i = t.$k4, a = On && Zs(e.changedTouches, t.$kx), o = On && Zs(e.changedTouches, t.$ky);
return (0 === e.button || "keyup" === e.type || i || o) && (i && a && (i.$d5 === Fs ? (i.$d5 = Gs, 
Hs[i.$r5 ? 1 : 0] > 0 ? t.$gp.$gr(t.$pm(n, Hs[i.$r5 ? 1 : 0], i.$r8(), 1)) : i.$r8()(null)) : i.$r8()(null)), 
(!On || a || o) && r[0] > r[1] && tc(r[1] = _e(n, t.$jt, r[0] + 1), ec, wt)), On && (a && (t.$kx = Number.MAX_VALUE), 
(a || o) && (t.$ky = Number.MAX_VALUE)), Gc(e, tr);
}
function oc(e) {
ue.push("br " + (0 | Ar()));
var t = Zc();
t.$l7 = Ar(), t.$jk === Vt || t.$mq || t.$p2();
}
function sc(e, t, n) {
return function() {
e && $(e).css("display", "none").css("visibility", "hidden").css("content-visibility", "hidden"), 
t && (n = n || "block", $(t).css("display", n).css("visibility", "visible").css("content-visibility", "visible"));
};
}
function cc(e, t) {
try {
window.scrollTo({
top: e,
left: 0,
behavior: t ? "smooth" : "auto"
});
} catch (t) {
window.scrollTo(e, 0);
}
}
function lc(e, t) {
var n = [ 250, 250 ];
return function() {
if (e) {
Zc().$jk, cc(0, !1), $(t + "#overlay-bg").stop(), $(t).css("opacity", 0).animate({
opacity: 1
}, n[0], function() {
$(this).css("opacity", "");
}), $("#overlay-bg").css("opacity", 0).animate({
opacity: 1
}, n[0], function() {
$(this).css("opacity", "");
}), sc(0, t + ",#overlay-bg")();
} else {
var r = $("#overlay-bg").css("opacity");
$(".overlay,#overlay-bg").stop().animate({
opacity: 0
}, r * n[1], function() {
$(this).css("opacity", ""), sc(".overlay,#overlay-bg", 0)();
});
}
};
}
function uc(e) {
var t = Zc();
(e.key ? "enter" !== e.key.toLowerCase() : 13 !== e.keyCode) || t.$jk != Vt && t.$jk !== Ht || (e.preventDefault(), 
t.$p8(Yt));
}
GLOB[gn[7]] = ne, GLOB[gn[14]] = function(e) {
var t = Math.random();
return (e = e.filter(function(e) {
return e[1] > 0;
})).length ? (e.find(function(e) {
return (t -= e[1]) < 0;
}) || e[e.length - 1])[0] : "";
}, function() {
if (GLOB[gn[13]]) GLOB[gn[13]](); else {
GLOB[gn[3]] = function() {
var e = Q.$bs(gn[10]);
return Q.$br(gn[10], (e = e ? parseInt(e) + 1 : 1).toString()), e;
}, GLOB[gn[4]] = function() {
var e = Q.$bs(gn[10]);
return e ? parseInt(e) : (Q.$br(gn[10], "1"), 1);
}, GLOB[gn[5]] = function() {
var e = Q.$bs(gn[11]);
return e ? parseInt(e) : 0;
}, GLOB[gn[6]] = function() {
Q.$br(gn[11], parseInt(GLOB[gn[4]]()).toString());
}, GLOB[gn[8]] = function() {
var e = GLOB[gn[14]](INTERSTITIAL_AD_PROVIDERS);
if (dr || (window.ADS_BLOCKED || "adinplay" === e && void 0 === window.adplayer) && !oe()) {
var t = "#adinplay-video-ad", n = $(t), r = dr || 7, i = r;
return n.addClass("video-ad-placeholder").css("opacity", 0).animate({
opacity: 1
}, 2e3), sc(0, t, "table")(), void function e() {
n.html('<span class="video-ad-placeholder-msg">' + $c + '</span><span class="video-ad-placeholder-timer">' + (i <= r - 1 ? i : "") + "</span>"), 
setTimeout(--i > 0 ? e : function() {
n.css("opacity", "").removeClass("video-ad-placeholder").empty(), sc(t, 0)(), GLOB[gn[7]](!0);
}, 1e3);
}();
}
if ("adinplay" === e) aiptag.cmd.player.push(function() {
document.getElementById("adinplay-video-ad").style.visibility = "visible", window.adplayer.startPreRoll();
}); else if ("cg" === e) if (window.CrazyGames) {
var a = window.CrazyGames.CrazySDK.getInstance(), o = {
ad_started: function() {
vr("ad_started");
},
ad_finished: function() {
vr("ad_finished", arguments), a.removeEventListener("adStarted", o.ad_started), 
a.removeEventListener("adFinished", o.ad_finished), a.removeEventListener("adError", o.ad_error), 
GLOB[gn[7]](!0);
},
ad_error: function() {
vr("ad_error", arguments), a.removeEventListener("adStarted", o.ad_started), a.removeEventListener("adFinished", o.ad_finished), 
a.removeEventListener("adError", o.ad_error), GLOB[gn[7]](!1);
}
};
a.addEventListener("adStarted", o.ad_started), a.addEventListener("adFinished", o.ad_finished), 
a.addEventListener("adError", o.ad_error), a.requestAd("midgame");
} else vr("!window.CrazyGames"), GLOB[gn[7]](!1); else if ("gd" === e) "undefined" != typeof gdsdk && "undefined" !== gdsdk.showBanner ? gdsdk.showBanner() : GLOB[gn[7]](!1); else if ("lsm" === e) {
$("#lsm-video-ad").empty();
LSM_Slot({
adkey: "dd6",
ad_size: "640x480",
slot: "slot1231290",
_ad_type: "vast_banner",
_render_div_id: "lsm-video-ad",
_onload: function(e) {
"error" === e.state() ? (sc("#lsm-video-ad", 0)(), GLOB[gn[7]](!1)) : sc(0, "#lsm-video-ad", "flex")();
},
_onhide: function() {
sc("#lsm-video-ad", 0)(), GLOB[gn[7]](!0);
}
});
} else GLOB[gn[7]](!0);
};
var e = GLOB[gn[9]] = 3;
GLOB[gn[16]] = function() {
try {
var e = JSON.parse(Q.$bs(gn[15])), t = Object.keys(SETTINGS_DEFAULT), n = pn[0].$b8;
if ("number" == typeof e.player_clr_ind || "number" != typeof e.player_hue || !(e.player_hue >= 0 && e.player_hue < 360)) {
var r = "number" == typeof e.player_clr_ind && 2 !== e.player_clr_ind ? e.player_clr_ind : xe() * (n.length - 3) | 0;
e.player_hue = n[r][5];
}
return t.forEach(function(t) {
null == e[t] && (e[t] = SETTINGS_DEFAULT[t]);
}), Object.keys(e).forEach(function(n) {
t.indexOf(n) < 0 && delete e[n];
}), e;
} catch (e) {}
return SETTINGS_DEFAULT;
}, GLOB[gn[17]] = function(e) {
Q.$br(gn[15], JSON.stringify(e));
};
var t = parseInt(GLOB[gn[4]]()), n = parseInt(GLOB[gn[5]]());
t - n > e ? Q.$br(gn[11], (t - e).toString()) : t < n && Q.$br(gn[10], (n + e).toString());
for (var r = 0, i = [ "/tp" ]; r < i.length; ++r) {
var a = {
path: i[r]
};
Q.$bt(gn[10], a), Q.$bt(gn[11], a), Q.$bt(gn[15], a);
}
}
}();
var hc = {
$bz: (On ? [ "Slide with a finger to change direction", "Press anywhere with another finger to accelerate" ] : [ "Move mouse to change direction", "Hold left mouse button or Space to accelerate" ]).concat([ "To join a private room, enter '@' symbol and\nthe room name right after your nickname.", "Avoid collisions!" ]),
$c0: 0,
$c3: 100,
$by: [ 400, 3e3 ],
$bv: !1,
$c1: function(e) {
if (Zc().$jk === Vt) {
var t = hc, n = $("#hint"), r = parseInt(n.css("opacity"));
e && hc.$c2(), 0 === r ? (n[0].innerText = t.$bz[t.$c0], t.$c0 = (t.$c0 + 1) % t.$bz.length, 
n.css("opacity", 0).animate({
opacity: 1
}, t.$by[0], function() {
t.$bv = setTimeout(t.$c1, t.$by[1]);
})) : n.animate({
opacity: 0
}, r * t.$by[0], t.$c1);
}
},
$c2: function() {
var e = hc;
$("#hint").css("opacity", 0).stop(), e.$c0 = 0, e.$bv && (clearTimeout(e.$bv), e.$bv = 0);
}
};
function dc() {
var e = Zc();
e.$qc("#root");
e.$jk === Vt ? e.$qs.$hk = go(e.$le) : e.$jk !== Wt && e.$jk !== Xt || (e.$k6.$hk = go(e.$le)), 
e.$p1() ? (e.$po(), e.$pn(), e.$kw = e.$kw || 1, e.$qe(), e.$jk === Ht && Rc()) : e.$jk === Vt && (e.$qq(), 
Rc());
}
var pc = "Connection lost.<br>Reloading the game...", fc = function(e) {
return "An error " + (e.length ? "(#" + e + ") " : "") + "occured.<br>Restarting the game...";
}, mc = "A new update is available.<br>Reloading the game...", gc = "Could not connect to game servers.<br>Either some errors occured, or your network admin may block the connection.<br>Trying again...", vc = "Connection lost.<br>Please send the content of your browser console (" + ((navigator.userAgent || navigator.vendor).match("Macintosh") ? "Cmd+Alt+J" : "Ctrl+Shift+J") + " to open) to our mailbox<br>hello@gulper.io to help us resolve the problem.", yc = "Connection lost.<br>Reloading the game...", $c = "If you want to support the game, please disable your ad-blocker for this website.", bc = 8e3, xc = 16e3, wc = 5e3, _c = 15e3, Mc = 500, Sc = 10, Ac = "GB|NL|IE|FR|SP|IT|DE|NO|SE|PT|PL|CH|AT|UA|RU|FI|BE|CZ|HU|DK|MT|GR|RO:eu:na,US|CA|MX:na:eu,BR|CO|PE|EC|AR|BO|VE:sa:na,AU|NZ:au:as,JP|KR|IN|CN|VN|ID|PH|AE|SG|HK|MY|TR|TW|PK|AR|EG|SA:as:eu,ZA:eu:as".split(",").map(function(e) {
return (e = e.split(":"))[0] = e[0].split("|"), e;
});
function Tc(e, t, n) {
Z("err-msg", t, CLIENT.startsWith("web") ? n : void 0), sc("#root", "#err-msg", "table")();
var r = Zc && Zc();
r && r.$p3(), "number" != typeof e || r && r.$mq || (setTimeout(ie, e), r && (r.$mq = !0, 
r.$cl && (r.$cl.onmessage = null), r.$q3()));
}
function Lc() {
return document.location.href.match(new RegExp("srv=([^&]+)"));
}
var Cc = "", Ec = 0;
var Pc = 0, kc = .98, Oc = .98, Dc = [ "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=computers_accesories&banner=0NV31AZ41KKDDTDR72G2&f=ifr&linkID=464810862cbf7394ffa5abefb4d28efb&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=computers_accesories&banner=11MDDMDHHT6YH817MWG2&f=ifr&linkID=8b51e33ba8d771b9b4ade4e583884c6c&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=computers_accesories&banner=1V8BQQ7AKZ0AZG0J1T02&f=ifr&linkID=01d6b9fbf7975170b8d6b84693d36ca4&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=computers_accesories&banner=09Q6XEEM657J1ENNBB02&f=ifr&linkID=59f0c3d47d89502abe8a46aee4cd89f2&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=13&l=ur1&category=gourmet&banner=01JS6W4RYN6KHF871E82&f=ifr&linkID=21071f3cbf420ea147ca7909fa61f94e&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=toysandgames&banner=0XGKBZSJ0Z6677333Q02&f=ifr&linkID=5d5047c200ca1492eafbe70ed3750118&t=gulperio-20&tracking_id=gulperio-20", "//rcm-na.amazon-adsystem.com/e/cm?o=1&p=48&l=ur1&category=videogames&banner=0RP1XBKTDEQSB59EMQG2&f=ifr&linkID=741efe370d452160de546b3553b09a9b&t=gulperio-20&tracking_id=gulperio-20" ];
function Nc() {
var e = "none" === $("#game-stats").css("display"), t = $(e ? "#start" : "#game-stats-inner")[0].getBoundingClientRect(), n = window.innerHeight - (e ? 1.6 : 0) * parseInt($(document.body).css("font-size")), r = 0 | Ur(t.bottom, n, .5);
return [ n - t.bottom, r, n ];
}
function Ic(e, t) {
var n = (t = $(t)).width(), r = t.height();
if (t.hasClass("banner-bottom")) {
var i = Nc(), a = i[0], o = i[1], s = i[2], c = Me(1, kc * window.innerWidth / n, (a - (window.innerHeight - s)) / r * Oc, .5 * window.innerHeight / r);
t.css("transform", 1 !== c ? "scale(" + c + ")" : "").css("top", o - .5 * c * r + "px");
} else {
var l = $("#game-stats-inner")[0].getBoundingClientRect();
t.hasClass("banner-left") ? t.css("transform", "").css("top", _e(l.top, l.top + .5 * (l.height - r)) + "px").css("left", Me(l.left - n, .5 * (.5 * (window.innerWidth - l.width) - n)) + "px") : t.hasClass("banner-right") && t.css("transform", "").css("top", _e(l.top, l.top + .5 * (l.height - r)) + "px").css("left", _e(l.right, window.innerWidth - .5 * (.5 * (window.innerWidth - l.width) + n)) + "px");
}
return c;
}
function Rc() {
return $.each($(".banner-area"), function(e, t) {
Ic(0, t);
}), 1;
}
function jc(e) {
var t = window.CrazyGames && window.CrazyGames.CrazySDK.getInstance();
t && e in t && (console.log(new Date().toISOString() + ": crazysdk." + e), t[e]());
}
function Uc() {
if ("app/ios" !== CLIENT) {
if (window.ADS_BLOCKED && !oe()) {
var e = "#gulper-io_300x250";
return (u = $(e)).css("left", "calc(50% - 0.5*300px)").removeClass("banner-bottom banner-left banner-right").addClass("banner-bottom"), 
Rc(), sc(0, e, "table")(), void $(".banner-placeholder").html($c);
}
$(".banner-area").css("outline-width", 0);
var t = GLOB[gn[14]](BANNER_AD_PROVIDERS);
if ("adinplay" === t || "cg" === t) {
$(".banner-area").empty();
var n = function(e, n, r, i) {
var a = "#gulper-io_" + e + "x" + n, o = $(a), s = $("#game-stats-inner")[0].getBoundingClientRect(), c = "none" === $("#game-stats").css("display");
o.removeClass("banner-bottom banner-left banner-right"), 300 !== e || 0 === Pc || c || e > .5 * kc * (window.innerWidth - s.width) ? (o.css("left", "calc(50% - 0.5*" + e + "px)").addClass("banner-bottom"), 
Rc()) : 1 & Pc ? (o.addClass("banner-left"), Ic(0, o[0])) : 2 & Pc && (o.addClass("banner-right"), 
Ic(0, o[0])), o.length && (sc(".banner-placeholder", a, "table")(), "adinplay" === t ? aiptag.cmd.display.push(function() {
aipDisplayTag.display(a.substring(1));
}) : r([ i ? {
containerId: a.substr(1),
size: e + "x" + n
} : a.substr(1) ]));
};
if ("cg" === t) {
var r = Nc(), i = window.CrazyGames && window.CrazyGames.CrazySDK.getInstance();
if (i) if (i.requestResponsiveBanner) {
var a = 0 | Me(window.innerWidth * kc, window.screen.width > 1280 ? 970 : 728), o = 0 | Me(r[0] * Oc, 280), s = o < 150 ? 90 : 250, c = 90 === s ? 728 : 300;
o < s && (a = Ne(a * s / o), o = s), a < c && (o = Ne(o * c / a), a = c), $(".banner-area").first().prop("id", "gulper-io_" + a + "x" + o).width(a).height(o), 
n(a, o, function(e) {
vr("crazysdk.requestResponsiveBanner " + a + "x" + o), i.requestResponsiveBanner(e);
}, !1);
} else i.requestBanner ? r[0] * Oc < 250 ? n(728, 90, function(e) {
vr("crazysdk.requestBanner 728x90"), i.requestBanner(e);
}, !0) : n(300, 250, function(e) {
vr("crazysdk.requestBanner 300x250"), i.requestBanner(e);
}, !0) : vr("CrazySdk: no banner request function"); else vr("!window.CrazyGames");
} else n(300, 250);
} else if ("lsm" === t) {
var l = [ 300, 250 ];
(u = $("#gulper-io_300x250")).empty(), u.css("left", "calc(50% - 0.5*" + l[0] + "px)"), 
Rc(), sc(".banner-placeholder", "#gulper-io_300x250", "table")(), LSM_Slot("web/fb" === CLIENT ? {
adkey: "53f",
ad_size: "300x250",
slot: "slot1231291",
_render_div_id: "gulper-io_300x250"
} : {
adkey: "deb",
ad_size: "300x250",
slot: "slot1231292",
_render_div_id: "gulper-io_300x250"
});
} else if ("amazon" === t) {
var u = $("#gulper-io_728x90"), h = (l = [ 728, 90 ], document.createElement("iframe"));
u.empty(), u.css("outline", "none"), h.src = Dc[xe() * (Dc.length - .001) | 0], 
h.width = "728", h.height = "90", h.scrolling = "no", h.style.border = "none", h.frameBorder = "0", 
u[0].appendChild(h), sc(".banner-placeholder", "#gulper-io_728x90", "table")();
var d = Rc();
u.css("left", .5 * (window.innerWidth - u.width() * d) + "px");
}
} else sc(".banner-area", 0)();
}
var Bc = 0;
function zc(e, t) {
var n = Zc(), r = GLOB[gn[4]](), i = r - (GLOB[gn[9]] > 2 ? 0 : 1) - GLOB[gn[5]](), a = .001 * (Date.now() - Bc);
n.$mk = Ar(), n.$ml = -0, n.$mo = !1, dr || (!GLOB[gn[2]] || !CLIENT.startsWith("app/")) && r >= 3 && (i >= GLOB[gn[9]] && a > 60 || i > 1 && a > 300 || a > 1800) ? (Bc = Date.now(), 
ue.push("sp1rt " + (0 | Ar())), n.$jk === Ht && n.$pv(Uint8Array.of(fa)), GLOB[gn[7]] = function(t) {
ue.push("sp1p " + (0 | Ar())), GLOB[gn[7]] = ne, n.$mk = -0, n.$ml = Ar(), t && GLOB[gn[6]](), 
e(n.$mo), n.$kw = n.$kw || 1;
}, GLOB[gn[8]]()) : (ue.push("sp0rt " + (0 | Ar())), n.$ni = setTimeout(function() {
ue.push("sp0p " + (0 | Ar())), n.$mk = -0, n.$ml = Ar(), n.$ni = 0, e(n.$mo), n.$kw = n.$kw || 1;
}, t || 0));
}
function Fc(e) {
ie();
}
function Gc(e, t) {
return t || (e.cancelable && e.preventDefault ? e.preventDefault() : !0 !== e.defaultPrevented && (e.returnValue = !1)), 
e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0, !1;
}
function Vc() {
var e = GLOB[gn[16]]();
return delete e.last_nick, JSON.stringify(e);
}
function Wc(e) {
e = e || GLOB[gn[16]](), Hr($("#graph-qual")[0], We[e.graph_qual]), $("#framerate").length && Hr($("#framerate")[0], e.low_fps ? "normal" : "high"), 
Hr($("#show-lbrd")[0], e.show_lbrd ? "visible" : "hidden"), Hr($("#show-nicks")[0], e.show_nicks ? "visible" : "hidden"), 
Hr($("#show-map")[0], e.show_map ? "visible" : "hidden"), Hr($("#show-flags")[0], e.show_flags ? "visible" : "hidden"), 
Hr($("#show-flashes")[0], e.show_flashes ? "on" : "off"), Hr($("#switch-rooms")[0], 0 === e.switch_rooms ? "off" : 1 === e.switch_rooms ? "manual" : "auto"), 
On && Hr($("#controls")[0], 1 === e.controls ? "arrow" : "joystick");
}
function qc(e) {
return function(t) {
var n = GLOB[gn[16]]();
n[e] = "graph_qual" === e ? (n[e] || We.length) - 1 : "switch_rooms" === e ? n[e] ? 0 : 2 : n[e] ? 0 : 1, 
Wc(n), GLOB[gn[17]](n);
};
}
function Hc(e) {
var t = e.target, n = (t.selectionStart, t.selectionEnd), r = Oa(t.value), i = FromString(r[0]).slice(0, en), a = FromString(r[2]).slice(0, tn);
t.value = ToString(i) + (r[1] ? "@" : "") + ToString(a), t.setSelectionStart = t.selectionEnd = n;
}
window.toggle_ctrl_btn = function(e, t, n) {
var r = $(e).stop();
t ? n ? r.css("opacity", 0).css("z-index", "").animate({
opacity: 1
}, n, function() {
$(this).css("opacity", "").css("pointer-events", "");
}) : r.css("opacity", "").css("pointer-events", "") : n ? r.css("opacity", 1).css("pointer-events", "none").animate({
opacity: 0
}, n, function() {
$(this).css("z-index", -1);
}) : r.css("opacity", 0).css("pointer-events", "none").css("z-index", -1);
}, _o.prototype.$rc = function() {
var e = this, t = e.$hf, n = Array.of(_r(t.$aw[1][0] >>> 8), "#50f0ff", "#00ff80", "#ff7030", "#ff7030");
$("#lbrd").css("border-color", t.$be[3]), $(".overlay, #game-stats-inner").css("background-color", t.$bf), 
$("#game-stats-inner").css("background-color", "rgba(" + parseInt(t.$bf.slice(1, 3), 16) + "," + parseInt(t.$bf.slice(3, 5), 16) + "," + parseInt(t.$bf.slice(5, 7), 16) + ",0.5)"), 
$(".overlay, .body .text, #nick-input, #game-stats-inner").css("border-color", t.$bg), 
$(".overlay .text, #nick-input").css("background-color", t.$bh), $("#root, a, #room-wait-msg").css("color", t.$bi), 
$(".banner-area").css("outline-color", t.$bl), $(".overlay .text-title, .sel-text").css("color", t.$bj), 
$("a, .footnote-link, .text-switch").not("#info *").hover(function() {
$(this).css("color", t.$bj);
}, function() {
$(this).css("color", t.$bi);
}), $(".footnote-link-inv").css("color", _r(t.$ay[2])).css("background-color", t.$bi), 
$("#more-games-link").css("border-color", t.$bi).hover(function() {
$(this).css("color", t.$bj).css("border-color", t.$bj);
}, function() {
$(this).css("color", t.$bi).css("border-color", t.$bi);
}), $(".msg-link").css("color", "").unbind("mouseenter").unbind("mouseleave"), "default" === $("#changelog-link").css("cursor") && $("#changelog-link").unbind("mouseenter").unbind("mouseleave"), 
$(".ctrl-common").css("color", t.$bk);
var r = 0;
function i() {
0 == r++ && $(this).css("border-color", t.$bk).css("background-color", t.$bk).css("color", t.$bh);
}
var a = $("#nick-input");
a.css("border-color", t.$bl).addClass("placeholder-color" + pn.indexOf(t)), K.$bp(a[0], "touchstart", i, {
passive: tr
}), a.on("mouseenter focus", i).on("mouseleave touchend blur", function() {
0 == --r && $(this).css("border-color", t.$bl).css("background-color", t.$bh).css("color", t.$bi);
}), K.$bp(document.body, "touchstart", ic, {
passive: tr,
capture: !0
}), $(".ctrl-btn").each(function(t, n) {
var r = e.$hf.$bo[n.id.replace(/-btn$/, "")] || e.$hf.$bo["close-btn"];
function i(e) {
return e ? function() {
$(this).css("stroke", _r(r[1]));
} : function() {
$(this).css("stroke", _r(r[0]));
};
}
On ? (K.$bp(n, "touchstart", i(!0), {
passive: tr
}), $(n).on("touchend", i(!1))) : $(n).hover(i(!0), i(!1)), i(!1).call(n), "rmads-btn" === n.id ? $("#rmads-icon text").attr("fill", _r(r[0])) : "restore-iap-btn" === n.id && $("#restore-iap-icon polygon").attr("fill", _r(r[0]));
}), $("#to-top-btn").css("stroke", $("#nick-input").css("background-color")).css("fill", Zo(16777215, 64));
for (var o = 0, s = "start,restart,main-menu,abort".split(","), c = _r(t.$ay[0]); o < s.length; ++o) !function(e) {
var t = n[e], r = 0 === e ? "blinking-btn" : "dummy", i = $("#" + s[e] + "-btn");
function a() {
$(this).css("background-color", t).css("color", c).removeClass(r);
}
i.css("border-color", t).css("background-color", "transparent").css("color", t).addClass(r).on("mouseenter", a).on("mouseleave touchend touchcancel", function() {
$(this).css("background-color", "transparent").css("color", t).addClass(r);
}).on("click", function() {
"start" === s[e] && re("event", "start-settings", {
event_label: Vc()
}), re("event", "click", {
event_label: s[e] + "-btn"
});
}), On && K.$bp(i[0], "touchstart", a, {
passive: tr
});
}(o);
$("#game-stats").css("color", _r(e.$hf.$bd[0])), $("#final-score,#top-rank,#time-alive").css("color", _r(e.$hf.$bd[1])), 
$("#lbrd").css("background-color", e.$hf.$be[0]).css("color", e.$hf.$be[1]), $("#lbrd-title").css("color", e.$hf.$be[2]), 
$("#stats").css("color", _r(e.$hf.$bc[0])), $("#stats-fps,#stats-ping,#stats-score,#stats-rank,#stats-num-players").css("color", _r(e.$hf.$bc[1])), 
$("html,#info").css("background-color", e.$hf.$bm), Xn = new $3.Color(t.$ay[0]);
};
var Xc = 8, Yc = !1, Jc = null, Zc = function() {
return Jc;
}, Kc = !1;
function Qc(e, t) {
var n, r = 0, i = new Array(e || 100), a = 0;
function o(e) {
Kc = !1, clearTimeout(a), a = 0;
}
Kc || (Kc = !0, a = setTimeout(o, 1e3 + 1e3 * e / 30, !0), jn(function e(t) {
if (n && (i[r++] = t - n), r < i.length) jn(e), n = t; else {
i.sort(function(e, t) {
return e - t;
}), i.slice().map(function(e) {
return Number(e).toFixed(3);
});
for (var a = new Array(), s = 0; s < i.length; ++s) {
var c = 0 | Math.round(i[s]), l = a[c];
l || (l = a[c] = new Array()), l.push(i[s]);
}
var u = new Array();
function h(e) {
return e[e.length >>> 1];
}
a.forEach(function(e) {
e.sort(function(e, t) {
return e - t;
}), u.push(e);
}), (a = u).sort(function(e, t) {
return t.length - e.length;
});
var d = 1e3 / h(a[a.length > 1 && Pe(2 - h(a[0]) / h(a[1])) < .1 && a[0].length / a[1].length < 2 ? 1 : 0]), p = [ 240, 165, 144, 120, 90, 75, 64, 60, 50 ].concat(Dn ? [ 48, 30, 0 ] : [ 40, 30, 0 ]).find(function(e, t, n) {
return t < n.length - 1 && Pe(e - d) + .001 < Pe(d - n[t + 1]);
}) || 60;
Bo = Ze = p, Ke = 1e3 / p, ee.$8n(1e3 / p), Math.abs(p - d), vr("max_fps = " + Ze + " raw_fps = " + d), 
Jc && Jc.$mi && Bo !== Jc.$mi[0].length && (Jc.$mi = [ new Float64Array(Bo), new Float64Array(Bo) ], 
Jc.$mi[0].fill(1e3 / Ze), Jc.$mi[1].fill(1e3 / Ze), Jc.$mj = Uint32Array.of(1, 1)), 
o();
}
}));
}
function el(e) {
var t = Zc();
t.$jk === Vt && "visible" === t.$qc("#overlay-bg").css("visibility") && 0 !== se("root").getBoundingClientRect().top && lc(!1)();
var n = _e(0, zr(Me(1, window.scrollY / window.innerHeight), .33, 1));
return t.$qc("#to-top-btn").css("opacity", n).css("pointer-events", n > 0 ? "initial" : "none"), 
Gc(e, tr);
}
function tl() {
return window.location.hash.startsWith("#r");
}
function nl(e) {
window.history.replaceState({}, "", window.location.pathname + window.location.search + (e ? "#r" + e : ""));
}
ee.$8n(1e3 / Ze), JS_SUPPORT && ($(window).on("load", function e() {
if (!Yc && (Yc = !0, !function() {
var e, t = null, n = CLIENT.startsWith("app/") ? "device" : "device/browser", r = "webgl,experimental-webgl".split(",");
try {
if (e = document.createElement("canvas"), window.WebGLRenderingContext) for (var i = 0; i < r.length && !(t = e.getContext(r[i])); ++i) ;
} catch (e) {}
function a() {
Tc(null, "Your " + n + " does not support WebGL or WebGL is disabled." + (CLIENT.startsWith("app/") ? "" : "<br>Please make sure that your browser is up-to-date and that WebGL is enabled."), [ "What is WebGL?", "https://get.webgl.org" ]);
}
if (t) {
var o = [ {
antialias: !1,
alpha: !1,
depth: !1,
stencil: !1
}, {
antialias: !1,
alpha: !0,
depth: !1,
stencil: !1
} ];
for (i = 0; i < o.length; ++i) {
try {
for (var s = 0; s < r.length && !(t = e.getContext(r[s], o[i])); ++s) ;
} catch (e) {}
if (!t) return de("/cw_" + JSON.stringify(o[i])), a(), !1;
}
if ([ "ANGLE_instanced_arrays", "EXT_blend_minmax" ].every(function(e) {
return t.getExtension(e);
})) return !0;
Tc(null, "Your " + n + " does not support the required WebGL extensions.", [ "What is WebGL?", "https://get.webgl.org" ]);
} else window.WebGLRenderingContext ? a() : Tc(null, "Your " + n + " does not support WebGL.", [ "What is WebGL?", "https://get.webgl.org" ]);
return !1;
}())) {
var t = tl() ? parseInt(window.location.hash.substr(2)) - 1 : 3;
return nl(t), void (t && ie());
}
if (tl() && nl(0), window.WebSocket || CLIENT.startsWith("app/")) if (GLOB[gn[1]] && --Xc > 0) setTimeout(e, 1e3); else {
var n;
if (!(n = (n = document.referrer.match(/gameflarex\.com|noobgamer\.club/)) && n[0]) && document.referrer.match(/vseigru\.net|iogames\.space/)) try {
for (var r = window.location.ancestorOrigins, i = r.length - 1; !n && i >= 0; --i) r[i].match(/(www\.)?(gamefree\.games|playjolt\.com|(juegosfriv201[\d]\.(com|org|net))|friv-2017\.net|friv2019\.com\.br|friv2019com\.com|al3abmizo\.com|asronlinegames\.com|gamemonetize\.com)|gameflarex\.com|noobgamer\.club/) && (n = r[i]);
} catch (e) {}
if (vr("performance.now = " + !(!performance || !performance.now) + "\ntimeOrigin = " + performance.timeOrigin + "\nnavigationStart = " + (performance.timing && performance.timing.navigationStart) + "\niframed = " + !!oe() + "\nmobile = " + On + "\npixel ratio = " + window.devicePixelRatio + "\nreferrer = '" + document.referrer + "'\ndomain = '" + document.domain + "'"), 
n) return de("/gotcha_" + encodeURIComponent(n)), $("#err-msg .msg-link").on("click", function(e) {
return window.location.href = "https://google.com", Gc(e);
}), void Tc(null, "The game is blocked on this domain by the owner. Official game website:", [ "https://gulper.io", "https://gulper.io/" ]);
jc("sdkGameLoadingStart"), Jc = new _o();
try {
ls(Jc.$l5 = JSON.parse($("#init-lbrd-json")[0].textContent));
} catch (e) {
console.error("Cannot parse leaderboard data: " + e);
}
$("#start-btn,#restart-btn").on("click", function(e) {
jc("sdkGameLoadingStart"), Jc.$p8(Yt);
}), $("#main-menu-btn,#abort-btn").on("click", function(e) {
Jc.$p8(Zt);
}), yo(!0), $("#lbrd-btn").on("click", function() {
lc(!0, "#topscores")(), Jc.$qh();
}), $("#contact-btn").on("click", lc(!0, "#contact")), "lbrd,nicks,map".split(",").forEach(function(e) {
$("#show-" + e).on("click", qc("show_" + e));
}), $("#graph-qual").on("click", qc("graph_qual")), $("#framerate").on("click", qc("low_fps")), 
$("#show-flags").on("click", qc("show_flags")), $("#show-flashes").on("click", qc("show_flashes")), 
$("#switch-rooms").on("click", qc("switch_rooms")), K.$bp(window, "scroll", el, {
passive: tr,
capture: !0
}), On ? $("#controls").on("click", qc("controls")) : $("#settings-controls").remove(), 
CLIENT.startsWith("app/") || $("#game-stats").addClass("game-stats-non-app"), CLIENT.startsWith("app/") && $("#app-store-badge").remove(), 
$("#settings-btn").on("click", function() {
Wc(), lc(!0, "#settings")();
}), $(".ctrl-btn").each(function(e, t) {
t.id.length && K.$bp(t, "click", function() {
re("event", "click", {
event_label: t.id
});
});
});
var a = $("#nick-input")[0].value, o = GLOB[gn[16]]();
if (0 === a.length && "string" == typeof o.last_nick) try {
$("#nick-input")[0].value = o.last_version === Fe ? decodeURIComponent(escape(window.atob(o.last_nick))) : "";
} catch (e) {
o.last_nick = "", GLOB[gn[17]](o);
}
o.last_version !== Fe && (o.last_version = Fe, o.last_ws = "", GLOB[gn[17]](o)), 
GLOB[gn[12]] && "app/ios" === CLIENT && "app-store-rate,rmads,restore-iap".split(",").forEach(function(e) {
$("#" + e + "-btn").on("click", GLOB[gn[12]](e));
}), window.toggle_ctrl_btn("#rmads-btn", GLOB[gn[0]], 0), $(".close-btn,#overlay-bg").on("click", function() {
lc(!1)(), $(".topscores-tabs, #topscores .body .text").html("");
}), Jc.$l7 = !document.hasFocus() * Ar(), $(window).on("blur", oc).on("focus", function(e) {
!function(e) {
ue.push("fs " + (0 | Ar()));
var t = Zc();
t.$l7 = -0, t.$jk === Vt || t.$mq || (t.$p2(), t.$jk === qt && (t.$kw = t.$kw || 1, 
se("main-canvas").focus()));
}(), dc();
}).on("resize", dc), K.$bp(window, "message", function(e) {
e.data === Jc.$o8 ? (fo(Jc.$o8), Jc.$o8 = null) : Jc.$l7 && e.data === Jc.$l8 && (--Jc.$l8, 
ho());
}, !1), K.$bp($("#main-canvas")[0], "webglcontextlost", Fc), K.$bp($("#aux-canvas")[0], "webglcontextlost", Fc), 
$("*").on("dragstart contextmenu", Gc), $("#current-year").html(new Date().getFullYear());
try {
var s = JSON.parse($("#changelog-json")[0].textContent);
for (i = 0; i < s.length - 1 && Fe >= s[i + 1][0]; ++i) ;
s.length > 3 && !CLIENT.startsWith("app/") ? $("#changelog-link").html("v" + s[i][1]).on("click", function() {
re("event", "click", {
event_label: "changelog"
}), lc(!0, "#changelog")();
}) : $("#changelog-link").html("v" + s[i][1]).css("cursor", "default").css("text-decoration", "none");
for (var c = ""; i >= 0; --i) c += '<li class="text-title">' + s[i][1].replace(/[^0-9.]*([0-9.]+).*/, "$1") + (s[i][2] ? " &mdash; " + s[i][2] : "") + "</li>" + (s[i].length > 3 ? "<ul>" + s[i].slice(3).reduce(function(e, t) {
return e + "<li>" + t + "</li>";
}, "") + "</ul>" : "") + (i > 0 ? "<br>" : "");
$("#changelog .text-list").html(c);
} catch (e) {
$("#changelog-link").html(""), console.error("Cannot parse changelog data: " + e);
}
if ($("#changelog-link").prop("href", "javascript:void(0);"), $(".mailto-hello").on("mouseover", function() {
$(this).prop("href", "mailto:" + $(this)[0].innerText);
}), K.$bp($("#nick-input")[0], "input", Hc), oe() || 0 === $("#info").length) $("#info").children().eq(1).detach().appendTo("#about"), 
$("#info").children().eq(2).detach().appendTo("#qa"), $("#info").remove(), $("#about-link").prop("href", "javascript:void(0);").on("click", function(e) {
e.originalEvent.preventDefault(), re("event", "click", {
event_label: "about"
}), lc(!0, "#about")();
}), $("#privacy-link").prop("href", "javascript:void(0);").on("click", function(e) {
e.originalEvent.preventDefault(), re("event", "click", {
event_label: "privacy"
}), lc(!0, "#privacy")();
}), $("#qa").length && $("#qa .text").html().trim(" ").length > 0 ? $("#qa-btn").on("click", lc(!0, "#qa")) : $("#qa-btn").remove(), 
$(".ctrl-btn,#clr-select-area,#app-store-badge,#start,#footnote,#aux-canvas,#room-wait-info,#social").not(".close-btn").css("position", "fixed"); else {
sc(0, "#info")();
var l = $("#info-about-title")[0].getBoundingClientRect().top, u = $("#info-qa-title")[0].getBoundingClientRect().top;
$("#about,#privacy,#qa").remove(), $("#about-link").prop("href", "javascript:void(0);").removeProp("target").removeProp("rel").on("click", function(e) {
e.originalEvent.preventDefault(), re("event", "click", {
event_label: "about"
}), cc(l, !0);
}), $("#qa-btn").on("click", function() {
cc(u, !0);
});
}
Jc.$rc(), 0 !== pn.indexOf(Jc.$hf) && $("link[rel*='icon']").prop("href", $("link[rel*='icon']").prop("href").replace(".png", "_" + (pn.indexOf(Jc.$hf) + 1) + ".png")), 
$("#info *").not(".mailto-hello *, .keep-style").each(function(e, t) {
$(t).removeAttr("style");
}), $("#to-top-btn").on("click", function() {
cc(0, !0);
}), Jc.$qr();
var h = $("#footnote,#social,.ctrl-btn,#start,#clr-select-area");
h.css("opacity", 1 / 255).css("pointer-events", "none"), setTimeout(function() {
0 === $(".fb-like").width() && $(".fb-like").css("display", "none"), h.animate({
opacity: 1
}, xs), setTimeout(function() {
h.stop().css("opacity", "").css("pointer-events", ""), jc("sdkGameLoadingStop");
}, xs);
}, ws), window.aiptag && setTimeout(function() {
Jc.$jk === Vt && !window.aiptag.gdprShowConsentToolButton && !window.aiptag.gdprConsent && (window.aiptag.gdprShowConsentToolButton = !0);
}, ws + bs), sc("#err-msg,.banner-area", "#root")(), setTimeout(hc.$c1, hc.$c3, !0), 
$("#nick-input").prop("placeholder", "Nickname"), qn && Uc(), setTimeout(Qc, 0, 200, !0), 
setInterval(function() {
if (Ca) {
if (Io(Jc.$cl) && Jc.$qu()) {
if (Ar() - Ca < 3 * Jc.$o2) return;
Xi(Ta, It + Pt, qi(Ta, It) + Ar() - Ca), Jc.$pv(Aa);
}
Ca = 0;
}
}, 1e4 / 60), lr && ((cr = Mo(ur)).onmessage = function(e) {
window.postMessage(e.data, "*");
}), "OffscreenCanvas" in window && !OffscreenCanvas.prototype.getContext && de("/osc " + wo(1, 1));
} else Tc(null, "Your browser does not support the WebSocket API.", [ "What is WebSocket?", "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" ]);
}), window.onbeforeunload = function() {
Tc(null, "Finishing..."), cc(0, !1);
});
}();
